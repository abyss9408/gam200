This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.repomixignore
App.cpp
App.h
AssetStore/AssetLoader.cpp
AssetStore/AssetLoader.h
AssetStore/AssetStore.cpp
AssetStore/AssetStore.h
ChartEditor/LevelChart.cpp
ChartEditor/LevelChart.h
Cloning/CloneEntityEvent.h
Cloning/CloneSystem.cpp
Cloning/CloneSystem.h
ECS/ECS.cpp
ECS/ECS.h
Engine/Engine.cpp
Engine/Engine.h
EventBus/Event.h
EventBus/EventBus.h
Hierarchy/HierarchySystem.cpp
Hierarchy/HierarchySystem.h
Hierarchy/ParentComponent.h
LoadingScreen/Loading.frag.glsl
LoadingScreen/Loading.vert.glsl
LoadingScreen/LoadingScreen.cpp
LoadingScreen/LoadingScreen.h
LoadingScreen/Splash.frag.glsl
Logging/Logger.cpp
Logging/Logger.h
PrefabManagement/Prefab.cpp
PrefabManagement/Prefab.h
PrefabManagement/PrefabEvent.h
PrefabManagement/PrefabInstanceComponent.h
PrefabManagement/PrefabManager.cpp
PrefabManagement/PrefabManager.h
PrefabManagement/PrefabRef.h
PrefabManagement/PrefabSyncSystem.cpp
PrefabManagement/PrefabSyncSystem.h
repomix.config.json
Runtime/RuntimeSystem.cpp
Runtime/RuntimeSystem.h
Serialization/ChartEditorSerialization.cpp
Serialization/ChartEditorSerialization.h
Serialization/SceneLoadedEvent.h
Serialization/Serialization.cpp
Serialization/Serialization.h
Serialization/SerializeTypes.cpp
Serialization/SerializeTypes.h
UI/FunctionRegistry.h
UI/UIComponent.h
UI/UISystem.cpp
UI/UISystem.h

================================================================
Files
================================================================

================
File: .repomixignore
================
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/

Audio/
Mono/
Precompiled/
Math/
Physics/
Collision/
Input/
Script/
Utilities/
PerformanceViewer/
Particles/
Animation/
Graphic/
Scene/
Camera/
Layering/
Transformation/
Editor/EditComponent.cpp
Editor/AssetStoreGUI.cpp
Editor/AssetsDragAndDrop.cpp
Editor/AutoSave.cpp
Editor/Changes.cpp
Editor/Changes.h
Editor/ChartEditor.cpp
Editor/Dockspace.cpp
Editor/EditorCameraControls.cpp
Editor/Viewports.cpp
Editor/UndoRedo.cpp
Editor/Style.cpp
Editor/ScriptDirectoryGUI.cpp
Editor/SceneLoadSave.cpp
Editor/PrefabEditor.cpp
Editor/LayerEditor.cpp
Editor/EntitySelectionInViewport.cpp
Editor/EditorRun.cpp
Editor/InGameCameraEdit.cpp
Editor/LogWindow.cpp
Editor/PerformanceGUI.cpp
Editor/

================
File: App.cpp
================
/******************************************************************************/
/*!
\file           App.cpp
\author         Team Popplio
\par            Course : CSD2401 / CSD2400
\par            Section : A
\date           2024/11/06
\brief
    This is the source file for the main application entry point into the main DLL.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

// Enable run-time memory check for debug builds.
#include <pch.h>

#include "App.h"

extern "C" DLL_EXPORT int App()
{
    // Enable run-time memory check for debug builds.
#if defined(DEBUG) | defined(_DEBUG)
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
#endif

    Popplio::Engine engine;

    engine.Initialize();
    engine.Run();
    engine.Destroy();

	return 0;
}

================
File: App.h
================
/******************************************************************************/
/*!
\file           App.h
\author         Team Popplio
\par            Course : CSD2401 / CSD2400
\par            Section : A
\date           2024/11/06
\brief
    This is the header file for the main application entry point into the main DLL.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once

#include "Engine/Engine.h"

#define DLL_EXPORT __declspec(dllexport)

/*
*   This is the main entry point for the Team_Popplio_PreDLL.
*   @returns int | The exit code of the core engine DLL.
*/
extern "C" DLL_EXPORT int App();

================
File: AssetStore/AssetLoader.cpp
================
/******************************************************************************/
/*!
\file   AssetLoader.cpp
\author Team Popplio
\author Val Tay Yun Ying
\co-author
\contribution Val - 100%
\par    Course : CSD2401
\par    Section : A
\date   2024/11/30
\brief
	This source file defines methods for the loading of assets into AssetStore.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>

#include "AssetStore.h"
#include "AssetLoader.h"
#include "../Serialization/ChartEditorSerialization.h"
#include "../PerformanceViewer/PerformanceViewer.h"

#include <filesystem>
#include <algorithm>
#include <rapidjson/document.h>
#include <rapidjson/istreamwrapper.h>
#include <rapidjson/prettywriter.h>
#include <rapidjson/stringbuffer.h>

namespace Popplio {
	namespace fs = std::filesystem;

	AudioSystem* AssetLoader::audioSystemRef = nullptr;
	LogicSystem* AssetLoader::logicSystemRef = nullptr;
	const std::string& AssetLoader::_metaExtension{ ".cyndaquil" };

	std::pair<std::vector<fs::path>, std::unordered_set<fs::path>> ListFilesRecursively(const fs::path& directory)
	{
		std::vector<fs::path> assetFiles;
		std::unordered_set<fs::path> metaFiles; // Use set for O(1) lookup

		// Estimate size for preallocation (not exact, but helps reduce reallocation)
		size_t fileCount = std::distance(fs::recursive_directory_iterator(directory), {});
		assetFiles.reserve(fileCount / 2); // Rough guess: half might be asset files

		for (const auto& entry : fs::recursive_directory_iterator(directory)) {
			if (entry.is_regular_file()) {
				const fs::path& filePath = entry.path();

				if (filePath.extension() == AssetLoader::_metaExtension) {
					metaFiles.insert(filePath);
				}
				else if (AssetLoader::IsAsset(filePath.filename().string())) {
					assetFiles.push_back(filePath);
				}
			}
		}

		return { assetFiles, metaFiles };
	}

	void AssetLoader::ReloadAssets()
	{
		auto [assetFiles, metaFiles] = ListFilesRecursively(fs::current_path());

		PerformanceViewer::GetInstance()->StartRealTime("GetMetaFiles");

		for (const fs::path& file : assetFiles) {
			fs::path metaPath = file;
			metaPath.replace_extension(AssetLoader::_metaExtension);

			// Faster lookup using unordered_set instead of fs::exists()
			if (metaFiles.find(metaPath) == metaFiles.end()) {
				Serializer::SerializeMetaFile(file);
			}

			if (!Serializer::DeserializeMetaFile(file)) {
				Logger::Warning("Unable to deserialize file: " + metaPath.string());
			}
		}

		PerformanceViewer::GetInstance()->EndRealTime("GetMetaFiles");
	}

	void AssetLoader::TotalWipe()
	{
		// find every file thats != folder
		auto [assetFiles, metaFiles] = ListFilesRecursively(fs::current_path());

		for (fs::path const& meta : metaFiles)
		{
			if (!fs::remove(meta))
				Logger::Warning("Unable to delete meta file: " + meta.filename().string());
		}

		//check for each assetfile if theres a meta equiv
		for (fs::path const& file : assetFiles)
		{
			std::string metaPath = file.filename().string();
			metaPath = metaPath.substr(0, metaPath.find('.')) + _metaExtension;

			if (!fs::exists(metaPath))
			{
				Serializer::SerializeMetaFile(file);
			}

			if (!Serializer::DeserializeMetaFile(file))
			{
				Logger::Warning("Unable to deserialize file: " + metaPath);
			}

		}
	}

	bool AssetLoader::IsAsset(const std::string& filename)
	{
		std::string extension = filename.substr(filename.find("."));
		if (extension == ".wav" || extension == ".png" || extension == ".vert" ||
			extension == ".frag" || extension == ".ttf" || extension == ".cpp" ||
			extension == ".h" || extension == ".scene")
		{
			if (filename == "fa-brands-400.ttf" || filename == "fa-regular-400.ttf" || filename == "fa-solid-900.ttf")
			{
				return false;
			}
			else
			{
				return true;
			}
		}
		else
		{
			return false;
		}
	}


	void AssetLoader::Setup(AudioSystem& audioRef, LogicSystem& logicRef)
	{
		audioSystemRef = &audioRef;
		logicSystemRef = &logicRef;
	}

	bool AssetLoader::LoadAudio(const char* filepath, const std::string& key, int channelGroup, float bpm, std::pair<int, int> timeSig)
	{
		//find the meta file with the same name
			// if dont have, generate one
			// otherwise deserialize the meta file and load the audio

		// meta file name
		try {
			audioSystemRef->SetAudio(filepath, key, audioSystemRef->GetCGroup(channelGroup), bpm, timeSig);
			return true;
		}
		catch (const std::exception&)
		{
			Logger::Error("Failed to load audio: " + std::string(filepath));
		}
		return false;
	}

	bool AssetLoader::LoadTexture(const std::string& filepath)
	{
		try {
			AssetStore::StoreTextureAsset(
				Serializer::GenerateAssetName(filepath),
				Texture(filepath).GetTextureID()
			);
		}
		catch (const std::exception&) {
			Logger::Error("Failed to load texture: " + filepath);
			return false;
		}
		return true;
	}

	bool AssetLoader::LoadShader(const std::string& filepath)
	{
		try {
			if (AssetStore::GetAllShaders().find(Serializer::GenerateAssetName(filepath)) != AssetStore::GetAllShaders().end()) return true;

			// remove extension from filepath
			std::string pathNoExtension = filepath.substr(0, filepath.find("."));
			AssetStore::StoreShaderAsset(
				Serializer::GenerateAssetName(filepath),
				std::make_unique<Shader>(pathNoExtension)
			);
		}
		catch (const std::exception&) {
			Logger::Error("Failed to load shader: " + filepath);
			return false;
		}

		return true;
	}

	bool AssetLoader::LoadFont(const std::string& filepath, std::list<unsigned int> fontsize)
	{
		// Generate an asset name based on the font path
		std::string assetName = Serializer::GenerateAssetName(filepath);

		// Create font instance with default size
		auto font = std::make_unique<Font>(filepath);

		// Load additional sizes
		for (const auto& size : fontsize) {
			font->LoadSize(size);
		}

		// Store the font
		try {
			AssetStore::StoreFontAsset(assetName, std::move(font));
		}
		catch (const std::exception&) {
			Logger::Error("Failed to load font: " + filepath);
			return false;
		}
		return true;
	}

	bool AssetLoader::LoadCPPScripts(const std::string& scriptClass)
	{
		try
		{
			logicSystemRef->LoadByName(scriptClass);
		}
		catch (const std::exception&)
		{
			Logger::Error("Failed to load script: " + scriptClass);
		}
		return true;
	}

	bool AssetLoader::LoadScene(const std::string& filepath)
	{
		// Generate an asset name based on the scene path
		std::string assetName = Serializer::GenerateAssetName(filepath);
		// Store the scene
		try {
			AssetStore::StoreSceneAsset(assetName, filepath);
		}
		catch (const std::exception&) {
			Logger::Error("Failed to load scene: " + filepath);
			return false;
		}
		return true;
	}
}

================
File: AssetStore/AssetLoader.h
================
/******************************************************************************/
/*!
\file   AssetLoader.h
\author Team Popplio
\author Val Tay Yun Ying
\co-author
\contribution Val - 100%
\par    Course : CSD2401
\par    Section : A
\date   2024/11/30
\brief
	This source file declares methods that can be called by any file for the loading of Assets into the AssetStore

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once
#include "../Serialization/Serialization.h"
#include "../Script/LogicSystem.h"
#include "../ChartEditor/LevelChart.h"
namespace Popplio
{
	class AssetLoader
	{
	public:
		AssetLoader() = delete;
		AssetLoader(const AssetLoader&) = delete;
		AssetLoader(AssetLoader&&) = delete;
		AssetLoader& operator=(const AssetLoader&) = delete;
		AssetLoader& operator=(AssetLoader&&) = delete;
		~AssetLoader() = delete;

		// extension for meta files
		static const std::string& _metaExtension;

		/**
		 * \brief Function to assign audio system and logic system for loader
		 */
		static void Setup(AudioSystem& audioRef, LogicSystem& logicRef);

		/**
		 * \brief Function to recheck if everything in assetstore matches the file directory
		 */
		static void ReloadAssets();

		/**
		 * \brief Function to regenerate every meta file back to it's default state
		 * USE ONLY IF THERE IS NO OTHER CHOICE!!!!
		 * WARNING!!! ALL YOUR META SETTINGS WILL BE GONE IF YOU CALL THIS!!!!
		 */
		static void TotalWipe();

		/**
		 * \brief Checker for if a file is a recognized asset
		 * \return Returns true if the file extension is a recognized asset
		 */
		static bool IsAsset(const std::string& filename);

		/**
		 * \brief Loads Audio Asset
		 * \return returns true if the asset can be loaded into memory
		 */
		static bool LoadAudio(const char* filepath, const std::string& key, int channelGroup, float bpm = 0.f, std::pair<int, int> timeSig = std::pair<int, int>{});
		/**
		 * \brief Loads Texture Asset
		 * \return returns true if the asset can be loaded into memory
		 */
		static bool LoadTexture(const std::string& filepath);
		/**
		 * \brief Loads Shader Asset
		 * \return returns true if the asset can be loaded into memory
		 */
		static bool LoadShader(const std::string& filepath);
		/**
		 * \brief Loads Font Asset
		 * \return returns true if the asset can be loaded into memory
		 */
		static bool LoadFont(const std::string& filepath, std::list<unsigned int> fontsize);
		/**
		 * \brief Loads Script Asset (ONLY C++ SCRIPTS)
		 * C# scripts will be loaded elsewhere
		 * \return returns true if the asset can be loaded into memory
		 */
		static bool LoadCPPScripts(const std::string& scriptClass);
		/**
		 * \brief Loads Scene Asset
		 * \return returns true if the asset can be loaded into memory
		 */
		static bool LoadScene(const std::string& filepath);

	private:
		// reference to audio system
		static AudioSystem* audioSystemRef;
		// reference to logic system
		static LogicSystem* logicSystemRef;
	};

}

================
File: AssetStore/AssetStore.cpp
================
/******************************************************************************/
/*!
\file AssetStore.cpp
\author Val Tay Yun Ying				 (tay.v) (100%)
\co-author:
\date 03-10-2024


All content � 2024 DigiPen Institute of Technology Singapore.
All rights reserved.
*/
/******************************************************************************/
#include <pch.h>
#include "AssetStore.h"

//#include "../Utilities/Any.h"

namespace Popplio
{
	std::unordered_map<std::string, FMOD::Sound*> AssetStore::loadedAudioList;
	std::unordered_map<std::string, std::unique_ptr<Shader>> AssetStore::shaderList;
	std::unordered_map<std::string, unsigned int> AssetStore::textureList;
	std::unordered_map<std::string, std::unique_ptr<Font>> AssetStore::fontList;
	std::unordered_map<MeshType, Mesh> AssetStore::meshList;
	std::unordered_map<std::string, std::shared_ptr<ILogicScript>> AssetStore::loadedScriptList;
	std::unordered_map<std::string, std::shared_ptr<ILogicData>> AssetStore::loadedDataList;

	std::unordered_map<std::string, std::filesystem::path> AssetStore::sceneList;
	std::unordered_map<std::string, std::pair<int, int>> AssetStore::textureSizeList;

	void AssetStore::StoreAudioAsset(const std::string& assetId, FMOD::Sound* sound)
	{
		loadedAudioList[assetId] = sound;
	}

	void AssetStore::StoreShaderAsset(const std::string& assetId, std::unique_ptr<Shader> shader)
	{
		shaderList.emplace(assetId, std::move(shader));
	}

	void AssetStore::StoreTextureAsset(const std::string& assetId, unsigned int texture)
	{
		int width = 0, height = 0;

		// Bind the texture and query its dimensions
		glBindTexture(GL_TEXTURE_2D, texture);
		glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &width);
		glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &height);

		// Store texture ID
		textureList.emplace(assetId, std::move(texture));

		// Store texture size in a separate map
		textureSizeList[assetId] = { width, height };
	}

	void AssetStore::StoreMeshAsset(MeshType type, const Mesh& mesh)
	{
		meshList.emplace(type, mesh);
	}

	void AssetStore::StoreFontAsset(const std::string& assetId, std::unique_ptr<Font> font)
	{
		fontList.emplace(assetId, std::move(font));
	}

	void AssetStore::StoreScriptAsset(const std::string& assetId, std::shared_ptr<ILogicScript> scp)
	{
		loadedScriptList.emplace(assetId, scp);
	}

	void AssetStore::StoreDataAsset(const std::string& assetId, std::shared_ptr<ILogicData> data)
	{
		loadedDataList.emplace(assetId, data);
	}

	void AssetStore::StoreSceneAsset(const std::string& assetId, const std::filesystem::path& path)
	{
		sceneList.emplace(assetId, path);
	}

	//void AssetStore::StoreChartAsset(const std::string& assetId, const std::filesystem::path& path)
	//{
	//	chartList.emplace(assetId, path);
	//}
	std::pair<int, int> AssetStore::GetTextureSize(const std::string& assetId)
	{
		auto it = textureSizeList.find(assetId);
		if (it != textureSizeList.end())
		{
			return it->second;
		}
		return { 0, 0 };
	}


	Shader* AssetStore::GetShader(const std::string& assetId)
	{
		auto it = shaderList.find(assetId);
		if (it != shaderList.end())
		{
			return it->second.get();
		}
		Logger::Warning("Shader asset not found: " + assetId);
		return nullptr;
	}

	unsigned int AssetStore::GetTexture(const std::string& assetId)
	{
		auto it = textureList.find(assetId);
		if (it != textureList.end())
		{
			return it->second;
		}
		Logger::Warning("Texture asset not found: " + assetId);
		return 0;
	}

	Font* AssetStore::GetFont(const std::string& assetId)
	{
		auto it = fontList.find(assetId);
		if (it != fontList.end())
		{
			return it->second.get();
		}
		Logger::Warning("Font asset not found: " + assetId);
		return nullptr;
	}

	Mesh& AssetStore::GetMesh(MeshType type)
	{
		auto it = meshList.find(type);
		if (it != meshList.end())
		{
			return it->second;
		}
		Logger::Warning("Mesh asset not found: " + type);
		static Mesh defaultMesh; // Return a static default mesh to avoid undefined behavior
		return defaultMesh;
	}

	FMOD::Sound* AssetStore::GetAudio(const std::string& assetId)
	{
		auto it = loadedAudioList.find(assetId);
		if (it != loadedAudioList.end())
		{
			return it->second;
		}
		Logger::Warning("Audio asset not found: " + assetId);
		return nullptr;
	}

	std::shared_ptr<ILogicScript> AssetStore::GetScript(const std::string& assetId)
	{
		auto it = loadedScriptList.find(assetId);
		if (it != loadedScriptList.end())
		{
			return it->second;
		}
		Logger::Warning("Script asset not found: " + assetId);
		return nullptr;
	}

	std::shared_ptr<ILogicData> AssetStore::GetData(const std::string& assetId)
	{
		auto it = loadedDataList.find(assetId);
		if (it != loadedDataList.end())
		{
			return it->second;
		}
		Logger::Warning("Data asset not found: " + assetId);
		return nullptr;
	}

	std::filesystem::path AssetStore::GetScene(const std::string& assetId)
	{
		auto it = sceneList.find(assetId);
		if (it != sceneList.end())
		{
			return it->second;
		}
		Logger::Warning("Scene asset not found: " + assetId);
		return std::filesystem::path("");
	}

	std::string AssetStore::GetSceneId(std::string const& path)
	{
		for (auto const& [id, scenePath] : sceneList)
		{
			if (scenePath == path)
			{
				return id;
			}
		}

		for (auto const& [id, scenePath] : sceneList)
		{
			if (scenePath == std::filesystem::absolute(path))
			{
				return id;
			}
		}

		Logger::Warning("Scene not found: " + path);
		return "";
	}

	//std::filesystem::path AssetStore::GetChart(const std::string& assetId)
	//{
	//	auto it = sceneList.find(assetId);
	//	if (it != sceneList.end())
	//	{
	//		return it->second;
	//	}
	//	Logger::Warning("Chart asset not found: " + assetId);
	//	return std::filesystem::path("");
	//}

	void AssetStore::Clear()
	{
		shaderList.clear();
		textureList.clear();
		fontList.clear();
		meshList.clear();

		loadedScriptList.clear();
		loadedDataList.clear();

		// For FMOD sounds, we need to release them properly
		for (std::pair<const std::string, FMOD::Sound*> pair : loadedAudioList)
		{
			pair.second->release();
		}

		loadedAudioList.clear();
	}

	const std::unordered_map<std::string, std::unique_ptr<Shader>>& AssetStore::GetAllShaders()
	{
		return shaderList;
	}

	const std::unordered_map<std::string, unsigned int>& AssetStore::GetAllTextures()
	{
		return textureList;
	}

	const std::unordered_map<std::string, std::unique_ptr<Font>>& AssetStore::GetAllFonts()
	{
		return fontList;
	}

	const std::unordered_map<std::string, FMOD::Sound*>& AssetStore::GetAllAudio()
	{
		return loadedAudioList;
	}

	const std::unordered_map<std::string, std::shared_ptr<ILogicScript>>& AssetStore::GetAllScripts()
	{
		return loadedScriptList;
	}

	const std::unordered_map<std::string, std::shared_ptr<ILogicData>>& AssetStore::GetAllData()
	{
		return loadedDataList;
	}

	const std::unordered_map<std::string, std::filesystem::path>& AssetStore::GetAllScenes()
	{
		return sceneList;
	}

	//const std::unordered_map<std::string, std::filesystem::path>& AssetStore::GetAllCharts()
	//{
	//	return chartList;
	//}

	const std::vector<std::string> AssetStore::GetShaderKeys()
	{
		std::vector<std::string> returning;
		auto it = shaderList.begin();
		for (; it != shaderList.end(); ++it)
		{
			if (it->first != "")
				returning.emplace_back(it->first);
		}
		return returning;
	}
	const std::vector<std::string> AssetStore::GetTextureKeys()
	{
		std::vector<std::string> returning;
		auto it = textureList.begin();
		for (; it != textureList.end(); ++it)
		{
			if (it->first != "")
				returning.emplace_back(it->first);
		}
		return returning;
	}
	const std::vector<std::string> AssetStore::GetFontKeys()
	{
		std::vector<std::string> returning;
		auto it = fontList.begin();
		for (; it != fontList.end(); ++it)
		{
			if (it->first != "")
				returning.emplace_back(it->first);
		}
		return returning;
	}
	const std::vector<std::string> AssetStore::GetAudioKeys()
	{
		std::vector<std::string> returning;
		auto it = loadedAudioList.begin();
		for (; it != loadedAudioList.end(); ++it)
		{
			if (it->first != "")
				returning.emplace_back(it->first);
		}
		return returning;
	}
	const std::vector<std::string> AssetStore::GetScriptKeys()
	{
		std::vector<std::string> returning;
		auto it = loadedScriptList.begin();
		for (; it != loadedScriptList.end(); ++it)
		{
			if (it->first != "")
				returning.emplace_back(it->first);
		}
		return returning;
	}
	const std::vector<std::string> AssetStore::GetDataKeys()
	{
		std::vector<std::string> returning;
		auto it = loadedDataList.begin();
		for (; it != loadedDataList.end(); ++it)
		{
			if (it->first != "")
				returning.emplace_back(it->first);
		}
		return returning;
	}
	const std::vector<std::string> AssetStore::GetSceneKeys()
	{
		std::vector<std::string> returning;
		auto it = sceneList.begin();
		for (; it != sceneList.end(); ++it)
		{
			if (it->first != "")
				returning.emplace_back(it->first);
		}
		return returning;
	}
	//const std::vector<std::string> AssetStore::GetChartKeys()
	//{
	//	std::vector<std::string> returning;
	//	auto it = chartList.begin();
	//	for (; it != chartList.end(); ++it)
	//	{
	//		if (it->first != "")
	//			returning.emplace_back(it->first);
	//	}
	//	return returning;
	//}
}

================
File: AssetStore/AssetStore.h
================
/******************************************************************************/
/*!
\file   AssetStore.h
\author Team Popplio
\author Val Tay Yun Ying
\co-author
\contribution Val - 100%
\par    Course : CSD2401
\par    Section : A
\date   2024/10/03
\brief
	This source file declares methods for the AssetStore. Functions related to the SAVING of assets is in this static class.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#ifndef ASSET_STORE_HEADER
#define ASSET_STORE_HEADER

#include <memory>
#include <iostream>
#include <string>
#include <typeindex>
#include <vector>
#include <unordered_map>
//#include <any>

#include <fmod.hpp>
#include "../Graphic/Mesh/Mesh.h"
#include "../Graphic/Shader/Shader.h"
#include "../Graphic/Texture/Texture.h"
#include "../Graphic/Font/Font.h"
#include "../Graphic/GraphicComponent.h"
#include "../Script/LogicScript.h"
#include "../Script/LogicData.h"

namespace Popplio
{
	extern const char* assetTypeList[];

	class AssetStore
	{
	private:
		AssetStore(const AssetStore&) = delete;
		AssetStore& operator=(const AssetStore&) = delete;

		static std::unordered_map<std::string, FMOD::Sound*> loadedAudioList;
		static std::unordered_map<std::string, std::unique_ptr<Shader>> shaderList;
		static std::unordered_map<std::string, unsigned int> textureList;
		static std::unordered_map<std::string, std::unique_ptr<Font>> fontList;
		static std::unordered_map<MeshType, Mesh> meshList;
		static std::unordered_map<std::string, std::shared_ptr<ILogicScript>> loadedScriptList;
		static std::unordered_map<std::string, std::shared_ptr<ILogicData>> loadedDataList; // deprecated

		static std::unordered_map<std::string, std::filesystem::path> sceneList;

		static std::unordered_map<std::string, std::filesystem::path> chartList;
		static std::unordered_map<std::string, std::pair<int, int>> textureSizeList; // Stores texture sizes

	public:

		// Storing Asset (Setters)
		static std::pair<int, int> GetTextureSize(const std::string& assetId); // New function

		/**
		 * \brief Stores Audio Asset
		 * \param assetID The ID to save the asset to
		 * \param sound The Sound asset to be saved into the assetstore
		 */
		static void StoreAudioAsset(const std::string& assetId, FMOD::Sound* sound);
		/**
		 * \brief Stores Shader Asset
		 * \param assetID The ID to save the asset to
		 * \param shader The shader asset to be saved into the assetstore
		 */
		static void StoreShaderAsset(const std::string& assetId, std::unique_ptr<Shader> shader);
		/**
		 * \brief Stores Texture Asset
		 * \param assetID The ID to save the asset to
		 * \param texture The texture asset to be saved into the assetstore
		 */
		static void StoreTextureAsset(const std::string& assetId, unsigned int texture);
		/**
		 * \brief Stores Mesh Asset
		 * \param assetID The ID to save the asset to
		 * \param mesh The mesh to be saved into the assetstore
		 */
		static void StoreMeshAsset(MeshType type, const Mesh& mesh);
		/**
		 * \brief Stores Font Asset
		 * \param assetID The ID to save the asset to
		 * \param font The Font asset to be saved into the assetstore
		 */
		static void StoreFontAsset(const std::string& assetId, std::unique_ptr<Font> font);
		/**
		 * \brief Stores Script Asset
		 * \param assetID The ID to save the asset to
		 * \param scp The Script asset to be saved into the assetstore
		 */
		static void StoreScriptAsset(const std::string& assetId, std::shared_ptr<ILogicScript> scp);
		/**
		 * \brief Stores Data Asset
		 * \param assetID The ID to save the asset to
		 * \param data The ILogicData asset to be saved into the assetstore
		 */
		static void StoreDataAsset(const std::string& assetId, std::shared_ptr<ILogicData> data);
		/**
		 * \brief Stores Scene Asset
		 * \param assetID The ID to save the asset to
		 * \param path The path to the scene asset to be saved into the assetstore
		 */
		static void StoreSceneAsset(const std::string& assetId, const std::filesystem::path& path);

		static void StoreChartAsset(const std::string& assetId, const std::filesystem::path& path);

		// Getters

		/**
		 * \brief Getter for Audio Asset
		 * \param assetID The ID key of the asset
		 * \return The Sound asset
		 */
		static FMOD::Sound* GetAudio(const std::string& assetId);
		/**
		 * \brief Getter for Shader Asset
		 * \param assetID The ID key of the asset
		 * \return The Shader asset
		 */
		static Shader* GetShader(const std::string& assetId);
		/**
		 * \brief Getter for Texture Asset
		 * \param assetID The ID key of the asset
		 * \return The Texture asset
		 */
		static unsigned int GetTexture(const std::string& assetId);
		/**
		 * \brief Getter for Mesh
		 * \param type The MeshType of the mesh
		 * \return The Mesh
		 */
		static Mesh& GetMesh(MeshType type);
		/**
		 * \brief Getter for Font Asset
		 * \param assetID The ID key of the asset
		 * \return The Font asset
		 */
		static Font* GetFont(const std::string& assetId);
		/**
		 * \brief Getter for Script Asset
		 * \param assetID The ID key of the asset
		 * \return The Script asset
		 */
		static std::shared_ptr<ILogicScript> GetScript(const std::string& assetId);
		/**
		 * \brief Getter for Data Asset
		 * \param assetID The ID key of the asset
		 * \return The ILogicData asset
		 */
		static std::shared_ptr<ILogicData> GetData(const std::string& assetId);
		/**
		 * \brief Getter for Scene Asset
		 * \param assetID The ID key of the asset
		 * \return The Scene asset
		 */
		static std::filesystem::path GetScene(const std::string& assetId);
		static std::string GetSceneId(std::string const& path);

		static std::filesystem::path GetChart(const std::string& assetId);

		/**
		 * \brief Getter for unordered_map of Shaders
		 * \return The Unordered map of Shader
		 */
		static const std::unordered_map<std::string, std::unique_ptr<Shader>>& GetAllShaders();
		/**
		 * \brief Getter for unordered_map of Textures
		 * \return The Unordered map of Textures
		 */
		static const std::unordered_map<std::string, unsigned int>& GetAllTextures();
		/**
		 * \brief Getter for unordered_map of Fonts
		 * \return The Unordered map of Fonts
		 */
		static const std::unordered_map<std::string, std::unique_ptr<Font>>& GetAllFonts();
		/**
		 * \brief Getter for unordered_map of Audio
		 * \return The Unordered map of Audio
		 */
		static const std::unordered_map<std::string, FMOD::Sound*>& GetAllAudio();
		/**
		 * \brief Getter for unordered_map of Scripts
		 * \return The Unordered map of Scripts
		 */
		static const std::unordered_map<std::string, std::shared_ptr<ILogicScript>>& GetAllScripts();
		/**
		 * \brief Getter for unordered_map of ILogicData
		 * \return The Unordered map of ILogicData
		 */
		static const std::unordered_map<std::string, std::shared_ptr<ILogicData>>& GetAllData();
		/**
		 * \brief Getter for unordered_map of Scenes
		 * \return The Unordered map of Scenes
		 */
		static const std::unordered_map<std::string, std::filesystem::path>& GetAllScenes();

		static const std::unordered_map<std::string, std::filesystem::path>& GetAllCharts();

		//returns size of array of keys via parameter size
		/**
		 * \brief Getter for vector of keys of Shader
		 * \return The vector of keys of Shader
		 */
		static const std::vector<std::string> GetShaderKeys();

		/**
		 * \brief Getter for vector of keys of Texture
		 * \return The vector of keys of Texture
		 */
		static const std::vector<std::string> GetTextureKeys();

		/**
		 * \brief Getter for vector of keys of Font
		 * \return The vector of keys of Font
		 */
		static const std::vector<std::string> GetFontKeys();

		/**
		 * \brief Getter for vector of keys of Audio
		 * \return The vector of keys of Audio
		 */
		static const std::vector<std::string> GetAudioKeys();

		/**
		 * \brief Getter for vector of keys of Script
		 * \return The vector of keys of Script
		 */
		static const std::vector<std::string> GetScriptKeys();

		/**
		 * \brief Getter for vector of keys of ILogicData
		 * \return The vector of keys of ILogicData
		 */
		static const std::vector<std::string> GetDataKeys();

		/**
		 * \brief Getter for vector of keys of Scene
		 * \return The vector of keys of Scene
		 */
		static const std::vector<std::string> GetSceneKeys();

		static const std::vector<std::string> GetChartKeys();

		/**
		 * \brief static function to unload all assets from memory
		 */
		static void Clear();

	};
}
#endif // !

================
File: ChartEditor/LevelChart.cpp
================
/******************************************************************************/
/*!
\file           LevelChart.cpp
\author         Team Popplio
\author         Val Tay Yun Ying
\co-author
\contribution   Val - 100%
\par            Course : CSD2401 / CSD2400
\par            Section : A
\date           2025/1/14
\brief
	This is the header file for the serializer of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#include "pch.h"
#include "LevelChart.h"

namespace Popplio
{
	LevelChart::LevelChart(std::string chartName, double songDuration, double bpm, int timeSigTop, int timeSigBot, std::string audioFilePath, std::string chartSavePath) :
		chartName(chartName),
		songDuration(songDuration),
		bpm(bpm),
		audioFilePath(audioFilePath),
		chartSavePath(chartSavePath)
	{
		timeSig[TOPNUMBER] = timeSigTop;
		timeSig[BOTTOMNUMBER] = timeSigBot;
	}

	LevelChart::~LevelChart()
	{
	}

	void LevelChart::AddBeatNote(LevelChart*& chart, float barstart, int bar, float beat, float beatLength, int lane, bool rainbow, int spriteID)
	{
		chart->notesList.push_back(Note(static_cast<int>(chart->notesList.size()), barstart, bar, beat, beatLength, lane, Note::NOTETYPE::BEAT, rainbow, spriteID));
	}

	void LevelChart::AddDirectionalNote(LevelChart*& chart, Note::NOTETYPE type, float barstart, int bar, float beat, float beatLength, int lane, bool rainbow, int spriteID)
	{
		chart->notesList.push_back(Note(static_cast<int>(chart->notesList.size()), barstart, bar, beat, beatLength, lane, type, rainbow, spriteID));
	}

	void LevelChart::AddHoldNote(LevelChart*& chart, float barstart, int bar, float beat, float beatLength, int lane, bool rainbow, int spriteID)
	{
		chart->notesList.push_back(Note(static_cast<int>(chart->notesList.size()), barstart, bar, beat, beatLength, lane, Note::NOTETYPE::HOLD, rainbow, spriteID));
	}
}

================
File: ChartEditor/LevelChart.h
================
/******************************************************************************/
/*!
\file           LevelChart.h
\author         Team Popplio
\author         Val Tay Yun Ying
\co-author
\contribution   Val - 100%
\par            Course : CSD2401 / CSD2400
\par            Section : A
\date           2025/1/14
\brief
	This is the header file for the serializer of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once

constexpr auto TOPNUMBER = 0;
constexpr auto BOTTOMNUMBER = 1;

namespace Popplio
{
	struct Note
	{
		enum NOTETYPE
		{
			BEAT = 0,
			HOLD,
			DIR_UP,
			DIR_DOWN
		};

		int id;

		// not being used in final, purely for calculation now
		float barstart;

		// which bar?
		int bar;

		// which beat in the bar? (0 to timeSig[0])
		float beat;

		//// which subbeat in the beat? (0 to timeSig[1])
		//int subbeat;

		// [Hold note only!!] how long this note is?
		float beatLength;

		int lane;			// which lane this is
		NOTETYPE noteType;	// type of note this is
		bool rainbow;		// this note has rainbow?
		int spriteID;		// spriteID



		// default constructor
		Note() :
			id(0),
			barstart(0),
			bar(0),
			beat(0),
			beatLength(0),
			lane(0),
			noteType(NOTETYPE::BEAT),
			rainbow(false),
			spriteID(0)
		{
		}

		// overloaded constructor
		Note(int id, float barstart, int bar, float beat, float beatLength, 
			int lane, NOTETYPE notetype, bool rainbow, int sprite) :
			id(id),
			barstart(barstart),
			bar(bar),
			beat(beat),
			beatLength(beatLength),
			lane(lane),
			noteType(notetype),
			rainbow(rainbow),
			spriteID(0)
		{
            (void)sprite;
		}
	};

	struct LevelChart
	{
		std::string chartName;
		// duration of the song
		double songDuration;
		double bpm;
		int timeSig[2];
		std::string audioFilePath;
		std::string chartSavePath;
		//int timeSig[2];

		// list of lanes, with a list of notes in that lane
		std::vector<Note> notesList;

		// no default constructor
		LevelChart() = delete;

		LevelChart(std::string chartName, double songDuration, double bpm, int timeSigTop, int timeSigBot, std::string audioFilePath, std::string chartSavePath);
		~LevelChart();

		static void AddBeatNote(LevelChart*& chart, float barstart, int bar, float beat, float beatLength, int lane, bool rainbow, int spriteID);

		static void AddDirectionalNote(LevelChart*& chart, Note::NOTETYPE type, float barstart, int bar, float beat, float beatLength, int lane, bool rainbow, int spriteID);

		static void AddHoldNote(LevelChart*& chart, float barstart, int bar, float beat, float beatLength, int lane, bool rainbow, int spriteID);
	};

}

================
File: Cloning/CloneEntityEvent.h
================
/******************************************************************************/
/*!
\file   CloneEntityEvent.h
\author Team Popplio
\author Bryan
\contribution Bryan - 85%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/11/07 11:23:30 PM (Last Edit)
\brief
		This is the header file for CloneEntityEvent

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include "../EventBus/Event.h"

namespace Popplio
{
	class CloneEntityEvent : public Event
	{
	public:
		int entityId;
		int cloneToId;
		
		CloneEntityEvent(int id, int toId = -1) : entityId(id), cloneToId(toId) {}
	};
}

================
File: Cloning/CloneSystem.cpp
================
/******************************************************************************/
/*!
\file   CloneSystem.cpp
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief
	This source file implements the CloneSystem class defined in CloneSystem.h. 
	The CloneSystem is responsible for cloning entities in a game engine. 
	It subscribes to events and handles the cloning of entities by copying 
	their components.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>
#include "CloneSystem.h"

#include "../Utilities/Components.h"

#ifndef IMGUI_DISABLE
#include "../Editor/Editor.h"
#endif

#include "../Hierarchy/HierarchySystem.h"

namespace Popplio
{
	int CloneSystem::cloneCounter = 0;

	CloneSystem::CloneSystem(Registry& reg, LayerManager& lay)
		: registry(reg), layerManager(lay)
	{
		// Register component cloning functions
		RegisterComponentCloner<ActiveComponent>();
		RegisterComponentCloner<TransformComponent>();
		
		// Special handling for ParentComponent to avoid copying child references directly
		componentCloners[std::type_index(typeid(ParentComponent))] = 
			[this](Entity& original, Entity& clone)
		{
			if (original.HasComponent<ParentComponent>())
			{
				auto& originalParent = original.GetComponent<ParentComponent>();
				
				// Add component with only the inheritance flags - children will be handled separately
				clone.AddComponent<ParentComponent>(Entity(-1),
					originalParent.inheritActive,
					originalParent.inheritTransform);
			}
		};

		RegisterComponentCloner<RigidBodyComponent>();
		RegisterComponentCloner<BoxColliderComponent>();
		RegisterComponentCloner<CircleColliderComponent>();
		RegisterComponentCloner<RenderComponent>();
		RegisterComponentCloner<TextComponent>();
		RegisterComponentCloner<PrefabInstanceComponent>();
		RegisterComponentCloner<AudioComponent>();
		RegisterComponentCloner<AnimationComponent>();
		RegisterComponentCloner<LogicComponent>();
		RegisterComponentCloner<ActiveComponent>();
		RegisterComponentCloner<UIComponent>();
		RegisterComponentCloner<PersistOnLoadComponent>();
        RegisterComponentCloner<ParticleComponent>();
		// Add more component types here as needed
	}

	void CloneSystem::SubscribeToEvents(EventBus& eventBus)
	{
		eventBus.SubscribeToEvent<CloneEntityEvent>(this, &CloneSystem::OnCloneEntity);
	}

	void CloneSystem::CloneComponents(Entity& originalEntity, Entity& newEntity)
	{
		// Clone components
		for (const auto& [typeIndex, clonerFunc] : componentCloners)
		{
			clonerFunc(originalEntity, newEntity);
		}
	}

	int CloneSystem::CloneEntity(CloneEntityEvent& event) // might not work
	{
		// Validate entity ID before proceeding
		if (event.entityId < 0 || !registry.EntityExists(event.entityId))
		{
			Logger::Error("Invalid entity ID for cloning: " + std::to_string(event.entityId));
			return -1;
		}

		int currentClone = cloneCounter++;

		Logger::Debug("CloneEntity | Cloning entity with ID: " + std::to_string(event.entityId));

		// Check if the entity exists in the registry
		if (!registry.EntityExists(event.entityId))
		{
			Logger::Error("CloneEntity | Entity with ID " + std::to_string(event.entityId) + " does not exist in the registry.");
			return -1;
		}
		
		Entity originalEntity = registry.GetEntityById(event.entityId);
		Entity newEntity = registry.CreateEntity(originalEntity.GetId(), event.cloneToId);
		
		CopyEntityInfo(originalEntity, newEntity);

		// First pass: Clone basic components
		CloneComponents(originalEntity, newEntity);

		//registry.ForceRuntimeUpdate(newEntity);
		
		if (originalEntity.HasComponent<ParentComponent>())
		{
			// Root clone
            if (currentClone == 0 && originalEntity.GetComponent<ParentComponent>().parent.Exists())
            {
				registry.GetSystem<HierarchySystem>().AddChild(
					originalEntity.GetComponent<ParentComponent>().parent, newEntity);

     //           originalEntity.GetComponent<ParentComponent>().parent.GetComponent<ParentComponent>().AddChild(newEntity);
     //           newEntity.GetComponent<ParentComponent>().parent = 
					//originalEntity.GetComponent<ParentComponent>().parent;

                newEntity.GetComponent<ParentComponent>().localPosition = originalEntity.GetComponent<ParentComponent>().localPosition;
                newEntity.GetComponent<ParentComponent>().localRotation = originalEntity.GetComponent<ParentComponent>().localRotation;
                newEntity.GetComponent<ParentComponent>().localScale = originalEntity.GetComponent<ParentComponent>().localScale;
            }

			// Second pass: Set up parent-child relationships
			HandleHierarchyCloning(originalEntity, newEntity);

			// TODO FIX - DOESNT WORK
			// Third pass: Preserve script entity references to children
			//if (originalEntity.HasComponent<LogicComponent>() && 
			//	!originalEntity.GetComponent<ParentComponent>().children.empty())
			//{
			//	registry.GetSystem<LogicSystem>().UpdateFromCopy(newEntity, originalEntity);
			//}
		}

#ifndef IMGUI_DISABLE
		registry.GetSystem<Editor>().latestNewEntity = newEntity; // to signal change event
#endif

		if (currentClone == 0)
		{
            HandleLogicCloning(originalEntity, newEntity, originalEntity, newEntity);
			cloneCounter = 0;
		}

		Logger::Info("CloneEntity | Entity cloned successfully. New entity ID: " + std::to_string(newEntity.GetId()));

		//registry.ForceRuntimeUpdate(newEntity);

		return newEntity.GetId();
	}

	void CloneSystem::OnCloneEntity(CloneEntityEvent& event)
	{
		Logger::Debug("OnCloneEntity | Event triggered: ");
		CloneEntity(event);
	}

	void CloneSystem::CopyEntityInfo(Entity originalEntity, Entity newEntity)
	{
		layerManager.AddEntityToLayer(newEntity, layerManager.GetEntityLayer(originalEntity));
		
		// Handle tag - add numbered clone suffix
		if (registry.EntityHasAnyTag(originalEntity))
		{
			std::string originalTag = registry.GetEntityTag(originalEntity);
            if (cloneCounter > 1) // non-root clone
            {
                newEntity.Tag(originalTag);
            }
			else
			{
				// Find next available clone number
				int cloneNum = 1;
				std::string newTag;
				bool tagExists;
				do
				{
					newTag = originalTag + " {" + std::to_string(cloneNum) + "}";
					try
					{
						registry.GetEntityByTag(newTag);
						tagExists = true;
					}
					catch (...)
					{
						tagExists = false;
					}
					cloneNum++;
				} while (tagExists);
				newEntity.Tag(newTag);
			}
		}
        newEntity.Group(registry.GetEntityGroup(originalEntity));
	}

	void CloneSystem::HandleHierarchyCloning(Entity originalEntity, Entity newEntity)
	{
		if (!originalEntity.HasComponent<ParentComponent>())
		{
			return;
		}

		auto& originalParentComp = originalEntity.GetComponent<ParentComponent>();
		auto& newParentComp = newEntity.GetComponent<ParentComponent>();

		// Only handle parent-child relationship if original entity has a valid parent
		if (originalParentComp.parent.Exists())
		{
			// Set parent reference on the new entity
			Entity newParent = registry.GetEntityById(originalParentComp.parent.GetId());
			if (newParent.Exists()) {
				newParentComp.parent = newParent;
				// Update transforms based on parent
				newParentComp.UpdateLocalTransform(
					newEntity.GetComponent<TransformComponent>(),
					newParent.GetComponent<TransformComponent>()
				);
			}
		}

		// Clone all children recursively
		if (!originalParentComp.children.empty())
		{
			for (auto& child : originalParentComp.children)
			{
				CloneEntityEvent childEvent(child.GetId());
				int newChildId = CloneEntity(childEvent);

				if (newChildId != -1)
				{
					Entity newChild = registry.GetEntityById(newChildId);
					newParentComp.AddChild(newChild, newEntity);

					auto& childParentComp = newChild.GetComponent<ParentComponent>();
					childParentComp.parent = newEntity;

					// Update child transforms 
					if (childParentComp.inheritTransform)
					{
						childParentComp.UpdateLocalTransform(
							newChild.GetComponent<TransformComponent>(),
							newEntity.GetComponent<TransformComponent>()
						);
					}
				}
			}
		}
	}

	void CloneSystem::HandleLogicCloning(Entity originalEntity, Entity newEntity, 
		Entity rootOriginalEntity, Entity rootNewEntity)
	{
		// root entity is the eldest entity in the hierarchy being cloned

        if (!originalEntity.HasComponent<LogicComponent>()) return;

        if (originalEntity.HasComponent<ParentComponent>())
        {
			auto& originalParentComp = originalEntity.GetComponent<ParentComponent>();
			auto& newParentComp = newEntity.GetComponent<ParentComponent>();

			if (!originalParentComp.children.empty())
			{
				auto originalIt = originalParentComp.children.begin();
				auto newIt = newParentComp.children.begin();

				while (originalIt != originalParentComp.children.end() && 
					newIt != newParentComp.children.end())
				{
					//Entity originalChild = *originalIt;
					//Entity newChild = *newIt;
					HandleLogicCloning(*originalIt, *newIt, rootOriginalEntity, rootNewEntity);
					++originalIt;
					++newIt;
				}
			}
		}

		registry.GetSystem<LogicSystem>().UpdateFromCopy(newEntity, originalEntity, rootNewEntity, rootOriginalEntity);
	}

	template<>
	void CloneSystem::RegisterComponentCloner<LogicComponent>()
	{
		componentCloners[std::type_index(typeid(LogicComponent))] = [this](Entity& original, Entity& clone)
		{
			if (original.HasComponent<LogicComponent>())
			{
				LogicComponent& clonedComponent = original.GetComponent<LogicComponent>();
				clone.AddComponent<LogicComponent>(clonedComponent);

				clonedComponent.Clone(original.GetComponent<LogicComponent>(), clone.GetId());
			}
		};
	}
	//template<>
	//void CloneSystem::RegisterComponentCloner<ParentComponent>()
	//{
	//	componentCloners[std::type_index(typeid(ParentComponent))] = [this](Entity& original, Entity& clone)
	//	{
	//		if (original.HasComponent<ParentComponent>())
	//		{
	//			ParentComponent& clonedComponent = original.GetComponent<ParentComponent>();
	//			clone.AddComponent<ParentComponent>(clonedComponent);
 //               clone.SetClonedFrom(original.GetId());
	//		}
	//	};
	//}
}

================
File: Cloning/CloneSystem.h
================
/******************************************************************************/
/*!
\file   CloneSystem.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief
    This header file defines the CloneSystem class within the Popplio namespace. 
    The CloneSystem is responsible for cloning entities in a game engine. It inherits 
    from the System class and provides functionality to subscribe to events and handle 
    the cloning of entities.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once
#include "../ECS/ECS.h"
#include "../EventBus/EventBus.h"
#include "../Cloning/CloneEntityEvent.h"
#include "../Logging/Logger.h"
#include <random>
#include <ctime>

namespace Popplio
{
    /*!
    \class CloneSystem
    \brief Represents the entity cloning system of the engine.

    This class is responsible for cloning entities in the game engine.
    It inherits from the System class and provides functionality to
    subscribe to events and handle the cloning of entities.

    \author Team Popplio
    \author Bryan Ang Wei Ze
    \date 2024/10/02
    */
    class CloneSystem : public System
    {
    public:
        /*!
        \brief Constructs a CloneSystem object.

        \param reg The registry of the game engine.
        */
        CloneSystem(Registry& reg, LayerManager& lay);

        /*!
        \brief Subscribes to relevant events.

        \param eventBus The event bus of the game engine.
        */
        void SubscribeToEvents(EventBus& eventBus);

        /*!
        \brief Clones components between entities

        \param originalEntity | source

        \param newEntity | destination
        */
        void CloneComponents(Entity& originalEntity, Entity& newEntity);

        int CloneEntity(CloneEntityEvent& event); // might not work

        /*!
        \brief Handles the CloneEntityEvent.

        \param event The CloneEntityEvent to handle.
        */
        void OnCloneEntity(CloneEntityEvent& event);

        /*!
        \brief Registers a component cloner for a specific component type.

        \tparam T The component type to register the cloner for.
        */
        template<typename T>
        void RegisterComponentCloner();
        template<>
        void RegisterComponentCloner<LogicComponent>();
        //template <>
        //void RegisterComponentCloner<ParentComponent>();

    private:
        Registry& registry;
        LayerManager& layerManager;
        std::unordered_map<std::type_index, std::function<void(Entity&, Entity&)>> componentCloners;

        static int cloneCounter;

        void CopyEntityInfo(Entity originalEntity, Entity newEntity);
		void HandleHierarchyCloning(Entity originalEntity, Entity newEntity);
        //void CloneComponentsSecondPass(Entity & originalEntity, Entity & newEntity);
        //void CloneComponentsThirdPass(Entity& originalEntity, Entity& newEntity);
        void HandleLogicCloning(Entity originalEntity, Entity newEntity, Entity rootOriginalEntity, Entity rootNewEntity);
    };

    template <typename T>
    void CloneSystem::RegisterComponentCloner()
    {
        componentCloners[std::type_index(typeid(T))] = [this](Entity& original, Entity& clone)
        {
            if (original.HasComponent<T>())
            {
                T& clonedComponent = original.GetComponent<T>();
                clone.AddComponent<T>(clonedComponent);
            }
        };
    }
}

================
File: ECS/ECS.cpp
================
/******************************************************************************/
/*!
\file   ECS.cpp
\author Team Popplio
\author Bryan Ang Wei Ze
\co-author Ng Jun Heng Shawn
\contribution Bryan - 95% | Shawn - 5%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/10/02
\brief
        This is the source file for the Entity Component System of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>

#ifndef IMGUI_DISABLE
#include "../Editor/Editor.h"
#endif

#include "../Cloning/CloneEntityEvent.h"
#include "../Cloning/CloneSystem.h"

namespace Popplio
{
    namespace
    {
        // l-value required
        static CloneEntityEvent cloneEvent = CloneEntityEvent(-1);
    }

    int IComponent::nextId = 0;

    bool Entity::Exists() const
    {
        return registry->EntityExists(id);
    }

    int Entity::GetId() const
    {
        return id;
    }

    void Entity::Kill()
    {
        registry->KillEntity(*this);
    }

    void Entity::Tag(const std::string& tag)
    {
        registry->TagEntity(*this, tag);
    }

    bool Entity::HasTag(const std::string& tag) const
    {
        return registry->EntityHasTag(*this, tag);
    }

    std::string Entity::GetTag() const
    {
        return registry->GetEntityTag(*this);
    }

    void Entity::Group(const std::string& group)
    {
        registry->GroupEntity(*this, group);
    }

    bool Entity::BelongsToGroup(const std::string& group) const
    {
        return registry->EntityBelongsToGroup(*this, group);
    }

    Entity Entity::Clone() const
    {
        return registry->GetEntityById(registry->GetSystem<CloneSystem>().CloneEntity(cloneEvent = CloneEntityEvent(id)));
    }

    //bool Entity::operator==(const Entity& other) const
    //{
    //    return this->id == other.id;
    //}

    Entity Entity::GetClonedFrom() const { return registry->GetClonedFrom(*this); }
    //void Entity::SetClonedFrom(int ent) { clonedFrom = ent; }

    void System::AddEntityToSystem(Entity entity)
    {
        if (!HasEntity(entity))
        {
            entities.push_back(entity);
        }
    }

    void System::RemoveEntityFromSystem(Entity entity)
    {
        entities.erase(std::remove_if(entities.begin(), entities.end(), [&entity](Entity other)
        {
            return entity == other;
        }), entities.end());
    }

    bool System::HasEntity(Entity entity) const
	{
		return std::find(entities.begin(), entities.end(), entity) != entities.end();
	}

    std::vector<Entity> System::GetSystemEntities() const
    {
        return entities;
    }

    const Signature& System::GetComponentSignature() const
    {
        return componentSignature;
    }

    const std::vector<Entity>& Registry::GetAllEntities() const
	{
		return entities;
	}

    std::vector<Entity>& Registry::GetAllEntitiesMutable()
    {
        return entities;
    }

    void Registry::ClearFreeIds()
    {
		freeIds.clear();
    }

    bool Registry::KillEntityQueueIsEmpty() const
    {
        return entitiesToBeKilled.empty();
    }

    void Registry::ResetNumEntities()
    {
		//numEntities = 0;
    }

    void Registry::UpdateNumEntities()
    {
        //numEntities = static_cast<int>(entities.size());
    }

	int Registry::GetNumEntities() const
	{
		//return numEntities;
        return static_cast<int>(entities.size());
	}

    Entity Registry::CreateEntity(int original, int idToSetTo)
    {
        int entityId = -1;

        // If a specific ID is requested (for deserialization or cloning)
        if (idToSetTo >= 0)
        {
            size_t initialSize = entityComponentSignatures.size();
            if (idToSetTo >= initialSize)
            {
                entityComponentSignatures.resize(idToSetTo + 1);

                for (size_t i{ initialSize }; i < entityComponentSignatures.size() - 1; ++i)
                {
                    freeIds.push_back(static_cast<int>(i));
                }
                entityId = idToSetTo;
            }
            else if (!freeIds.empty())
            {
                auto locationToErase = std::find(freeIds.begin(), freeIds.end(), idToSetTo);
                if (locationToErase != freeIds.end())
                {
                    freeIds.erase(locationToErase);
                    entityId = idToSetTo;
                    if (freeIds.empty()) Logger::Info("No more free IDs");
                }
            }

            if (std::find(entities.begin(), entities.end(), Entity(idToSetTo)) != entities.end())
            {
                Logger::Error("Entity with ID " + std::to_string(idToSetTo) + " already exists");
                Logger::Critical("Scene file is corrupted. Please check the scene file for errors and duplicates.");
            }
        }
        else // Generate a new unique ID (for instantiating prefabs)
        {
            // If there are no free ids waiting to be reused
            if (freeIds.empty())
            {
                entityId = static_cast<int>(entities.size());

                // Make sure the entityComponentSignatures vector can accommodate the new entity
                if (entityId >= entityComponentSignatures.size())
                {
                    entityComponentSignatures.resize(entityId + 1);
                }
                Logger::Debug("Created entity with ID: " + std::to_string(entityId));
            }
            else
            {
                // Reuse an id from the list of previously removed entities
                entityId = freeIds.front();
                freeIds.pop_front();
            }
        }

        if (entityId < 0)
        {
            std::vector<int> ids;
            for (int i : freeIds)
            {
                ids.push_back(i);
            }

            Logger::Error("Entity ID " + std::to_string(idToSetTo) + " is invalid.");
            if (std::find(entities.begin(), entities.end(), Entity(idToSetTo)) != entities.end())
            {
                Logger::Error("Entity with ID " + std::to_string(idToSetTo) + " already exists");
            }
            return Entity(-1);
        }

        Entity entity(entityId);
        clonedFromIds[entityId] = original;
        entity.registry = this;
        entitiesToBeAdded.insert(entity);

        // Add ActiveComponent by default
        entity.AddComponent<ActiveComponent>();

        // Add TransformComponent by default
        entity.AddComponent<TransformComponent>();

        entities.push_back(entity);

        return entity;
    }

    void Registry::KillEntityFirstPass(Entity entity)
    {
        OnEntityDestroy(entity);

        // Remove from parent's children list if this entity is a child
        if (entity.HasComponent<ParentComponent>())
        {
            auto& parentComp = entity.GetComponent<ParentComponent>();

            // Then handle destroying children
            //std::set<Entity>& childrenToDestroy = parentComp.children;
            //for (auto child : childrenToDestroy)
            for (auto& child : parentComp.children)
            {
                KillEntityFirstPass(child);
            }
        }
    }

    std::set<Entity>& Registry::KillEntitySecondPass(Entity entity, std::set<Entity>& killedEntities)
    {
        // Remove from parent's children list if this entity is a child
        if (entity.HasComponent<ParentComponent>())
        {
            auto& parentComp = entity.GetComponent<ParentComponent>();
            if (parentComp.parent.GetId() != -1 && EntityExists(parentComp.parent.GetId()))
            {
                Entity parent = GetEntityById(parentComp.parent.GetId());
                if (parent.HasComponent<ParentComponent>())
                {
                    parent.GetComponent<ParentComponent>().RemoveChild(entity);
                }
            }

            // Then handle destroying children
            //std::vector<Entity>& childrenToDestroy = parentComp.children;
            //for (auto& child : childrenToDestroy)
            std::set<Entity> temp{};
            for (auto child : parentComp.children)
            {
                //std::set<Entity> temp = killedEntities;
                temp = KillEntitySecondPass(child, killedEntities);

                //killedEntities.insert(temp.begin(), temp.end());
            }

            for (Entity e : temp)
            {
                killedEntities.insert(e);
            }
        }
        killedEntities.insert(entity);
        return killedEntities;
    }

    void Registry::KillEntityRuntime(Entity entity)
    {
        KillEntityFirstPass(entity);

        std::set<Entity> killedEntities{};

        KillEntitySecondPass(entity, killedEntities);

        //killedEntities.insert(entity);

        for (Entity e : killedEntities)
        {
            Logger::Debug("Entity queued for deletion. ID: " + std::to_string(entity.GetId()));
            entitiesToBeKilled.insert(e);
        }
    }

    void Registry::KillEntity(Entity entity)
    {
        //std::set<Entity> temp = KillEntityRuntime(entity);

        Logger::Debug("Entity queued for deletion. ID: " + std::to_string(entity.GetId()));
        entitiesToBeKilled.insert(entity);
    }

    void Registry::KillAllEntities()
    {
        for (Entity e : GetAllEntities())
        {
            KillEntity(e);
        }
    }

    bool Registry::EntityExists(int entityId) const
    {
        return entityId >= 0 && entityId < entityComponentSignatures.size() && entityComponentSignatures[entityId].any();
    }

    Entity Registry::GetEntityById(int entityId)
    {
        if (!EntityExists(entityId))
        {
            Logger::Error("Attempted to get non-existent entity.");
            return Entity(-1);
            //throw std::runtime_error("Attempted to get non-existent entity.");
        }
        Entity entity(entityId);
        entity.registry = this;
        return entity;
    }

    void Registry::AddEntityToSystems(Entity entity)
    {
        const auto entityId = entity.GetId();
        // Match entityComponentSignature <---> systemConponentSignature
        const auto& entityComponentSignature = entityComponentSignatures[entityId];

        for (auto& system : systems)
        {
            const auto& systemComponentSignature = system.second->GetComponentSignature();

            bool isInterested = (entityComponentSignature & systemComponentSignature) == systemComponentSignature;

            // Add entity to system if entityComponentSignature matches systemConponentSignature
            if (isInterested)
            {
                system.second->AddEntityToSystem(entity);
            }
        }
    }

    void Registry::RemoveEntityFromSystems(Entity entity)
    {
        for (auto& system : systems)
        {
            system.second->RemoveEntityFromSystem(entity);
        }
    }

    void Registry::TagEntity(Entity entity, const std::string& tag)
    {
        entityPerTag.emplace(tag, entity);
        tagPerEntity.emplace(entity.GetId(), tag);
    }

    bool Registry::EntityHasTag(Entity entity, const std::string& tag) const
    {
        if (tagPerEntity.find(entity.GetId()) == tagPerEntity.end())
        {
            return false;
        }
        return entityPerTag.find(tag)->second.GetId() == entity.GetId();
    }

    bool Registry::EntityHasAnyTag(Entity entity) const
	{
		return tagPerEntity.find(entity.GetId()) != tagPerEntity.end();
	}

    Entity Registry::GetEntityByTag(const std::string& tag) const
    {
        auto it = entityPerTag.find(tag);
        if (it == entityPerTag.end())
        {
            throw std::runtime_error("No entity found with tag: " + tag);
        }
        return it->second;
    }

    std::string Registry::GetEntityTag(Entity entity) const
    {
        auto it = tagPerEntity.find(entity.GetId());
        if (it != tagPerEntity.end())
        {
            return it->second;
        }
        return ""; // Return empty string if entity has no tag
    }

    void Registry::RemoveEntityTag(Entity entity)
    {
        auto taggedEntity = tagPerEntity.find(entity.GetId());
        if (taggedEntity != tagPerEntity.end())
        {
            const auto& tag = taggedEntity->second;
            entityPerTag.erase(tag);
            tagPerEntity.erase(taggedEntity);
        }
    }

    void Registry::GroupEntity(Entity entity, const std::string& group)
    {
        entitiesPerGroup[group].emplace(entity);
        groupsPerEntity.emplace(entity.GetId(), group);
    }

    bool Registry::EntityBelongsToGroup(Entity entity, const std::string& group) const
    {
        auto groupEntities = entitiesPerGroup.find(group);
        // entity does not belong to group specified
        if (groupEntities == entitiesPerGroup.end())
        {
            return false;
        }
        return groupEntities->second.find(entity.GetId()) != groupEntities->second.end();
    }

    bool Registry::EntityBelongsToAnyGroup(Entity entity) const
	{
		return groupsPerEntity.find(entity.GetId()) != groupsPerEntity.end();
	}

    std::vector<Entity> Registry::GetEntityByGroup(const std::string& group) const
    {
        auto groupOfEntities = entitiesPerGroup.find(group);
        if (groupOfEntities == entitiesPerGroup.end())
        {
            return {};
        }
        return std::vector<Entity>(groupOfEntities->second.begin(), groupOfEntities->second.end());
    }

    std::string Registry::GetEntityGroup(Entity entity) const
    {
        auto it = groupsPerEntity.find(entity.GetId());
        if (it != groupsPerEntity.end())
		{
			return it->second;
		}

        return ""; // Return empty string if entity has no tag
    }

    void Registry::RemoveEntityGroup(Entity entity)
    {
        auto groupedEntity = groupsPerEntity.find(entity.GetId());
        if (groupedEntity != groupsPerEntity.end())
        {
            auto group = entitiesPerGroup.find(groupedEntity->second);
            if (group != entitiesPerGroup.end())
            {
                group->second.erase(entity);
            }
            groupsPerEntity.erase(groupedEntity);
        }
    }

    void Registry::Update()
    {
        // Process the entities that are waiting to be created to the active Systems
        for (const auto& entity : entitiesToBeAdded)
        {
            AddEntityToSystems(entity);
            OnEntityCreate(entity);
        }
        entitiesToBeAdded.clear();

        // Process the entities that are waiting to be killed to the active Systems
        for (const auto& entity : entitiesToBeKilled)
        {
            if (!entity.Exists()) continue;
            //OnEntityDestroy(entity);
            RemoveEntityFromSystems(entity);
            entityComponentSignatures[entity.GetId()].reset();

            // Remove the entity from component pools
            for (auto pool : componentPools)
            {
                if (pool)
                {
                    pool->RemoveEntityFromPool(entity.GetId());
                }
            }

            // Make the entity id available to be reused
            freeIds.push_back(entity.GetId());

            // Remove any traces of that entity from the tag/group maps
            RemoveEntityTag(entity);
            RemoveEntityGroup(entity);

            // Remove the entity from the entities vector
            entities.erase(std::remove_if(entities.begin(), entities.end(),
                [&entity](const Entity& e) { return e.GetId() == entity.GetId(); }),
                entities.end());
        }
        entitiesToBeKilled.clear();
    }

    void Registry::RuntimeUpdate(Entity e)
    {
        //if (e.Exists()) return;

#ifndef IMGUI_DISABLE
        if (GetSystem<Editor>().editorState == Editor::EDITING) return;
#endif

        std::set<Entity>::iterator i = std::find(entitiesToBeAdded.begin(), entitiesToBeAdded.end(), e);
        if (i != entitiesToBeAdded.end())
        {
            AddEntityToSystems(e);
            OnEntityCreate(e);
            entitiesToBeAdded.erase(i);
        }
    }

    void Registry::ForceRuntimeUpdate(Entity e) // FIX
    {
        //if (e.Exists()) return;

#ifndef IMGUI_DISABLE
        if (GetSystem<Editor>().editorState == Editor::EDITING) return;
#endif
        AddEntityToSystems(e);
        OnEntityCreate(e);
        entitiesToBeAdded.erase(e);
    }

    void Registry::EntitySignatureChanged(Entity entity, const Signature& entitySignature)
	{
		// Notify each system that an entity's signature has changed
		for (auto& system : systems)
		{
			const auto& systemComponentSignature = system.second->GetComponentSignature();

            // Check if system is interested in this entity
			bool isInterested = (entitySignature & systemComponentSignature) == systemComponentSignature;
			
            bool alreadyTracking = system.second->HasEntity(entity);

			// Add entity to system if entityComponentSignature matches systemConponentSignature
			if (isInterested && !alreadyTracking)
			{
				system.second->AddEntityToSystem(entity);
			}
			// Remove entity from system if entityComponentSignature does not match systemConponentSignature
			else if (!isInterested && alreadyTracking)
			{
				system.second->RemoveEntityFromSystem(entity);
			}
		}

        Update();
	}

    void Registry::ClearInstancedEntities()
    {
        std::vector<Entity> entitiesToRemove;

        for (const auto& entity : GetAllEntities())
        {
            if (entity.BelongsToGroup("instanced_entity"))
            {
                entitiesToRemove.push_back(entity);
            }
        }

        for (const auto& entity : entitiesToRemove)
        {
            KillEntity(entity);
        }

        Logger::Info("Cleared " + std::to_string(entitiesToRemove.size()) + " instanced entities");
    }

    void Registry::CachePreRuntime()
    {
        cacheFreeIds.clear();
        for (auto ids : freeIds)
            cacheFreeIds.push_back(ids);

        //cacheNumEntities = numEntities;
    }
    void Registry::ResetToPreRuntime()
    {
        freeIds.clear();
        for (auto ids : cacheFreeIds)
            freeIds.push_back(ids);

        //numEntities = cacheNumEntities;
    }

    int Registry::GetFreeIdCount() const
    {
        return static_cast<int>(freeIds.size());
    }

    std::vector<int> Registry::GetFreeIds() const
    {
        std::vector<int> container{};
        for (auto ids : freeIds)
            container.push_back(ids);
        return container;
    }

    void Registry::ResetEntityComponentSignatures()
    {
        entityComponentSignatures.clear();
    }

    Entity Registry::GetClonedFrom(Entity entity) 
    {
        return GetEntityById(clonedFromIds[entity.GetId()]);
    }

    void Registry::SetClonedFrom(Entity entity, Entity original)
    {
        clonedFromIds[entity.GetId()] = original.GetId();
    }

    std::vector<Signature> Registry::StashPersistentEntities(std::set<Entity>& persistent)
    {
        std::vector<Signature> signatures{};
        for (Entity const e : persistent)
        {
            signatures.push_back(entityComponentSignatures[e.GetId()]);
            RemoveEntityFromSystems(e);
        }
        return signatures;
    }

    void Registry::RestorePersistentEntities(std::vector<Signature>& signatures)
    {
        std::vector<Entity> persistentEntities{};
        for (Signature sig : signatures)
        {
            persistentEntities.push_back(CreateEntity());
        }
        Update();
        for (size_t i{}; i < persistentEntities.size(); ++i)
        {
            entityComponentSignatures[persistentEntities[i].GetId()] = signatures[i];
            AddEntityToSystems(persistentEntities[i]);
        }
        Update();
    }

    void Registry::OnEntityCreate(Entity const& entity)
    {
#ifndef IMGUI_DISABLE
        if (GetSystem<Editor>().IsEditorRunning())
        {
#endif
            if (entity.HasComponent<LogicComponent>())
            {
                GetSystem<LogicSystem>().CSOnEntityCreate(entity.GetId(), entity.GetComponent<LogicComponent>().scriptObject);
            }

            if (entity.HasComponent<AudioComponent>())
            {
                entity.GetComponent<AudioComponent>().Update(GetSystem<AudioSystem>());
            }
#ifndef IMGUI_DISABLE
        }
#endif
    }

    void Registry::OnEntityDestroy(Entity entity)
    {
#ifndef IMGUI_DISABLE
        if (GetSystem<Editor>().IsEditorRunning())
        {
#endif
            if (entity.HasComponent<LogicComponent>())
            {
                switch (entity.GetComponent<LogicComponent>().scriptLang)
                {
                case ScriptLang::CPP:
                    GetSystem<LogicSystem>().CPPOnEntityDestroy(entity.GetId());
                    break;
                case ScriptLang::CS:
                    GetSystem<LogicSystem>().
                        CSOnEntityDestroy(entity.GetId(), entity.GetComponent<LogicComponent>().scriptObject);
                    break;
                case ScriptLang::UNASSIGNED:
                    break;
                }
            }

            if (entity.HasComponent<AudioComponent>())
            {
                //Logger::Critical(std::to_string(entity.GetId()));
                GetSystem<AudioSystem>().GetAudioInst(entity.GetComponent<AudioComponent>().data).Kill();
            }

            //if ()

#ifndef IMGUI_DISABLE
        }
        GetSystem<Popplio::Editor>().ResetSelectedEntity(entity);
#endif
    }

    bool operator==(const Entity& lhs, const Entity& rhs) { return lhs.GetId() == rhs.GetId(); }

    bool operator!=(const Entity& lhs, const Entity& rhs) { return lhs.GetId() != rhs.GetId(); }

    bool operator<(const Entity& lhs, const Entity& rhs) { return lhs.GetId() < rhs.GetId(); }

    bool operator>(const Entity& lhs, const Entity& rhs) { return lhs.GetId() > rhs.GetId(); }
}

================
File: ECS/ECS.h
================
/******************************************************************************/
/*!
\file   ECS.h
\author Team Popplio
\author Bryan Ang Wei Ze
\co-author Ng Jun Heng Shawn
\contribution Bryan - 95% | Shawn - 5%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/10/02
\brief
        This is the header file for the Entity Component System of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once

#include <bitset>
#include <vector>
#include <unordered_map>
#include <typeindex>
#include <set>
#include <memory>
#include <deque>

#include "../EventBus/Event.h"
#include "../Logging/Logger.h"

namespace Popplio
{
	static const unsigned int MAX_COMPONENTS = 32;

	using Signature = std::bitset<MAX_COMPONENTS>;

    /**
    * @brief An interface class for components in the ECS system.
    * 
    * This class provides a base for all components in the ECS system.
    * It contains a protected static variable `nextId` which is used to assign unique ids to each component type.
    */
    struct IComponent
    {
    protected:
        static int nextId; /**< The next available id for a component type. */
    };

    /**
    * @brief A base class for components in the ECS system.
    * 
    * This class provides a static method to get the unique id of a component type.
    */
    template <typename T>
    class Component: public IComponent
    {
    public:
    /**
    * @brief Get the unique id of Component<T>.
    * 
    * @return int The unique id of Component<T>.
    */
		static int GetId()
		{
			static auto id = nextId++;
			return id;
		}
    };

    /**
    * @brief Represents an entity in the ECS system.
    * 
    * This class provides methods to manipulate and query an entity in the ECS system.
    */
    class Entity
    {
    public:
        /**
        * @brief Constructs an Entity object with the given id.
        * 
        * @param id The id of the entity.
        */
        Entity(int id) : id(id), registry(nullptr) {};

        /**
        * @brief Kills the entity.
        * 
        * This method marks the entity for removal from the registry.
        */
        void Kill();

        bool Exists() const;

        /**
        * @brief Gets the id of the entity.
        * 
        * @return int The id of the entity.
        */
        int GetId() const;

        /**
        * @brief Tags the entity with the given tag.
        * 
        * @param tag The tag to assign to the entity.
        */
        void Tag(const std::string& tag);

        /**
        * @brief Checks if the entity has the given tag.
        * 
        * @param tag The tag to check.
        * @return bool True if the entity has the tag, false otherwise.
        */
        bool HasTag(const std::string& tag) const;

        std::string GetTag() const;

        /**
        * @brief Groups the entity with the given group.
        * 
        * @param group The group to assign to the entity.
        */
        void Group(const std::string& group);

        /**
        * @brief Checks if the entity belongs to the given group.
        * 
        * @param group The group to check.
        * @return bool True if the entity belongs to the group, false otherwise.
        */
        bool BelongsToGroup(const std::string& group) const;

        /**
        * @brief Adds a component of type TComponent to the entity.
        * 
        * @tparam TComponent The type of the component to add.
        * @tparam TArgs The types of the arguments to forward to the component's constructor.
        * @param args The arguments to forward to the component's constructor.
        */
        template <typename TComponent, typename ...TArgs>
        void AddComponent(TArgs&& ...args);

        /**
        * @brief Removes the component of type TComponent from the entity.
        * 
        * @tparam TComponent The type of the component to remove.
        */
        template <typename TComponent>
        void RemoveComponent();

        /**
        * @brief Checks if the entity has a component of type TComponent.
        * 
        * @tparam TComponent The type of the component to check.
        * @return bool True if the entity has the component, false otherwise.
        */
        template <typename TComponent>
        bool HasComponent() const;

        /**
        * @brief Gets the component of type TComponent from the entity.
        * 
        * @tparam TComponent The type of the component to get.
        * @return TComponent& The reference to the component.
        */
        template <typename TComponent>
        TComponent& GetComponent() const;

        Entity Clone() const;

        //bool operator==(const Entity& other) const;

        Entity GetClonedFrom() const;
        //void SetClonedFrom(int ent);

        /**
        * @brief Holds a pointer to the entity's owner registry.
        */
        class Registry* registry;

    private:
        int id;
        //int clonedFrom; // id of entity that this entity was cloned from
    };

    class EntityRef // for use in mono
    {
        public:
        Entity& entity;
        EntityRef(Entity& e) : entity(e) {}
    };

    /**
    * @brief Represents a system in the ECS system.
    * 
    * This class provides methods to add and remove entities from the system, as well as retrieve the entities and component signature of the system.
    */
    class System
    {
    public:
        /**
        * @brief Virtual destructor for the System class.
        */
        virtual ~System() = default;

        /**
        * @brief Adds an entity to the system.
        * 
        * @param entity The entity to add.
        */
        void AddEntityToSystem(Entity entity);

        /**
        * @brief Removes an entity from the system.
        * 
        * @param entity The entity to remove.
        */
        void RemoveEntityFromSystem(Entity entity);

        /**
        * @brief Gets the entities in the system.
        * 
        * @return std::vector<Entity> The entities in the system.
        */
        std::vector<Entity> GetSystemEntities() const;

        /**
        * @brief Gets the component signature of the system.
        * 
        * @return const Signature& The component signature of the system.
        */
        const Signature& GetComponentSignature() const;

        bool HasEntity(Entity entity) const;

        /**
        * @brief Defines the component type that entities must have to be considered by the system.
        * 
        * @tparam TComponent The component type.
        */
        template <typename TComponent>
        void RequireComponent();
    private:
        Signature componentSignature; /**< The component signature for the system. */
        std::vector<Entity> entities; /**< The entities in the system. */
    };

	/**
	* @brief An interface class for component pools in the ECS system.
	*
	* This class provides a base for all component pools in the ECS system.
	* It defines a virtual method `RemoveEntityFromPool` that must be implemented by derived classes.
	*/
    class IPool
    {
    public:
        /**
        * @brief Virtual destructor for the IPool class.
        */
        virtual ~IPool() = default;

        /**
        * @brief Removes an entity from the pool.
        * 
        * @param entityId The id of the entity to remove.
        */
        virtual void RemoveEntityFromPool(int entityId) = 0;
    };

    /**
    * @brief Represents a pool of objects of type T in the ECS system.
    * 
    * This class template provides methods to manage a pool of objects of type T in the ECS system.
    * It inherits from the IPool interface.
    */
    template <typename T>
    class Pool : public IPool
    {
    public:
		/**
		* @brief Constructs a Pool object with the given capacity.
		* 
		* @param capacity The capacity of the pool.
		*/
		Pool(int capacity = 100)
		: size(0)
		{
			data.resize(capacity);
		}

		/**
		* @brief Virtual destructor for the Pool class.
		*/
		virtual ~Pool() = default;

		/**
		* @brief Checks if the pool is empty.
		* 
		* @return bool True if the pool is empty, false otherwise.
		*/
		bool IsEmpty() const
		{
			return size == 0;
		}

		/**
		* @brief Gets the size of the pool.
		* 
		* @return int The size of the pool.
		*/
		int GetSize() const
		{
			return size;
		}

        /**
        * @brief Resizes the pool to the specified size.
        * 
        * @param n The new size of the pool.
        */
        void Resize(int n)
        {
			data.resize(n);
        }

        /**
        * @brief Clears the pool.
        * 
        * This method removes all elements from the pool and resets the size to 0.
        */
        void Clear()
        {
			data.clear();
			size = 0;
        }

        /**
        * @brief Adds an object to the pool.
        * 
        * @param object The object to add to the pool.
        */
        void Add(T&& object)
        {
			data.push_back(std::move(object));
        }

        /**
        * @brief Sets the object at the specified entity id in the pool.
        * 
        * If the entity id already exists in the pool, the existing object is replaced with the new object.
        * If the entity id is new, the object is added to the pool and the entity id is tracked.
        * If the pool capacity is reached, the pool is resized by doubling its current capacity.
        * 
        * @param entityId The id of the entity.
        * @param object The object to set in the pool.
        */
        void Set(int entityId, T&& object)
        {
			if (entityIdToIndex.find(entityId) != entityIdToIndex.end())
			{
				// If the element already exists, simply replace the component object
				int index = entityIdToIndex[entityId];
				data[index] = std::move(object);
			}
			else
			{
				// When a new object, we keep track of the entity ids and their vector index
				int index = size;
				entityIdToIndex.emplace(entityId, index);
				indexToEntityId.emplace(index, entityId);
				if (index >= data.capacity())
				{
					// necessary, we resize by always doubling the current capacity
					data.resize(size * 2);
				}

				data[index] = std::move(object);
				++size;
			}
        }

        /**
        * @brief Removes the entity with the specified entityId from the pool.
        * 
        * This method removes the entity with the specified entityId from the pool and updates the index-entity maps accordingly.
        * If the entityId does not exist in the pool, no action is taken.
        *
        * @param entityId The id of the entity to remove from the pool.
        */
        void Remove(int entityId)
        {
			// Copy the last element to the deleted position to keep the array packed
			int indexOfRemoved = entityIdToIndex[entityId];
			int indexOfLast = size - 1;
			data[indexOfRemoved] = data[indexOfLast];

			// Update the index-entity maps to point to the correct elements
			int entityIdOfLastElement = indexToEntityId[indexOfLast];
			entityIdToIndex[entityIdOfLastElement] = indexOfRemoved;
			indexToEntityId[indexOfRemoved] = entityIdOfLastElement;

			entityIdToIndex.erase(entityId);
			indexToEntityId.erase(indexOfLast);

			--size;
        }

        /**
        * @brief Removes the entity with the specified entityId from the pool.
        * 
        * This method removes the entity with the specified entityId from the pool and updates the index-entity maps accordingly.
        * If the entityId does not exist in the pool, no action is taken.
        *
        * @param entityId The id of the entity to remove from the pool.
        */
        void RemoveEntityFromPool(int entityId) override
        {
			if (entityIdToIndex.find(entityId) != entityIdToIndex.end())
			{
				Remove(entityId);
			}
        }

        /**
        * @brief Gets the object at the specified entity id in the pool.
        * 
        * @param entityId The id of the entity.
        * @return T& The reference to the object.
        */
        T& Get(int entityId)
        {
            auto it = entityIdToIndex.find(entityId);
            if (it == entityIdToIndex.end())
            {
                throw std::out_of_range("Trying to get non-existent component");
            }
            return data[it->second];
        }

        /**
        * @brief Gets the object at the specified index in the pool.
        * 
        * @param index The index of the object in the pool.
        * @return T& The reference to the object.
        */
        T& operator[](unsigned int index)
        {
			return data[index];
        }

	private:
		// Keep track of the vector of component objects and their current size
		std::vector<T> data;
		int size;

		// Maps to keep track of entity ids per index so that the vector is always packed
		std::unordered_map<int, int> entityIdToIndex;
		std::unordered_map<int, int> indexToEntityId;
	};

	
	class Registry
	{
	public:
		int GetNumEntities() const;

        void ResetNumEntities();

        void UpdateNumEntities();

		void ClearFreeIds();
        /**
        * @brief Updates the ECS registry.
        * 
        * This method updates the ECS registry by processing any pending entity additions or removals.
        * It is responsible for adding new entities to their respective systems and removing killed entities from the systems.
        */
        void Update();

        void RuntimeUpdate(Entity e);

        void ForceRuntimeUpdate(Entity e);

        bool KillEntityQueueIsEmpty() const;

        const std::vector<Entity>& GetAllEntities() const;

        std::vector<Entity>& GetAllEntitiesMutable();

        /**
        * @brief Creates a new entity in the ECS registry.
        * 
        * @param original The id of the entity that this entity was cloned from if it was cloned.
        * 
        * @param idToSetTo The id to set the entity to if it is not -1 (for deserialization, etc).
        * 
        * @return Entity The newly created entity.
        */
        Entity CreateEntity(int original = -1, int idToSetTo = -1);

        void KillEntityFirstPass(Entity entity);

        std::set<Entity>& KillEntitySecondPass(Entity entity, std::set<Entity>& killedEntities);

        void KillEntityRuntime(Entity entity);

        /**
        * @brief Kills the specified entity in the ECS registry.
        * 
        * @param entity The entity to kill.
        */
        void KillEntity(Entity entity);

        /**
        * @brief Kills all entities in the ECS registry.
        */
        void KillAllEntities();

        /**
        * @brief Checks if an entity with the specified id exists in the ECS registry.
        * 
        * @param entityId The id of the entity to check.
        * @return bool True if the entity exists, false otherwise.
        */
        bool EntityExists(int entityId) const;

        /**
        * @brief Gets the entity with the specified id from the ECS registry.
        * 
        * @param entityId The id of the entity to get.
        * @return Entity The entity with the specified id.
        */
        Entity GetEntityById(int entityId);

        /**
        * @brief Gets entity ref with the specified id from the ECS registry.
        *
        * @param entityId The id of the entity to get.
        * @return Entity& The entity with the specified id.
        */
        //Entity& RefEntityById(int entityId);

        /**
        * @brief Tags the specified entity with the given tag.
        * 
        * @param entity The entity to tag.
        * @param tag The tag to assign to the entity.
        */
        void TagEntity(Entity entity, const std::string& tag);

        /**
        * @brief Checks if the specified entity has the given tag.
        * 
        * @param entity The entity to check.
        * @param tag The tag to check.
        * @return bool True if the entity has the tag, false otherwise.
        */
        bool EntityHasTag(Entity entity, const std::string& tag) const;

        /**
        * @brief Checks if the entity has any tag assigned.
        * 
        * This method checks if the entity has any tag assigned to it.
        * 
        * @param entity The entity to check.
        * @return bool True if the entity has any tag assigned, false otherwise.
        */
        bool EntityHasAnyTag(Entity entity) const;

        /**
        * @brief Gets the entity with the specified tag from the ECS registry.
        * 
        * @param tag The tag of the entity to get.
        * @return Entity The entity with the specified tag.
        */
        Entity GetEntityByTag(const std::string& tag) const;

        /**
        * @brief Gets the tag of the specified entity.
        * 
        * @param entity The entity to get the tag from.
        * @return std::string The tag of the entity.
        */
        std::string GetEntityTag(Entity entity) const;

        /**
        * @brief Removes the tag from the specified entity in the ECS registry.
        * 
        * @param entity The entity to remove the tag from.
        */
        void RemoveEntityTag(Entity entity);

        /**
        * @brief Groups the entity with the given group.
        *
        * @param entity The entity to group.
        * @param group The group to assign to the entity.
        */
        void GroupEntity(Entity entity, const std::string& group);

        /**
        * @brief Checks if the entity belongs to the given group.
        *
        * @param entity The entity to check.
        * @param group The group to check.
        * @return bool True if the entity belongs to the group, false otherwise.
        */
        bool EntityBelongsToGroup(Entity entity, const std::string& group) const;

        /**
        * @brief Checks if the entity belongs to any group.
        * 
        * This method checks if the entity belongs to any group.
        * 
        * @param entity The entity to check.
        * @return bool True if the entity belongs to any group, false otherwise.
        */
        bool EntityBelongsToAnyGroup(Entity entity) const;

        /**
        * @brief Gets the entities in the specified group.
        *
        * @param group The group to get the entities from.
        * @return std::vector<Entity> The entities in the group.
        */
        std::vector<Entity> GetEntityByGroup(const std::string& group) const;

        /**
        * @brief Gets the group of the specified entity.
        * 
        * This method retrieves the group of the specified entity.
        * 
        * @param entity The entity to get the group from.
        * @return std::string The group of the entity.
        */
        std::string GetEntityGroup(Entity entity) const;

        /**
        * @brief Removes the entity from its group.
        *
        * @param entity The entity to remove from the group.
        */
        void RemoveEntityGroup(Entity entity);

        // Component management
        /**
        * @brief Adds a component of type TComponent to the entity.
        *
        * @tparam TComponent The type of the component to add.
        * @tparam TArgs The types of the arguments to forward to the component's constructor.
        * @param entity The entity to add the component to.
        * @param args The arguments to forward to the component's constructor.
        */
        template <typename TComponent, typename ...TArgs>
        void AddComponent(Entity entity, TArgs&& ...args);

        /**
        * @brief Removes the component of type TComponent from the entity.
        *
        * @tparam TComponent The type of the component to remove.
        * @param entity The entity to remove the component from.
        */
        template <typename TComponent>
        void RemoveComponent(Entity entity);

        /**
        * @brief Checks if the entity has a component of type TComponent.
        *
        * @tparam TComponent The type of the component to check.
        * @param entity The entity to check.
        * @return bool True if the entity has the component, false otherwise.
        */
        template <typename TComponent>
        bool HasComponent(Entity entity) const;

        /**
        * @brief Gets the component of type TComponent from the entity.
        *
        * @tparam TComponent The type of the component to get.
        * @param entity The entity to get the component from.
        * @return TComponent& The reference to the component.
        */
        template <typename TComponent>
        TComponent& GetComponent(Entity entity) const;

        /**
        * @brief Adds a system of type TSystem to the ECS registry.
        *
        * This method adds a system of type TSystem to the ECS registry.
        *
        * @tparam TSystem The type of the system to add.
        * @tparam TArgs The types of the arguments to forward to the system's constructor.
        * @param args The arguments to forward to the system's constructor.
        */
        template <typename TSystem, typename ...TArgs>
        void AddSystem(TArgs&& ...args);

        /**
        * @brief Removes the system of type TSystem from the ECS registry.
        *
        * This method removes the system of type TSystem from the ECS registry.
        *
        * @tparam TSystem The type of the system to remove.
        */
        template <typename TSystem>
        void RemoveSystem();

        /**
        * @brief Checks if the system of type TSystem exists in the ECS registry.
        *
        * This method checks if the system of type TSystem exists in the ECS registry.
        *
        * @tparam TSystem The type of the system to check.
        * @return bool True if the system exists, false otherwise.
        */
        template <typename TSystem>
        bool HasSystem() const;

        /**
        * @brief Gets the system of type TSystem from the ECS registry.
        *
        * This method gets the system of type TSystem from the ECS registry.
        *
        * @tparam TSystem The type of the system to get.
        * @return TSystem& The reference to the system.
        */
        template <typename TSystem>
        TSystem& GetSystem() const;

        /**
        * @brief Adds an entity to its systems.
        *
        * This method adds an entity to its systems.
        *
        * @param entity The entity to add.
        */
        void AddEntityToSystems(Entity entity);

        /**
        * @brief Removes an entity from its systems.
        *
        * This method removes an entity from its systems.
        *
        * @param entity The entity to remove.
        */
        void RemoveEntityFromSystems(Entity entity);

        /**
        * @brief Notifies the system that the signature of an entity has changed.
        * 
        * This method is called by the Entity class when the signature of an entity has changed.
        * It takes the entity and its new signature as parameters.
        * The system uses this method to update the component signature of the entity in the system.
        * 
        * @param entity The entity whose signature has changed.
        * @param entitySignature The new signature of the entity.
        */
        void EntitySignatureChanged(Entity entity, const Signature& entitySignature);

        /**
        * @brief Clears instanced entities
        *
        * This method is completed instantly without queueing
        */
        void ClearInstancedEntities();

        // for runtime
        void CachePreRuntime(); // cache ECS info pre runtime to be reset to after runtime
        void ResetToPreRuntime(); // reset ECS info to pre runtime

        int GetFreeIdCount() const;
        std::vector<int> GetFreeIds() const;

        void ResetEntityComponentSignatures();

        Entity GetClonedFrom(Entity entity);

        void SetClonedFrom(Entity entity, Entity original);

        std::vector<Signature> StashPersistentEntities(std::set<Entity>& persistent);

        void RestorePersistentEntities(std::vector<Signature>& signatures);

	private:
		// Keep track of how many entities were added to the scene
		//int numEntities = 0;

        /**< The entities in the ECS registry. */
        std::vector<Entity> entities;

		/*
			Vector of component pools, each pool contains all the data for a certain component type
			[vector index = componentId]
			[entity id -> pool index] (mIndexToEntityId)
		*/
		std::vector<std::shared_ptr<IPool>> componentPools;
	
		/*
			Vector of component signatures per entity, saying which component is turned "on" for a given entity
			[vector index = entityId]
		*/
		std::vector<Signature> entityComponentSignatures;

		/*
			Unordered map of active systems
			index = system typeId]
		*/
		std::unordered_map<std::type_index, std::shared_ptr<System>> systems;
	
		// Set of entities that are flagged to be added or removed in the next registry Update()
		std::set<Entity> entitiesToBeAdded;
		std::set<Entity> entitiesToBeKilled;

		// Entity tags (one tag name per entity)
		std::unordered_map<std::string, Entity> entityPerTag;
		std::unordered_map<int, std::string> tagPerEntity;

		// Entity groups (a set of entities per group name and an entity belongs to only one group)
		std::unordered_map<std::string, std::set<Entity>> entitiesPerGroup;
		std::unordered_map<int, std::string> groupsPerEntity;

		// List of free entity ids that were previously removed
		std::deque<int> freeIds;

        // Entity cloned from ids
        std::unordered_map<int, int> clonedFromIds; // Key: entity id, Value: original entity id

        // runtime
        std::deque<int> cacheFreeIds{};
        int cacheNumEntities = 0;


        /**
        * @brief Behaviour on entity creation
        *
        * This method adds behaviours on entity creation.
        *
        * @param entity The entity created.
        */
        void OnEntityCreate(Entity const& entity);
        /**
        * @brief Behaviour on entity destruction
        *
        * This method adds behaviours on entity destruction.
        *
        * @param entity The entity destroyed.
        */
        void OnEntityDestroy(Entity entity);
	};
	
    /**
    * @brief Overloads the equality operator for comparing two Entity objects.
    * 
    * @param lhs The left-hand side Entity object.
    * @param rhs The right-hand side Entity object.
    * @return bool True if the two Entity objects are equal, false otherwise.
    */
    bool operator==(const Entity& lhs, const Entity& rhs);

    /**
    * @brief Overloads the inequality operator for comparing two Entity objects.
    * 
    * @param lhs The left-hand side Entity object.
    * @param rhs The right-hand side Entity object.
    * @return bool True if the two Entity objects are not equal, false otherwise.
    */
    bool operator!=(const Entity& lhs, const Entity& rhs);

    /**
    * @brief Overloads the less than operator for comparing two Entity objects.
    * 
    * @param lhs The left-hand side Entity object.
    * @param rhs The right-hand side Entity object.
    * @return bool True if lhs is less than rhs, false otherwise.
    */
    bool operator<(const Entity& lhs, const Entity& rhs);

    /**
    * @brief Overloads the greater than operator for comparing two Entity objects.
    * 
    * @param lhs The left-hand side Entity object.
    * @param rhs The right-hand side Entity object.
    * @return bool True if lhs is greater than rhs, false otherwise.
    */
    bool operator>(const Entity& lhs, const Entity& rhs);

    // =================================================================== //

    struct EntityRuntimeChangeEvent : public Event // on change at runtime
    {
        enum Change
        {
            ADDED = 0,
            REMOVED = 1,
            MODIFIED = 2
        };

        Change change;
        int id;

        EntityRuntimeChangeEvent(Change change, int id) : change(change), id(id) {}
    };

    // =================================================================== //

	template <typename TComponent>
	void System::RequireComponent()
	{
		const auto componentId = Component<TComponent>::GetId();
		componentSignature.set(componentId);
	}

	template <typename TSystem, typename ...TArgs>
	void Registry::AddSystem(TArgs&& ...args)
	{
		std::shared_ptr<TSystem> newSystem = std::make_shared<TSystem>(std::forward<TArgs>(args)...);
		systems.insert(std::make_pair(std::type_index(typeid(TSystem)), newSystem));
	}

	template <typename TSystem>
	void Registry::RemoveSystem()
	{
		auto system = systems.find(std::type_index(typeid(TSystem)));
        if (system != systems.end())
        {
            systems.erase(system);
        }
	}

	template <typename TSystem>
	bool Registry::HasSystem() const
	{
		return systems.find(std::type_index(typeid(TSystem))) != systems.end();
	}

	template <typename TSystem>
	TSystem& Registry::GetSystem() const
	{
		auto system = systems.find(std::type_index(typeid(TSystem)));
        if (system == systems.end())
        {
            throw std::runtime_error("System not found");
        }
		return *(std::static_pointer_cast<TSystem>(system->second));
	}

	template <typename TComponent, typename ...TArgs>
	void Registry::AddComponent(Entity entity, TArgs&& ...args)
	{
		const auto componentId = Component<TComponent>::GetId();
		const auto entityId = entity.GetId();

		// If the component id is greater than the current size of the componentPools, then resize the vector
		if (componentId >= componentPools.size())
		{
			componentPools.resize(componentId + 1, nullptr);
		}

		// If we still don't have a Pool for that component type
		if (!componentPools[componentId])
		{
			std::shared_ptr<Pool<TComponent>> newComponentPool = std::make_shared<Pool<TComponent>>();
			componentPools[componentId] = newComponentPool;
		}

		// Get the pool of component values for that component type
		std::shared_ptr<Pool<TComponent>> componentPool = std::static_pointer_cast<Pool<TComponent>>(componentPools[componentId]);

		// Create a new Component object of the type T, and forward the various parameters to the constructors
		TComponent newComponent(std::forward<TArgs>(args)...);

		// Add the component to the component pool list, using the entity Id as index
		componentPool->Set(entityId, std::move(newComponent));

		// Finally, change the component signature of the entity and set the component id on the bitset to 1
		entityComponentSignatures[entityId].set(componentId);

        // Notify systems that an entity's components have changed
        EntitySignatureChanged(entity, entityComponentSignatures[entityId]);

		Logger::Debug("Component added to Entity ID: " + std::to_string(entity.GetId()) +
			", Component Type: " + typeid(TComponent).name());
	}

	template <typename TComponent>
	void Registry::RemoveComponent(Entity entity)
	{
		const auto componentId = Component<TComponent>::GetId();
		const auto entityId = entity.GetId();

        if (!entityComponentSignatures[entityId].test(componentId))
        {
            Logger::Warning("Tried to remove non-existent component from entity " + std::to_string(entityId));
            return;
        }

		// Remove the component from the component pool for that entity
		std::shared_ptr<Pool<TComponent>> componentPool = std::static_pointer_cast<Pool<TComponent>>(componentPools[componentId]);
		componentPool->Remove(entityId);

		// Set the component signature for that entity to false
		entityComponentSignatures[entityId].set(componentId, false);

        EntitySignatureChanged(entity, entityComponentSignatures[entityId]);

        Logger::Debug("Component removed from Entity ID: " + std::to_string(entity.GetId()) +
            ", Component Type: " + typeid(TComponent).name());
	}

	template <typename TComponent>
	bool Registry::HasComponent(Entity entity) const
	{
		const auto componentId = Component<TComponent>::GetId();
		const auto entityId = entity.GetId();
		return entityId < entityComponentSignatures.size() && entityComponentSignatures[entityId].test(componentId);
	}

	template <typename TComponent>
	TComponent& Registry::GetComponent(Entity entity) const
	{
		const auto componentId = Component<TComponent>::GetId();
		const auto entityId = entity.GetId();
        if (componentId >= componentPools.size() || !componentPools[componentId])
        {
            Logger::Error("Attempt to get non-existent component from Entity ID: " + std::to_string(entityId));
            throw std::runtime_error("Component not found");
        }
		auto componentPool = std::static_pointer_cast<Pool<TComponent>>(componentPools[componentId]);
		return componentPool->Get(entityId);
	}

	template <typename TComponent, typename ...TArgs>
	void Entity::AddComponent(TArgs&& ...args)
	{
		registry->AddComponent<TComponent>(*this, std::forward<TArgs>(args)...);
	}

	template <typename TComponent>
	void Entity::RemoveComponent()
	{
		registry->RemoveComponent<TComponent>(*this);
	}

	template <typename TComponent>
	bool Entity::HasComponent() const
	{
		return registry->HasComponent<TComponent>(*this);
	}

	template <typename TComponent>
	TComponent& Entity::GetComponent() const
	{
		return registry->GetComponent<TComponent>(*this);
	}
}

================
File: Engine/Engine.cpp
================
/******************************************************************************/
/*!
\file   Engine.cpp
\author Team Popplio
\author Bryan Ang Wei Ze
\co-author	Ng Jun Heng Shawn | Shannon | Hafawati Binte Mohd Ali
\contribution Bryan - 70%, Shawn - 15%, Shannon - 5%, Hafawati - 10%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/11/30
\brief
	This is the source file for the core of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

//Precompiled header
#include <pch.h>

//Header
#include "Engine.h"

//Debug
#include "../PerformanceViewer/PerformanceViewer.h"

//ECS
#include "../ECS/ECS.h"

//Systems
#include "../Physics/MovementSystem.h"
#include "../Graphic/RenderSystem.h"
#include "../Input/InputSystem.h"
#include "../Cloning/CloneSystem.h"
#include "../Audio/AudioSystem.h"
#include "../Collision/CollisionSystem.h"
#include "../Physics/GravitySystem.h"
#ifndef IMGUI_DISABLE
#include "../Editor/Editor.h"
#endif
#include "../Script/LogicSystem.h"
#include "../Transformation/TransformationSystem.h"
#include "../PrefabManagement/PrefabSyncSystem.h"
#include "../Animation/AnimationSystem.h"
#include "../AssetStore/AssetLoader.h"
#include "../UI/UISystem.h"

#include "../Particles/ParticleSystem.h"
#include "../Hierarchy/HierarchySystem.h"
#include "../Scene/SceneManageSystem.h"
#include "../Runtime/RuntimeSystem.h"
#include "../Utilities/QueueSystem.h"

// Mono
#include "../Mono/MonoInternalCall.h"

//Utilities
#include "../Utilities/CrashHandler.h"
#include "../Utilities/OnAppQuit.h"

//Components
#include "../Utilities/Components.h"

#include "../Utilities/Rand.h"

//Libraries
#include <glad/glad.h>

#include <windows.h> // can cause conflicts with other libraries / headers

// test //

// test //

namespace Popplio
{
	LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam);
	// Hook handle 
	HHOOK keyboardHook;

	static GLFWwindow* g_window = nullptr; // Global pointer for the window

	void SetWindowForHook(GLFWwindow* window)
	{
		g_window = window;
	}

	// configuration

	std::string Engine::Config::engineVer;
    std::string Engine::Config::appVer;

	int Engine::Config::windowWidth;
	int Engine::Config::windowHeight;
	bool Engine::Config::vSync;

	bool Engine::Config::safeMode;
    std::string Engine::Config::lastScene;
    bool Engine::Config::verbose;

    std::string Engine::Config::startScene;

	//Engine::Config config{};

	//bool Engine::isEditorEnabled = true;

	// ===========================

	// runtime

	PopplioUtil::Timer Engine::timer;
	double Engine::framesPerSecond;

	bool Engine::isPaused;
	bool Engine::fullscreen = false;

	// Add new variables to store the original window position and size
	static int windowedPosX = 0, windowedPosY = 0;
	static int windowedWidth = 0, windowedHeight = 0;

	// Flag to track ALT+TAB state
	bool altTabPressed = false;
	bool ctrlAltDelPressed = false;
	static bool wasMaximized = false;


	// test //
	// test //

	PopplioPhysics::Gravity Engine::gravity(20.00); //declare for gravity value

	bool Engine::isSceneChanging = false;

	std::string Engine::programPath = "";

	// glfw: whenever the window size changed (by OS or user resize) this callback function executes
	// ---------------------------------------------------------------------------------------------
	void framebuffer_size_callback(GLFWwindow* window, int width, int height)
	{
        static_cast<void>(window);

		// make sure the viewport matches the new window dimensions; note that width and
		// height will be significantly larger than specified on retina displays.
		glViewport(0, 0, width, height);

		Engine::Config::windowWidth = width;
		Engine::Config::windowHeight = height;


		// Update Editor's viewport size
#ifndef IMGUI_DISABLE
		Editor* editor = static_cast<Editor*>(glfwGetWindowUserPointer(window));
		if (editor)
		{
			// Scene viewport will be resized dynamically based on window size
			editor->ResizeFramebufferTexture(editor->GetSceneFramebuffer(), width, height);
			editor->SetSceneViewportSize(width, height);

			// Game viewport will be resized dynamically based on window size
			editor->ResizeFramebufferTexture(editor->GetGameFramebuffer(), width, height);
			editor->SetGameViewportSize(width, height);
		}
#endif // !IMGUI_DISABLE
	}

	// Keyboard hook callback
	LRESULT CALLBACK LowLevelKeyboardProc(int nCode, WPARAM wParam, LPARAM lParam)
	{
		if (nCode == HC_ACTION)
		{
			KBDLLHOOKSTRUCT* pKeyBoard = (KBDLLHOOKSTRUCT*)lParam;

			bool altPressed = (GetAsyncKeyState(VK_MENU) & 0x8000); // ALT key
			bool ctrlPressed = (GetAsyncKeyState(VK_CONTROL) & 0x8000); // CTRL key
			bool delPressed = (pKeyBoard->vkCode == VK_DELETE);
			bool tabPressed = (pKeyBoard->vkCode == VK_TAB);

			// Checks if keys are pressed
			if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)
			{
				if (altPressed && tabPressed)
				{

					// Track if the window was maximized before Alt-Tab
					wasMaximized = glfwGetWindowAttrib(g_window, GLFW_MAXIMIZED);

					altTabPressed = true;
					//std::cout << "ALT+TAB detected! Minimizing window..." << std::endl;

					Engine::isPaused = true;
					glfwIconifyWindow(g_window);
				}
				if (ctrlPressed && altPressed && delPressed)
				{
					ctrlAltDelPressed = true;
					//std::cout << "CTRL+ALT+DEL detected! Minimizing window..." << std::endl;

					Engine::isPaused = true;
					glfwIconifyWindow(g_window);
				}
			}
			// Checks when key is released
			else if (wParam == WM_KEYUP || wParam == WM_SYSKEYUP)
			{
				if (pKeyBoard->vkCode == VK_MENU || pKeyBoard->vkCode == VK_TAB)
				{
					altTabPressed = false;
				}
				if (pKeyBoard->vkCode == VK_MENU || pKeyBoard->vkCode == VK_CONTROL || pKeyBoard->vkCode == VK_DELETE)
				{
					ctrlAltDelPressed = false;
				}
			}
		}

		return CallNextHookEx(NULL, nCode, wParam, lParam);
	}

	// Callback to handle window focus changes 
	void window_focus_callback(GLFWwindow* window, int focused)
	{
		if (!focused)
		{
			//std::cout << "Window lost focus (manual trigger)." << std::endl;
		}
		else
		{
			
			if (glfwGetWindowAttrib(window, GLFW_ICONIFIED))
			{
				glfwRestoreWindow(window);
			}

			// If it was maximized before Alt-Tab, maximize it again
			if (wasMaximized)
			{
				glfwMaximizeWindow(window);
				wasMaximized = false;  // Reset flag after restoring
			}

			Engine::isPaused = false;
			//std::cout << "Window back in focus." << std::endl;
		}
	}

	// Sets window to fullscreen mode
	void Engine::SetFullScreen()
	{
		// Get the monitor and video mode for fullscreen
		GLFWmonitor* monitor = glfwGetPrimaryMonitor();
		const GLFWvidmode* mode = glfwGetVideoMode(monitor);

		// Store the current window position and size for later restoration
		glfwGetWindowPos(window, &windowedPosX, &windowedPosY);
		glfwGetWindowSize(window, &windowedWidth, &windowedHeight);

		// Switch to fullscreen mode
		glfwSetWindowMonitor(window, monitor, 0, 0, mode->width, mode->height, mode->refreshRate);
		glfwSwapInterval(Config::vSync); // Refresh context
	}

	// Sets window to windowed mode
	void Engine::SetWindowedMode()
	{
		// Restore the window size and position to the stored values
		glfwSetWindowMonitor(window, nullptr, windowedPosX, windowedPosY,
			windowedWidth, windowedHeight, GLFW_DONT_CARE);
		glfwSwapInterval(Config::vSync); // Refresh context
	}

	Engine::Engine()
		:window(nullptr),
		registry(std::make_unique<Registry>()),
		eventBus(std::make_unique<EventBus>()),
		serializer(std::make_unique<Serializer>(*registry, *layerManager, *prefabManager, *eventBus)),
		prefabManager(std::make_unique<PrefabManager>(*eventBus)),
		layerManager(std::make_unique<LayerManager>()),
		monoAPI(std::make_unique<PopplioScriptAPI::MonoAPI>(*registry))
	{

	}

	void Engine::Initialize()
	{
        programPath = std::filesystem::current_path().string(); // set program path

		// Set up Logger
		Logger::Initialize(LogLevel::DEBUG_LOG);
		Logger::Info("Engine intialization started", LogDestination::WINDOWS_CONSOLE);

		// Install the low-level keyboard hook
		keyboardHook = SetWindowsHookEx(WH_KEYBOARD_LL, LowLevelKeyboardProc, NULL, 0);
		if (!keyboardHook) {
			std::cerr << "Failed to install keyboard hook!" << std::endl;
			return;
		}

		// glfw: initialize and configure
		// ------------------------------
		if (!glfwInit())
		{
			Logger::Critical("Failed to initialize GLFW", LogDestination::WINDOWS_CONSOLE);
			return;
		}
		glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
		glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
		glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

#ifndef IMGUI_DISABLE
		glfwWindowHint(GLFW_RESIZABLE, GL_TRUE);
#else
		glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);
#endif // !IMGUI_DISABLE

        // Load configuration
		if (serializer->LoadConfiguration(POPPLIO_CONFIG_PATH))
		{
            Config::engineVer = serializer->GetConfiguration().engineVer;
            Config::appVer = serializer->GetConfiguration().appVer;
			Config::windowWidth = serializer->GetConfiguration().width;
			Config::windowHeight = serializer->GetConfiguration().height;
			Config::vSync = serializer->GetConfiguration().vSync;
            Config::safeMode = serializer->GetConfiguration().safeMode;
            Config::lastScene = serializer->GetConfiguration().lastScene;
			Config::verbose = serializer->GetConfiguration().verbose;
            Config::startScene = serializer->GetConfiguration().startScene;
		}

		window = glfwCreateWindow(Config::windowWidth, Config::windowHeight, "Team Popplio Engine", nullptr, nullptr);
		if (!window)
		{
			Logger::Critical("Failed to create GLFW window", LogDestination::WINDOWS_CONSOLE);
			glfwTerminate();
			return;
		}

		glfwMakeContextCurrent(window);
		glfwSwapInterval(Config::vSync);
		glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
		SetWindowForHook(window); // Set the window pointer
		glfwSetWindowFocusCallback(window, window_focus_callback);

		//GLFWimage image;
		//image.pixels = stbi_load("Team_Popplio.ico", &image.width, &image.height, 0, 4);
		//glfwSetWindowIcon(window, 1, &image);

		// glad: load all OpenGL function pointers
		// ---------------------------------------
		if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
		{
			Logger::Critical("Failed to initialize GLAD", LogDestination::WINDOWS_CONSOLE);
			return;
		}


		// Now that basic GL setup is done, we can initialize the loading screen
		loadingScreen = std::make_unique<LoadingScreen>(window);
		if (!loadingScreen->Initialize())
		{
			Logger::Error("Failed to initialize loading screen", LogDestination::WINDOWS_CONSOLE);
			return;
		}

		loadingScreen->Render();

		// Force a buffer swap to ensure the loading screen is visible
		glfwSwapBuffers(window);
		glfwPollEvents();

		// Load assets with progress reporting
		loadingScreen->LoadAssets([this](float progress)
		{
			static_cast<void>(progress);
			// This is the asset loading function that will be called by the loading screen
			// It will periodically update the progress value

			// Initialize core components (20%)
			cameraManager = std::make_unique<CameraManager>(Config::windowWidth, Config::windowHeight);
			InputSystem::Init(window);
			PopplioUtil::InitRand();
			glDisable(GL_DEPTH_TEST);
			glEnable(GL_BLEND);
			glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
			CrashHandler::Initialize();
			loadingScreen->Update(0.2f);
			loadingScreen->Render();

			// Initialize systems (50%)
			registry->AddSystem<MovementSystem>();
			registry->AddSystem<AudioSystem>(*registry);
			registry->AddSystem<CollisionSystem>(*eventBus, *layerManager);
			registry->AddSystem<GravitySystem>();
			registry->AddSystem<CloneSystem>(*registry, *layerManager);
			registry->AddSystem<PrefabSyncSystem>(*registry, *prefabManager);
			registry->AddSystem<AnimationSystem>();
			loadingScreen->Update(0.5f);
			loadingScreen->Render();

			// Initialize scripting (70%)
			registry->AddSystem<LogicSystem>(*registry, *eventBus, *layerManager, *monoAPI);
			registry->AddSystem<TransformationSystem>();
			registry->AddSystem<RenderSystem>(window, *layerManager, *cameraManager);
			registry->AddSystem<ParticleSystem>(*registry);
			registry->AddSystem<HierarchySystem>();
			registry->AddSystem<RuntimeSystem>(*registry, *eventBus, *monoAPI);
			registry->AddSystem<SceneManageSystem>(*this, *registry, *serializer, *monoAPI, *cameraManager);
			registry->AddSystem<QueueSystem>();
			registry->AddSystem<UISystem>(*cameraManager, *registry, window);
			loadingScreen->Update(0.7f);
			loadingScreen->Render();

			// Initialize subsystems (80%)
			registry->GetSystem<RenderSystem>().Initialize();
			registry->GetSystem<LogicSystem>().Initialization();
			registry->GetSystem<UISystem>().Initialize();
			loadingScreen->Update(0.8f);
			loadingScreen->Render();

			// Setup scripting and assets (90%)
			PopplioScriptAPI::SetIntCall(*registry, *layerManager, *eventBus, *prefabManager, *cameraManager);
			AssetLoader::Setup(registry->GetSystem<AudioSystem>(), registry->GetSystem<LogicSystem>());
			AssetLoader::ReloadAssets();

			loadingScreen->SetFirstSplashTexture("DigiPen_BLACK");
			loadingScreen->SetSecondSplashTexture("Popplio_TeamLogo");

			loadingScreen->Update(0.9f);
			loadingScreen->Render();

			// Load editor or game scene (100%)
#ifndef IMGUI_DISABLE
			registry->AddSystem<Editor>(window, *registry, *serializer, *eventBus, *prefabManager, *layerManager, *cameraManager, *monoAPI);
			auto& editor = registry->GetSystem<Editor>();
			editor.Init();
			editor.LoadScene(Config::lastScene);
			registry->GetSystem<AnimationSystem>().StopAll();
#else
			serializer->LoadSceneFromFile(Config::startScene, *cameraManager);
			monoAPI->ReloadAssembly();
			GameSetup();
			GameInit();
#endif

			// Setup event subscriptions
			registry->GetSystem<CloneSystem>().SubscribeToEvents(*eventBus);
			registry->GetSystem<PrefabSyncSystem>().SubscribeToEvents(*eventBus);
			registry->GetSystem<AudioSystem>().SubscribeToEvents(*eventBus);

			// Final update at 100%
			loadingScreen->Update(1.0f);
			loadingScreen->Render();
		});

		// Set fullscreen by default for game build
#ifdef IMGUI_DISABLE
		SetFullScreen();
		fullscreen = true;
#endif

		// Wait for the splash screen to complete if it's active
		while (!loadingScreen->IsComplete()) {
			glfwPollEvents();
			loadingScreen->Render();

			// This gives a small delay to avoid maxing out the CPU
			std::this_thread::sleep_for(std::chrono::milliseconds(16)); // ~60 FPS
		}

		// Clean up loading screen resources
		loadingScreen.reset();


		Logger::Info("Engine initialization completed", LogDestination::WINDOWS_CONSOLE);
	}

	void Engine::Run()
	{
		Logger::Info("Engine loop started", LogDestination::WINDOWS_CONSOLE);

		while (!glfwWindowShouldClose(window))
		{
			// update delta time and fps
			Popplio::PerformanceViewer::GetInstance()->start(PerformanceViewer::_MainEngine);
			timer.Update(framesPerSecond, 1.f);
			Popplio::PerformanceViewer::GetInstance()->start("total input");
			ProcessInput();
			Popplio::PerformanceViewer::GetInstance()->end("total input");
			Popplio::PerformanceViewer::GetInstance()->start("total update");
			Update();
			Popplio::PerformanceViewer::GetInstance()->end("total update");
			Popplio::PerformanceViewer::GetInstance()->start("total render");
			Render();
			Popplio::PerformanceViewer::GetInstance()->end("total render");
			Popplio::PerformanceViewer::GetInstance()->end(PerformanceViewer::_MainEngine);
		}

//#ifndef IMGUI_DISABLE
//		if (registry->GetSystem<Editor>().HasUnsavedChanges())
//		{
//            registry->GetSystem<Editor>().UnsavedPopup();
//		}
//#endif // !IMGUI_DISABLE

		eventBus->EmitEvent<PopplioUtil::OnAppQuit>();

		Logger::Info("Engine loop ended", LogDestination::WINDOWS_CONSOLE);
	}

//	void Engine::Setup()
//	{
//		// Add systems
//		loadingScreen->SetMessage("Initializing Systems...");
//		registry->AddSystem<MovementSystem>(); // translation
//		registry->AddSystem<AudioSystem>(*registry);
//		loadingScreen->CompleteStep("Audio System");
//
//		registry->AddSystem<CollisionSystem>(*eventBus, *layerManager);
//		registry->AddSystem<GravitySystem>(); // rigidbody
//		loadingScreen->CompleteStep("Physics");
//
//		registry->AddSystem<CloneSystem>(*registry, *layerManager);
//		registry->AddSystem<PrefabSyncSystem>(*registry, *prefabManager);
//		registry->AddSystem<AnimationSystem>();
//
//		loadingScreen->SetMessage("Loading Scripts...");
//		registry->AddSystem<LogicSystem>(*registry, *eventBus, *layerManager, *monoAPI); // logic system (scripts)
//		loadingScreen->CompleteStep("Scripts");
//		
//		registry->AddSystem<TransformationSystem>(); // transformation system
//		registry->AddSystem<RenderSystem>(window, *layerManager, *cameraManager); // sprites
//		registry->AddSystem<ParticleSystem>(*registry);
//		loadingScreen->CompleteStep("Graphics");
//
//		registry->AddSystem<HierarchySystem>();
//		registry->AddSystem<RuntimeSystem>(*registry, *eventBus, *monoAPI);
//        registry->AddSystem<SceneManageSystem>(*this, *registry, *serializer, *monoAPI, *cameraManager);
//		registry->AddSystem<QueueSystem>();
//		registry->AddSystem<UISystem>(*cameraManager, *registry,window);
//
//		// Initialize systems
//		loadingScreen->SetMessage("Initializing Renderer...");
//		registry->GetSystem<RenderSystem>().Initialize();
//		registry->GetSystem<LogicSystem>().Initialization();
//		registry->GetSystem<UISystem>().Initialize();
//
//		//get reference to systems
//		//MovementSystem& movementSystem = registry->GetSystem<MovementSystem>();
//		//ParticleSystem& particleSystem = registry->GetSystem<ParticleSystem>();
//
//		//connect movement system to particle system
//		//particleSystem.SetMovementSystem(&movementSystem);
//
//
//		// Mono
//		loadingScreen->SetMessage("Setting up scripting system...");
//		PopplioScriptAPI::SetIntCall(*registry, *layerManager, *eventBus, *prefabManager, *cameraManager); // set up internal call code
//
//		AssetLoader::Setup(registry->GetSystem<AudioSystem>(), registry->GetSystem<LogicSystem>());
//		
//		loadingScreen->SetMessage("Loading assets...");
//		AssetLoader::ReloadAssets();
//
//
//#ifndef IMGUI_DISABLE
//		registry->AddSystem<Editor>(window, *registry, *serializer, *eventBus, *prefabManager, *layerManager, *cameraManager, *monoAPI); // Editor
//		auto& editor = registry->GetSystem<Editor>();
//		editor.Init();
//		editor.LoadScene(Config::lastScene);
//
//		registry->GetSystem<AnimationSystem>().StopAll();
//#else
//		loadingScreen->SetMessage("Loading scene...");
//		serializer->LoadSceneFromFile(Config::startScene, *cameraManager);
//        monoAPI->ReloadAssembly();
//#endif // !IMGUI_DISABLE
//
//		// Perform the subscription of the events for all systems
//		registry->GetSystem<CloneSystem>().SubscribeToEvents(*eventBus);
//		registry->GetSystem<PrefabSyncSystem>().SubscribeToEvents(*eventBus);
//		registry->GetSystem<AudioSystem>().SubscribeToEvents(*eventBus);
//
//		loadingScreen->CompleteStep("Scene");
//		
//#ifdef IMGUI_DISABLE
//		//monoAPI->ReloadAssembly(); // reload assembly
//		GameSetup();
//		GameInit();
//#endif
//	}

	void Engine::ProcessInput()
	{
		Popplio::PerformanceViewer::GetInstance()->start("input");
		glfwPollEvents();

		// Toggle fullscreen/windowed mode
		if (InputSystem::IsKeyTriggered(GLFW_KEY_F1))
		{
			if (fullscreen)
			{
				SetWindowedMode();
			}
			else
			{
				SetFullScreen();
			}

			fullscreen = !fullscreen;
		}

		// Editor toggle input handling
#ifndef IMGUI_DISABLE
		Popplio::PerformanceViewer::GetInstance()->start("editor input");
        registry->GetSystem<Editor>().ProcessInput();
		Popplio::PerformanceViewer::GetInstance()->end("editor input");

#endif
		registry->GetSystem<UISystem>().ProcessInput();

		InputSystem::Update();
		Popplio::PerformanceViewer::GetInstance()->end("input");
	}

	void Engine::Update()
	{
#ifndef IMGUI_DISABLE
		if (isPaused)
		{
			if (registry->GetSystem<Editor>().editorState == Editor::State::PLAYING)
			{
				registry->GetSystem<Editor>().PauseScene();
			}
		}
		else
		{
			if (registry->GetSystem<Editor>().editorState == Editor::State::PAUSED)
			{
				registry->GetSystem<Editor>().ResumeScene();
			}
		}
#else
		//if (isPaused)
		//{
		//	registry->GetSystem<AudioSystem>().PauseAllAudio();
		//}
		//else
		//{
		//	registry->GetSystem<AudioSystem>().ResumeAllAudio();
		//}
#endif // IMGUI_DISABLE

		
		
		
		// Update the registry to process the entites that are waiting to be created/deleted
		Popplio::PerformanceViewer::GetInstance()->start("registry");
		registry->Update();
		Popplio::PerformanceViewer::GetInstance()->end("registry");

		// Game systems update
		Popplio::PerformanceViewer::GetInstance()->start("prefabs sync");
		registry->GetSystem<PrefabSyncSystem>().Update();
		Popplio::PerformanceViewer::GetInstance()->end("prefabs sync");

#ifndef IMGUI_DISABLE
		auto& editor = registry->GetSystem<Editor>();

		// Get game state from editor
		bool isPlaying = (editor.editorState == Editor::State::PLAYING);

		// Update editor if enabled
		//if (editor.IsEditorEnabled())
		//{
		//	editor.Update();
		//}

		Popplio::PerformanceViewer::GetInstance()->start("editor");
		editor.Update();
		Popplio::PerformanceViewer::GetInstance()->end("editor");

		// Only update game logic if playing
        if (isPlaying)
        {
			Popplio::PerformanceViewer::GetInstance()->start("editor runtime");
            editor.RunUpdate();
            Popplio::PerformanceViewer::GetInstance()->end("editor runtime");
        }
		else
		{
			Popplio::PerformanceViewer::GetInstance()->start("transformation");
			registry->GetSystem<TransformationSystem>().Update();
			Popplio::PerformanceViewer::GetInstance()->end("transformation");

			Popplio::PerformanceViewer::GetInstance()->start("hierarchy");
			registry->GetSystem<HierarchySystem>().Update();
			Popplio::PerformanceViewer::GetInstance()->end("hierarchy");
		}
#else
		if (!isSceneChanging)
		{
			Popplio::PerformanceViewer::GetInstance()->start("runtime");
			GameUpdate();
            Popplio::PerformanceViewer::GetInstance()->end("runtime");
		}
		else
		{
            isSceneChanging = false;
			GameChangeScene();
		}
#endif
	}

	void Engine::Render()
	{
		// Window
		std::stringstream title;

		// Render to FBO
#ifndef IMGUI_DISABLE
		title << "Popplio Engine | FPS: " << framesPerSecond;
		glfwSetWindowTitle(window, title.str().c_str());

		auto& editor = registry->GetSystem<Editor>();

		editor.Render();

		// Update render system
		//PerformanceViewer::GetInstance()->start("rendering");
		//registry->GetSystem<RenderSystem>().Update();
		//PerformanceViewer::GetInstance()->end("rendering");

		//if (!editor.IsEditorEnabled()) editor.RunRender();
#else
		title << "BassNKick";
		glfwSetWindowTitle(window, title.str().c_str());

		// Game-only mode rendering - render directly to screen
		Popplio::PerformanceViewer::GetInstance()->start("runtime render");
		GameRender();
        Popplio::PerformanceViewer::GetInstance()->end("runtime render");
#endif

		// Swap buffers
		glfwSwapBuffers(window);
	}

	// +++++++++++++++++++++++++++++ //

	// Game functions

	// brought from EditorRun.cpp

	void Engine::GameSetup()
	{
		Logger::Info("Running setup...", LogDestination::IMGUI_CONSOLE);

		//registry->GetSystem<QueueSystem>().Clear(); // clear in case loaded from previous scene
		registry->GetSystem<SceneManageSystem>().Init(AssetStore::GetSceneId(Config::startScene));
		registry->GetSystem<AudioSystem>().Setup();
		registry->GetSystem<AudioSystem>().StopAllAudioInst();
		registry->GetSystem<AudioSystem>().StopAllAudio();
		registry->GetSystem<LogicSystem>().Setup();
		//registry->GetSystem<LogicSystem>().SubscribeToEvents(*eventBus);
        registry->GetSystem<AnimationSystem>().StartAll();

		// Initialize UI button actions
		registry->GetSystem<UISystem>().InitializeButtons();

		if (!(registry->GetSystem<QueueSystem>().IsProcessing())) registry->GetSystem<QueueSystem>().Process();
		registry->Update();
	}

	void Engine::GameInit()
	{
		Logger::Info("Initializing...", LogDestination::IMGUI_CONSOLE);
		registry->GetSystem<LogicSystem>().Init();
		//Logger::Info("Done! Game is running", LogDestination::IMGUI_CONSOLE);

		registry->GetSystem<AudioSystem>().Init();

		if (!(registry->GetSystem<QueueSystem>().IsProcessing())) registry->GetSystem<QueueSystem>().Process();

		registry->Update();
		Logger::Info("Done! Scene is running");
	}

	void Engine::GameUpdate() 
	{
		// Fixed Logic updates
		PerformanceViewer::GetInstance()->start("fixed logic");
		registry->GetSystem<LogicSystem>().FixedUpdate();
		PerformanceViewer::GetInstance()->end("fixed logic");

		// Logic updates
		PerformanceViewer::GetInstance()->start("logic");
		registry->GetSystem<LogicSystem>().Update();
		PerformanceViewer::GetInstance()->end("logic");

		// Particle updates
        PerformanceViewer::GetInstance()->start("particles");
        registry->GetSystem<ParticleSystem>().Update(timer.GetFixedDeltaTime());
        PerformanceViewer::GetInstance()->end("particles");

        // Transform updates
		Popplio::PerformanceViewer::GetInstance()->start("transformation");
		registry->GetSystem<TransformationSystem>().Update();
		Popplio::PerformanceViewer::GetInstance()->end("transformation");

		Popplio::PerformanceViewer::GetInstance()->start("hierarchy");
		registry->GetSystem<HierarchySystem>().Update();
		Popplio::PerformanceViewer::GetInstance()->end("hierarchy");

		// Physics updates
		//PerformanceViewer::GetInstance()->start("gravity");
		//registry->GetSystem<GravitySystem>().Update();
		//PerformanceViewer::GetInstance()->end("gravity");

		PerformanceViewer::GetInstance()->start("Movement");
		registry->GetSystem<MovementSystem>().Update(static_cast<float>(timer.GetFixedDeltaTime()));
		PerformanceViewer::GetInstance()->end("Movement");

		// Collision updates
		PerformanceViewer::GetInstance()->start("collision");
		registry->GetSystem<CollisionSystem>().Update(*registry, static_cast<float>(timer.GetFixedDeltaTime()));
		PerformanceViewer::GetInstance()->end("collision");

		// resolve queue
		PerformanceViewer::GetInstance()->start("queue");
		if (!(registry->GetSystem<QueueSystem>().IsProcessing())) registry->GetSystem<QueueSystem>().Process();
		PerformanceViewer::GetInstance()->end("queue");

		// UI
		PerformanceViewer::GetInstance()->start("ui");
		registry->GetSystem<UISystem>().Update();
		PerformanceViewer::GetInstance()->end("ui");
	}

	//void Engine::GameFixedUpdate() // todo: implement
	//{
	//	// Logic updates
	//	PerformanceViewer::GetInstance()->start("fixed logic");
	//	registry->GetSystem<LogicSystem>().FixedUpdate();
	//	PerformanceViewer::GetInstance()->end("fixed logic");

	//	// Transform updates
	//	Popplio::PerformanceViewer::GetInstance()->start("fixed transformation");
	//	registry->GetSystem<TransformationSystem>().Update();
	//	Popplio::PerformanceViewer::GetInstance()->end("fixed transformation");

	//	Popplio::PerformanceViewer::GetInstance()->start("fixed hierarchy");
	//	registry->GetSystem<HierarchySystem>().Update();
	//	Popplio::PerformanceViewer::GetInstance()->end("fixed hierarchy");

	//	// Physics updates
	//	PerformanceViewer::GetInstance()->start("fixed gravity");
	//	registry->GetSystem<GravitySystem>().Update();
	//	PerformanceViewer::GetInstance()->end("fixed gravity");

	//	PerformanceViewer::GetInstance()->start("fixed Movement");
	//	registry->GetSystem<MovementSystem>().Update(static_cast<float>(timer.GetFixedDeltaTime()));
	//	PerformanceViewer::GetInstance()->end("fixed Movement");

	//	// Collision updates
	//	PerformanceViewer::GetInstance()->start("fixed collision");
	//	registry->GetSystem<CollisionSystem>().Update(*registry, static_cast<float>(timer.GetFixedDeltaTime()));
	//	PerformanceViewer::GetInstance()->end("fixed collision");

	//	PerformanceViewer::GetInstance()->start("queue");
	//	if (!(registry->GetSystem<QueueSystem>().IsProcessing())) registry->GetSystem<QueueSystem>().Process();
	//	PerformanceViewer::GetInstance()->end("queue");
	//}

	void Engine::GameRender()
	{
		// Bind to default framebuffer (screen)
		glBindFramebuffer(GL_FRAMEBUFFER, 0);
		glViewport(0, 0, Config::windowWidth, Config::windowHeight);

		// Update render system
		PerformanceViewer::GetInstance()->start("rendering");
		registry->GetSystem<RenderSystem>().Update();
		PerformanceViewer::GetInstance()->end("rendering");

		// Animation update
		PerformanceViewer::GetInstance()->start("animation");
		registry->GetSystem<AnimationSystem>().Update(static_cast<float>(timer.GetFixedDeltaTime()));
		PerformanceViewer::GetInstance()->end("animation");

		// Particle update
		PerformanceViewer::GetInstance()->start("particles");
		registry->GetSystem<ParticleSystem>().Update(timer.GetFixedDeltaTime());
		PerformanceViewer::GetInstance()->end("particles");

        // Audio update
		PerformanceViewer::GetInstance()->start("audio");
		registry->GetSystem<AudioSystem>().Update();
		PerformanceViewer::GetInstance()->end("audio");
	}

	void Engine::GameEnd()
	{
		registry->GetSystem<AudioSystem>().End();
		registry->GetSystem<LogicSystem>().End();

		if (!(registry->GetSystem<QueueSystem>().IsProcessing())) registry->GetSystem<QueueSystem>().Process();

		registry->Update();
	}

	void Engine::GameChangeScene()
	{
		//if (!isSceneChanging)
		//{
  //          isSceneChanging = true;
		//	return;
		//}

		if (isSceneChanging)
		{
			Logger::Info("Changing scene...");
			GameEnd();

			// TODO clear instanced entities except persistent ones
			registry->ClearInstancedEntities();
		}
		else
		{
			//monoAPI->ReloadAssembly();

			// new scene setup
			registry->GetSystem<LogicSystem>().Setup();
			registry->GetSystem<AnimationSystem>().StartAll();
            registry->GetSystem<QueueSystem>().Process();
			registry->Update();

			registry->GetSystem<LogicSystem>().Init();
			registry->GetSystem<AudioSystem>().Init();
			registry->GetSystem<QueueSystem>().Process();
			registry->Update();
		}

        //isSceneChanging = false;
	}

	// +++++++++++++++++++++++++++++ //

	void Engine::Destroy()
	{
#ifndef IMGUI_DISABLE
		registry->GetSystem<Editor>().Terminate();
#else
        GameEnd();
#endif // IMGUI_DISABLE
		AssetStore::Clear();
		registry->GetSystem<AudioSystem>().Terminate();
		PerformanceViewer::DestroyInstance();
		UnhookWindowsHookEx(keyboardHook);
		glfwDestroyWindow(window);
		glfwTerminate();
	}
}

================
File: Engine/Engine.h
================
/******************************************************************************/
/*!
\file   Engine.h
\author Team Popplio
\author Bryan Ang Wei Ze
\co-author	Ng Jun Heng Shawn | Shannon | Hafawati Binte Mohd Ali
\contribution Bryan - 70%, Shawn - 15%, Shannon - 5%, Hafawati - 10%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/11/30 
\brief
    This is the header file for the core of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include "../ECS/ECS.h"
#include "../Serialization/Serialization.h"
#include "../EventBus/EventBus.h"
#include "../Utilities/UtilLib.h"
#include "../Physics/Physics.h"
#include "../Logging/Logger.h"
#include "../PrefabManagement/PrefabManager.h"
#include "../Layering/LayerManager.h"
#include "../Camera/CameraManager.h"
#include "../LoadingScreen/LoadingScreen.h"
#include <glad/glad.h>
#include <GLFW/glfw3.h>

// ScriptAPI
#include "../Mono/MonoAPI.h"

namespace Popplio
{
    /**
     * @struct GLFWwindowDeleter
     * @brief A custom deleter for GLFWwindow pointers.
     * 
     * This struct provides a custom deleter for GLFWwindow pointers. It is used to automatically destroy GLFW windows when they are no longer needed.
     */
	//struct GLFWwindowDeleter
	//{
 //       /**
 //        * @brief Operator function for deleting a GLFWwindow.
 //        * 
 //        * This operator function is called when a GLFWwindow pointer needs to be deleted. It destroys the GLFW window using glfwDestroyWindow().
 //        * 
 //        * @param window The GLFWwindow pointer to be deleted.
 //        */
	//	void operator()(GLFWwindow* window)
	//	{
	//		glfwDestroyWindow(window);
	//	}
	//};

    /**
     * @class Engine
     * @brief Represents an engine instance.
     * 
     * The Engine class is responsible for managing the game loop and handling various game-related operations such as initialization, updating, rendering, and audio playback.
     */
	class Engine
	{
	public:
        /**
         * @brief Default constructor for the Engine class.
         */
		Engine();

        /**
         * @brief Initializes the program.
         * 
         * This function initializes the game by creating the program window, setting up the ECS registry, event bus, serializer, and other necessary components.
         */
		void Initialize();

        /**
         * @brief Performs the initial setup for the program.
         * 
         * This function performs the initial setup for the program, such as loading assets, setting up the game scene, and initializing any required systems.
         */
		//void Setup();

        /**
         * @brief Runs the program loop.
         * 
         * This function runs the main program loop, which includes processing input, updating game logic, rendering the game scene, and playing audio.
         */
		void Run();

        /**
         * @brief Processes user input.
         * 
         * This function processes user input, such as keyboard and mouse events, and updates the game state accordingly.
         */
		void ProcessInput();

        /**
         * @brief Updates the program logic.
         * 
         * This function updates the program logic, such as updating entity positions, handling collisions, and executing game events.
         */
		void Update();

        /**
         * @brief Renders the program.
         * 
         * This function renders the program and scene, including all entities, sprites, and other visual elements.
         */
		void Render();

        /**
         * @brief Game loop for the program.
         */

        void GameSetup();
        void GameInit();
        void GameUpdate();
        //void GameFixedUpdate();
        void GameRender();
        void GameEnd();
        void GameChangeScene();

        /**
         * @brief Destroys the program.
         * 
         * This function destroys the game by cleaning up any allocated resources and shutting down the game engine.
         */
		void Destroy();

        /**
         * @brief Sets the window to fullscreen mode.
         *
         * This function sets the window to fullscreen mode from windowed mode.
         */
        void SetFullScreen();

        /**
         * @brief Sets the window to windowed mode.
         *
         * This function sets the window to windowed mode from fullscreen mode.
         */
        void SetWindowedMode();

        // ++++++++++++++++++++++++++++++++ //

        // Configuration

        struct Config
        {
            // Version // ========================

            /**
             * @brief engine version. v0.milestone.week | date
             */
            static std::string engineVer;

            /**
             * @brief app version. v0.milestone.week | date
             */
            static std::string appVer;

            // Program settings // ========================

            /**
             * @brief The width of the program window.
             */
            static int windowWidth;

            /**
             * @brief The height of the program window.
             */
            static int windowHeight;

            /**
             * @brief Flag indicating whether vertical sync is enabled.
             */
            static bool vSync;

            // Editor // ========================

            /**
             * @brief Flag indicating if safe mode is enabled.
             */
            static bool safeMode;

            /**
             * @brief Scene to load in editor upon program start.
             */
            static std::string lastScene;

            /**
             * @brief Flag indicating if verbose logging is enabled (only to relevant systems).
             */
            static bool verbose;

            // Build settings // ========================

            /**
             * @brief Start scene to load in build.
             */
            static std::string startScene;
        };

        //static Config config;

        // ++++++++++++++++++++++++++++++++ //

        /**
         * @brief The timer used for measuring frame time and calculating frames per second.
         */
		static PopplioUtil::Timer timer;

        /**
         * @brief The current frames per second (FPS) of the game.
         */
		static double framesPerSecond;

        /**
         * @brief Flag indicating whether game is paused.
         */
        static bool isPaused;

        /**
         * @brief Flag indicating whether windows is in fullscreen mode.
         */
        static bool fullscreen;

        static PopplioPhysics::Gravity gravity;

        static bool isSceneChanging;

        static std::string programPath;

	private:
        GLFWwindow* window; /**< The GLFW window used for rendering. */
        std::unique_ptr<Registry> registry; /**< The ECS registry for managing entities and components. */
        std::unique_ptr<EventBus> eventBus; /**< The event bus for handling game events. */
        std::unique_ptr<PrefabManager> prefabManager; /**< The prefab manager for managing prefabs. */
        std::unique_ptr<LayerManager> layerManager; /**< The layer manager for managing entity layers. */
        std::unique_ptr<CameraManager> cameraManager; /**< The camera manager for managing cameras. */
        std::unique_ptr<Serializer> serializer; /**< The serializer for saving and loading game data. */
        std::unique_ptr<LoadingScreen> loadingScreen;
        std::unique_ptr<PopplioScriptAPI::MonoAPI> monoAPI; /**< The Mono API for interacting with C# scripts. */
    };
}

================
File: EventBus/Event.h
================
/******************************************************************************/
/*!
\file   Event.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/10/02
\brief
		This is the header file for the base class of all events in the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once

namespace Popplio
{
	/*
		Event
		A base class that all types of events will inherit from, allowing for storage in a uniform way
	*/
	class Event
	{
	public:
		Event() = default;

	private:
	};
}

================
File: EventBus/EventBus.h
================
/******************************************************************************/
/*!
\file   EventBus.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/10/02
\brief
        This is the header file for the Events System of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include "Event.h"
#include "../Logging/Logger.h"
#include <map>
#include <typeindex>
#include <memory>
#include <list>
#include <functional>

namespace Popplio
{
	
    /**
     * @brief Interface for event callback classes.
     * 
     * This interface defines the contract for event callback classes.
     * Any class implementing this interface must provide an implementation
     * for the Call() method, which is responsible for invoking the event callback function.
     */
    class IEventCallback
    {
    public:
        /**
         * @brief Destructor for IEventCallback.
         */
        virtual ~IEventCallback() = default;

        /**
         * @brief Call the event callback function.
         * 
         * @param e The event object.
         */
        virtual void Call(Event& e) = 0;
    };

    /**
     * @brief Represents a callback for a member function event.
     * 
     * This class is responsible for invoking a member function callback when an event is triggered.
     * It inherits from the IEventCallback interface and provides an implementation for the Call() method.
     * 
     * @tparam TOwner The owner class type.
     * @tparam TEvent The event type.
     */
    template <typename TOwner, typename TEvent>
    class MemberFunctionEventCallback : public IEventCallback
    {
    public:
        using CallbackFunction = void (TOwner::*)(TEvent&); /**< The type of the member function callback. */
        /**
         * @brief Constructor for MemberFunctionEventCallback.
         * 
         * @param owner The owner instance.
         * @param callback The member function callback.
         */
        MemberFunctionEventCallback(TOwner* owner, CallbackFunction callback)
            : ownerInstance(owner), callbackFunction(callback) {}

        /**
         * @brief Call the member function callback.
         * 
         * @param e The event object.
         */
        void Call(Event& e) override
        {
            std::invoke(callbackFunction, ownerInstance, static_cast<TEvent&>(e));
        }

    private:
        
        TOwner* ownerInstance; /**< The owner instance. */
        CallbackFunction callbackFunction; /**< The member function callback. */
    };

    /**
     * @brief Represents a callback for a function event.
     * 
     * This class is responsible for invoking a function callback when an event is triggered.
     * It inherits from the IEventCallback interface and provides an implementation for the Call() method.
     * 
     * @tparam TEvent The event type.
     */
    template <typename TEvent>
    class FunctionEventCallback : public IEventCallback
    {
    public:
        /**
         * @brief Constructor for FunctionEventCallback.
         * 
         * @param callback The function callback.
         */
        FunctionEventCallback(std::function<void(TEvent&)> callback)
            : callbackFunction(callback) {}

        /**
         * @brief Call the function callback.
         * 
         * @param e The event object.
         */
        void Call(Event& e) override
        {
            callbackFunction(static_cast<TEvent&>(e));
        }

    private:
        std::function<void(TEvent&)> callbackFunction; /**< The function callback. */
    };

    class EventBus
    {
    public:
        /**
         * @brief Resets the event bus by clearing all subscribers.
         */
        void Reset()
        {
            subscribers.clear();
        }

        /**
         * @brief Subscribes an owner instance to an event with a member function callback.
         * 
         * @tparam TEvent The event type.
         * @tparam TOwner The owner class type.
         * @param ownerInstance The owner instance.
         * @param callbackFunction The member function callback.
         */
        template <typename TEvent, typename TOwner>
        void SubscribeToEvent(TOwner* ownerInstance, void (TOwner::* callbackFunction)(TEvent&))
        {
            subscribers[typeid(TEvent)].push_back(
                std::make_shared<MemberFunctionEventCallback<TOwner, TEvent>>
                (ownerInstance, callbackFunction)
            );
        }

        /**
         * @brief Subscribes a function callback to an event.
         * 
         * @tparam TEvent The event type.
         * @param callback The function callback.
         */
        template <typename TEvent>
        void SubscribeToEvent(std::function<void(TEvent&)> callback)
        {
            subscribers[typeid(TEvent)].push_back(
                std::make_shared<FunctionEventCallback<TEvent>>(callback)
            );
        }

        /**
         * @brief Emits an event by invoking all subscribed event handlers.
         * 
         * @tparam TEvent The event type.
         * @tparam TArgs The argument types.
         * @param args The arguments to construct the event object.
         */
        template <typename TEvent, typename ...TArgs>
        void EmitEvent(TArgs&& ...args)
        {
            auto handlers = subscribers[typeid(TEvent)];
            if (!handlers.empty())
            {
                TEvent event(std::forward<TArgs>(args)...);
                for (auto& handler : handlers)
                {
                    handler->Call(event);
                }
            }
        }

        /**
         * @brief Unsubscribes an owner instance to an event with a member function callback.
         *
         * @tparam TEvent The event type.
         * @tparam TOwner The owner class type.
         * @param ownerInstance The owner instance.
         * @param callbackFunction The member function callback.
         */
        template <typename TEvent, typename TOwner>
        void UnsubscribeToEvent(TOwner* ownerInstance, void (TOwner::* callbackFunction)(TEvent&)) // TODO IMPLEMENT
        {
            //subscribers[typeid(TEvent)].erase(
            //    MemberFunctionEventCallback<TOwner, TEvent>
            //    (ownerInstance, callbackFunction)
            //);
        }

        /**
         * @brief Unsubscribes a function callback to an event.
         *
         * @tparam TEvent The event type.
         * @param callback The function callback.
         */
        template <typename TEvent>
        void UnsubscribeToEvent(std::function<void(TEvent&)> callback) // TODO IMPLEMENT
        {
            //subscribers[typeid(TEvent)].erase(
            //    FunctionEventCallback<TEvent>(callback)
            //);
        }

    private:
        std::map<std::type_index, std::list<std::shared_ptr<IEventCallback>>> subscribers; /**< The map of event subscribers. */
    };
}

================
File: Hierarchy/HierarchySystem.cpp
================
/******************************************************************************/
/*!
\file   HierarchySystem.cpp
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief
This file contains the implementation of the HierarchySystem class, which is 
responsible for managing the hierarchical relationships between entities in the 
game engine. It ensures that parent-child relationships are maintained and that 
transformations are correctly propagated through the hierarchy.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>
#include "HierarchySystem.h"

namespace Popplio
{
	HierarchySystem::HierarchySystem()
	{
		RequireComponent<ParentComponent>();
		RequireComponent<TransformComponent>();
		RequireComponent<ActiveComponent>();
	}

	void HierarchySystem::Update()
	{
		for (auto entity : GetSystemEntities())
        {
            if (!entity.Exists()) continue;
            if (!entity.HasComponent<TransformComponent>() || !entity.HasComponent<ActiveComponent>()) 
                continue;
            if (!entity.HasComponent<ParentComponent>()) continue;
			auto& parentComp = entity.GetComponent<ParentComponent>();

			// Skip if this is a child being processed (to avoid double processing)
			if (parentComp.parent.GetId() != -1)
            {
				continue;
			}

            entity.GetComponent<ParentComponent>().SetLocalToWorld(entity.GetComponent<TransformComponent>());

			// Process entire hierarchy starting from root
			UpdateHierarchy(entity);
		}
	}

	void HierarchySystem::UpdateHierarchy(Entity& entity)
	{
        if (!entity.HasComponent<ParentComponent>())
            return;

        auto& parentComp = entity.GetComponent<ParentComponent>();
        auto& parentTransform = entity.GetComponent<TransformComponent>();

        // Update children with deltas
        for (auto child : parentComp.children)
        {
            if (!child.HasComponent<TransformComponent>() ||
                !child.HasComponent<ActiveComponent>())
                continue;

            //if (!child.GetComponent<ParentComponent>().IsModified())
            //    child.GetComponent<ParentComponent>().UpdateLocalTransform(
            //        child.GetComponent<TransformComponent>(), parentTransform);

            // Handle active state inheritance
            //if (parentComp.inheritActive)
            if (child.GetComponent<ParentComponent>().inheritActive)
            {
                auto& parentActive = entity.GetComponent<ActiveComponent>();
                auto& childActive = child.GetComponent<ActiveComponent>();
                childActive.isActive = parentActive.isActive;
            }

            // Handle transform inheritance
            //if (parentComp.inheritTransform)
            auto& childTransform = child.GetComponent<TransformComponent>();
            auto& childParentComp = child.GetComponent<ParentComponent>();

            if (child.GetComponent<ParentComponent>().inheritTransform)
            {
                //if (child.GetComponent<ParentComponent>().IsModified()) 
                //    childParentComp.SyncLocalToWorld(childTransform, parentTransform);
                //else
                
                //if (childParentComp.localModified)
                //{
                //    //childParentComp.UpdateLocalTransform(childTransform, parentTransform);
                //    childParentComp.localModified = false;
                //}

                //if (childParentComp.WorldIsModified(childTransform)) 
                //    childParentComp.SyncLocalToWorld(childTransform, parentTransform);

                // Update world transform based on local transform and parent's transform
                childParentComp.UpdateWorldTransform(childTransform, parentTransform);
            }
            else childParentComp.SyncLocalToWorld(childTransform, parentTransform);

            // Recursively update children
            UpdateHierarchy(child);
        }
	}

    void HierarchySystem::InitializeParentTransform(Entity parent)
    {
        if (parent.HasComponent<TransformComponent>())
        {
            //for (auto& [id, transform] : lastParentTransforms)
            //{
            //    if (id == parent.GetId()) return;
            //}
            lastParentTransforms[parent.GetId()] = parent.GetComponent<TransformComponent>();
        }
    }

    void HierarchySystem::StopParentTransform(Entity parent)
    {
        if (parent.HasComponent<TransformComponent>())
        {
            for (auto& [id, transform] : lastParentTransforms)
            {
                if (id == parent.GetId())
                {
                    lastParentTransforms.erase(parent.GetId());
                    break;
                }
            }
        }
    }

    std::vector<Entity> HierarchySystem::GetChildRecursive(Entity const parent)
    {
        if (!parent.HasComponent<ParentComponent>()) return std::vector<Entity>();
        std::vector<Entity>temp{};
        return GetChildRecursion(parent, temp);
    }

    Entity HierarchySystem::GetChildRecursive(Entity const parent, Entity child)
    {
        //if (child == parent) return child; // untested
        if (!parent.HasComponent<ParentComponent>()) return Entity(-1);

        std::vector<Entity> children = GetChildRecursive(parent);

        for (auto& c : children)
        {
            if (c.GetId() == child.GetId()) return c;
        }
        return Entity(-1);
    }

    void HierarchySystem::AddChild(Entity parent, Entity child)
    {
        if (!parent.HasComponent<ParentComponent>())
        {
            //return;
            parent.AddComponent<ParentComponent>();
        }

        if (!child.HasComponent<ParentComponent>())
        {
            child.AddComponent<ParentComponent>();
        }

        // Get the current world transform of the child before changing hierarchy
        auto& childTransform = child.GetComponent<TransformComponent>();
        //auto& parentTransform = parent.GetComponent<TransformComponent>();

        Entity childExistingParent = child.GetComponent<Popplio::ParentComponent>().parent;
        if (childExistingParent.Exists())
            childExistingParent.GetComponent<Popplio::ParentComponent>().RemoveChild(child);

        // Add child to parent's list
        parent.GetComponent<ParentComponent>().AddChild(child, parent);

        // Add or update ParentComponent on child
        //if (!child.HasComponent<ParentComponent>())
        //{
        //    child.AddComponent<ParentComponent>(parent);
        //}
        //else
        //{
        //    child.GetComponent<ParentComponent>().parent = parent;
        //}

        child.GetComponent<ParentComponent>().parent = parent;

        //child.GetComponent<ParentComponent>().InitLocalTransform(childTransform);

        // Calculate and set local transform for the child
        //child.GetComponent<ParentComponent>().UpdateLocalTransform(childTransform, parentTransform);
        child.GetComponent<ParentComponent>().SetLocalToWorld(childTransform);

        InitializeParentTransform(parent);
    }

    void HierarchySystem::RemoveChild(Entity parent, Entity child)
    {
        if (!parent.HasComponent<ParentComponent>())
            return;

        // Before removing, calculate the final world transform
        auto& childTransform = child.GetComponent<TransformComponent>();
        //auto& parentTransform = parent.GetComponent<TransformComponent>();
        auto& childParentComp = child.GetComponent<ParentComponent>();

        // Store the current world transform
        PopplioMath::Vec2f worldPos = childTransform.position;
        PopplioMath::Vec2f worldScale = childTransform.scale;
        double worldRotation = childTransform.rotation;

        // Remove child from parent
        parent.GetComponent<ParentComponent>().RemoveChild(child);

        // Set the child's transform to its world transform
        childTransform.position = worldPos;
        childTransform.scale = worldScale;
        childTransform.rotation = worldRotation;

        // Reset the child's local transform
        childParentComp.localPosition = { 0.0f, 0.0f };
        childParentComp.localScale = { 1.0f, 1.0f };
        childParentComp.localRotation = 0.0;
    }

    std::vector<Entity>& HierarchySystem::GetChildRecursion(Entity const parent, std::vector<Entity>& ents)
    {
        auto& parentComp = parent.GetComponent<ParentComponent>();
        for (auto c : parentComp.children)
        {
            ents.push_back(c);
            if (c.GetComponent<ParentComponent>().children.size() > 0)
            {
                ents = GetChildRecursion(c, ents);
            }
        }
        return ents;
    }

    //void HierarchySystem::SetChildParentIdRecursive(Entity e, Entity o)
    //{
    //    auto child = e.GetComponent<ParentComponent>().children.begin();
    //    auto originalChild = o.GetComponent<ParentComponent>().children.begin();

    //    while (child != e.GetComponent<ParentComponent>().children.end() &&
    //        originalChild != o.GetComponent<ParentComponent>().children.end())
    //    {
    //        child->SetClonedFrom(originalChild->GetId());

    //        child.GetComponent<ParentComponent>().parent = e;

    //        if (!GetChildRecursive(e, child).Exists()) e.GetComponent<ParentComponent>().AddChild(child);

    //        if (child.GetComponent<ParentComponent>().children.size() > 0)
    //        {
    //            SetChildParentIdRecursive(child, originalChild);
    //        }
    //    }

    //    //for (size_t i{}; i < e.GetComponent<ParentComponent>().children.size(); ++i)
    //    //{
    //    //    auto& child = e.GetComponent<ParentComponent>().children[i];
    //    //    auto& originalChild = o.GetComponent<ParentComponent>().children[i];

    //    //    child.SetClonedFrom(originalChild.GetId());

    //    //    child.GetComponent<ParentComponent>().parent = e;

    //    //    if (!GetChildRecursive(e, child).Exists()) e.GetComponent<ParentComponent>().AddChild(child);

    //    //    if (child.GetComponent<ParentComponent>().children.size() > 0)
    //    //    {
    //    //        SetChildParentIdRecursive(child, originalChild);
    //    //    }
    //    //}
    //}

    //void HierarchySystem::CloneSecondPass(Entity newEnt, Entity original)
    //{
    //    SetChildParentIdRecursive(newEnt, original);
    //}
}

================
File: Hierarchy/HierarchySystem.h
================
/******************************************************************************/
/*!
\file   HierarchySystem.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief
This file contains the interface of the HierarchySystem class, which is
responsible for managing the hierarchical relationships between entities in the
game engine. It ensures that parent-child relationships are maintained and that
transformations are correctly propagated through the hierarchy.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include "../ECS/ECS.h"
#include "ParentComponent.h"

namespace Popplio
{
	class HierarchySystem : public System
	{
	public:
		HierarchySystem();

		void Update();

		// Call this when a new parent-child relationship is established
		void InitializeParentTransform(Entity parent);

		void StopParentTransform(Entity parent);

		std::vector<Entity> GetChildRecursive(Entity const parent);
		Entity GetChildRecursive(Entity const parent, Entity child);

		void AddChild(Entity e, Entity child);

		void RemoveChild(Entity e, Entity child);

		void SetChildParentIdRecursive(Entity e, Entity o);

		void CloneSecondPass(Entity newEnt, Entity original);

	private:
		std::unordered_map<int, TransformComponent> lastParentTransforms;

		void UpdateHierarchy(Entity& entity);

		std::vector<Entity>& GetChildRecursion(Entity const parent, std::vector<Entity>& ents);
	};
}

================
File: Hierarchy/ParentComponent.h
================
/******************************************************************************/
/*!
\file   ParentComponent.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 70%, Shawn - 30%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief  This file contains the definition of the ParentComponent class, which is 
        used to manage parent-child relationships between entities in the ECS 
        system. It includes methods for adding and removing child entities, 
        updating local and world transforms, and synchronizing transformations 
        between parent and child entities.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include <vector>
#include "../ECS/ECS.h"
#include "../Math/MathLib.h"

namespace Popplio
{
	class ParentComponent
	{
		public:

		Entity parent{ -1 };
		std::vector<Entity> children{};
		bool inheritActive = true;
		bool inheritTransform = true;

		// Local transform data
		PopplioMath::Vec2f localPosition{ 0.0f, 0.0f };
		PopplioMath::Vec2f localScale{ 1.0f, 1.0f };
		double localRotation = 0.0;

		// do not serialize

		PopplioMath::Vec2f prevLocalPosition{ 0.0f, 0.0f };
		PopplioMath::Vec2f prevLocalScale{ 1.0f, 1.0f };
		double prevLocalRotation = 0.0;

		PopplioMath::Vec2f prevWorldPosition{ 0.0f, 0.0f };
		PopplioMath::Vec2f prevWorldScale{ 1.0f, 1.0f };
		double prevWorldRotation = 0.0;

		bool localModified = false;

		ParentComponent() = default;

		//ParentComponent()
		//{
  //          children = std::vector<Entity>();
		//	children.clear();
  //          children.reserve(100);
		//	children.push_back(Entity(-1));
		//}

		ParentComponent(Entity parentEntity, bool inheritActiveState = true, bool inheritTransformState = true)
			: parent(parentEntity)
			, inheritActive(inheritActiveState)
			, inheritTransform(inheritTransformState)
		{ 
			//children = std::vector<Entity>();
			//children.clear();
			//children.reserve(100);
			//children.push_back(Entity(-1));
		}

   //     void CloneFrom(const Entity& ent, const Entity& other)
   //     {
			////if (other.GetComponent<ParentComponent>().children.empty()) return;

			////if (children.size() != other.GetComponent<ParentComponent>().children.size()) return;

			//////if (parent.Exists()) parent.GetComponent<ParentComponent>().RemoveChild(ent);

			//////for (auto& child : other.GetComponent<ParentComponent>().children)
			//////{
   //////             Entity e = child.Clone();
			//////	AddChild(e);

			//////	e.GetComponent<ParentComponent>().CloneFrom(e, child);
			//////}

			////// TODO fix
			////for (size_t i{}; i < other.GetComponent<ParentComponent>().children.size(); ++i)
			////{
			////	Entity e = children[i];
   ////             other.GetComponent<ParentComponent>().RemoveChild(e);
			////	AddChild(e);
			////}

   //         if (other.GetComponent<ParentComponent>().parent == -1) return;
			//other.GetComponent<ParentComponent>().parent.GetComponent<ParentComponent>().RemoveChild(ent);
			//AddChild(ent);
   //     }
	
		void AddChild(Entity childEntity, Entity thisEntity)//, bool const& preserveTransform = true)
		{
			if (!childEntity.Exists()) return;

			if (std::find(children.cbegin(), children.cend(), childEntity) == children.end())
			{
				children.push_back(childEntity);

				if (!childEntity.HasComponent<ParentComponent>())
				{
					childEntity.AddComponent<ParentComponent>();
				}

				childEntity.GetComponent<ParentComponent>().parent = thisEntity;
			}
			

            //if (children.size() <= 0) children = std::vector<Entity>();

			//if (children[0] == Entity(-1)) children.clear();

			//if (children.empty()) return;
			//if (std::find(children.begin(), children.end(), childEntity) == children.end())
			//{
			//	children.push_back(childEntity);
			//}
			
			//children.push_back(childEntity);
			
			// Add ParentComponent to child if it doesn't exist
			//if (!childEntity.HasComponent<ParentComponent>())
			//{
			//	childEntity.AddComponent<ParentComponent>(parent);
			//}

			//childEntity.GetComponent<ParentComponent>().parent = parent;

            //if (preserveTransform) InitLocalTransform(childEntity.GetComponent<TransformComponent>());

            //childEntity.GetComponent<ParentComponent>().SetLocalToWorld(childEntity.GetComponent<TransformComponent>());

			//if (childEntity.GetComponent<ParentComponent>().inheritTransform)
			//{
   //             childEntity.GetComponent<ParentComponent>().SyncLocalToWorld(
			//		childEntity.GetComponent<TransformComponent>(), parent.GetComponent<TransformComponent>());
			//}
		}

   //     void InitLocalTransform(const TransformComponent& transform)
   //     {
			//localPosition = transform.position;
			//localScale = transform.scale;
			//localRotation = transform.rotation;
   //     }

		// Convert local transform to world transform
		void UpdateWorldTransform(TransformComponent& transform, const TransformComponent& parentTransform)
		{
			if (!inheritTransform)
			{
				return;
			}

			//if (prevLocalRotation != localRotation)
			//{
			// Calculate world rotation
			transform.rotation = parentTransform.rotation + localRotation;
			//}

			//if (prevLocalRotation != localRotation) SyncLocalToWorld(transform, parentTransform);

			//if (prevLocalScale != localScale)
			//{
			// Calculate world scale
			transform.scale.x = parentTransform.scale.x * localScale.x;
			transform.scale.y = parentTransform.scale.y * localScale.y;
			//}

			//if (prevLocalScale != localScale) SyncLocalToWorld(transform, parentTransform);

			if (prevLocalPosition != localPosition) // || prevLocalRotation != localRotation || prevLocalScale != localScale)
			{
				// Calculate world position using parent's rotation and scale
				double parentRadians = parentTransform.rotation * PopplioMath::M_PI / 180.0f;
				double cosTheta = std::cos(parentRadians);
				double sinTheta = std::sin(parentRadians);

				// Apply parent's rotation and scale to local position
				PopplioMath::Vec2f rotatedLocalPos = {
					static_cast<float>(static_cast<double>(localPosition.x) * cosTheta - 
						static_cast<double>(localPosition.y) * sinTheta),
					static_cast<float>(static_cast<double>(localPosition.x) * sinTheta + 
						static_cast<double>(localPosition.y) * cosTheta)
				};

				// Add parent's position
				transform.position.x = parentTransform.position.x + rotatedLocalPos.x;
				transform.position.y = parentTransform.position.y + rotatedLocalPos.y;

                prevLocalPosition = localPosition;

                SyncLocalToWorld(transform, parentTransform);
			}
			else
			{
				// Calculate world position using parent's rotation and scale
				double parentRadians = parentTransform.rotation * PopplioMath::M_PI / 180.0f;
				double cosTheta = std::cos(parentRadians);
				double sinTheta = std::sin(parentRadians);

				// Apply parent's rotation and scale to local position
				PopplioMath::Vec2f rotatedLocalPos = {
					static_cast<float>((static_cast<double>(localPosition.x) * cosTheta -
						static_cast<double>(localPosition.y) * sinTheta) *
					static_cast<double>(parentTransform.scale.x)),
					static_cast<float>((static_cast<double>(localPosition.x) * sinTheta +
						static_cast<double>(localPosition.y) * cosTheta) *
					static_cast<double>(parentTransform.scale.y))
				};

				// Add parent's position
				transform.position.x = parentTransform.position.x + rotatedLocalPos.x;
				transform.position.y = parentTransform.position.y + rotatedLocalPos.y;

			//	prevLocalPosition = localPosition;
			//	prevLocalScale = localScale;
			//	prevLocalPosition = localPosition;
			}

			prevWorldPosition = transform.position;
			prevWorldScale = transform.scale;
			prevWorldRotation = transform.rotation;
		}

		// Set local to absolute transform of the object
		void SetLocalToWorld(const TransformComponent& transform) // must be same entity
		{
            localPosition = transform.position;
            localScale = transform.scale;
            localRotation = transform.rotation;
		}

        void SetLocalPos(const PopplioMath::Vec2f& pos, 
			TransformComponent& transform, const TransformComponent& parentTransform, 
			const ParentComponent& parentLocalTransform)
        {
            static_cast<void>(parentLocalTransform);

            localPosition = pos;

			// Calculate world position using parent's rotation and scale
			float parentRadians = static_cast<float>(parentTransform.rotation * PopplioMath::M_PI / 180.0f);
			float cosTheta = std::cos(parentRadians);
			float sinTheta = std::sin(parentRadians);

			// Apply parent's rotation and scale to local position
            // do not apply parent's scale as it will mess up everything (do that only during update)
			PopplioMath::Vec2f rotatedLocalPos = 
			{
				(localPosition.x * cosTheta - localPosition.y * sinTheta) * parentTransform.scale.x, //* parentLocalTransform.localScale.x, 
				//* localScale.x, // * parentTransform.scale.x,
                (localPosition.x * sinTheta + localPosition.y * cosTheta) * parentTransform.scale.y //* parentLocalTransform.localScale.y
				//* localScale.y // * parentTransform.scale.y
			};

			// Add parent's position
			transform.position.x = parentTransform.position.x + rotatedLocalPos.x;
			transform.position.y = parentTransform.position.y + rotatedLocalPos.y;

            //SyncLocalToWorld(transform, parentTransform);
        }

		void SetLocalScale(const PopplioMath::Vec2f& scale,
			TransformComponent& transform, const TransformComponent& parentTransform)
		{
            localScale = scale;
			transform.scale.x = parentTransform.scale.x * localScale.x;
			transform.scale.y = parentTransform.scale.y * localScale.y;

			//SyncLocalToWorld(transform, parentTransform);
		}

		void SetLocalRot(const double& rot,
			TransformComponent& transform, const TransformComponent& parentTransform)
		{
            localRotation = rot;

            transform.rotation = parentTransform.rotation + localRotation;

			//SyncLocalToWorld(transform, parentTransform);
		}

		// Set local transform based on current world transform and parent's transform
		void UpdateLocalTransform(const TransformComponent& transform, const TransformComponent& parentTransform)
		{
			if (!inheritTransform)
			{
				return;
			}

            SyncLocalToWorld(transform, parentTransform);
		}

		void SyncLocalToWorld(const TransformComponent& transform, const TransformComponent& parentTransform)
		{
			// Calculate local rotation
			localRotation = transform.rotation - parentTransform.rotation;

			// Calculate local scale
			localScale.x = transform.scale.x / parentTransform.scale.x;
			localScale.y = transform.scale.y / parentTransform.scale.y;

			// Calculate relative position
			PopplioMath::Vec2f relativePosition = {
				transform.position.x - parentTransform.position.x,
				transform.position.y - parentTransform.position.y
			};

			// Reverse parent's rotation and scale
			float parentRadians = static_cast<float>(parentTransform.rotation * PopplioMath::M_PI / 180.0f);
			float cosTheta = std::cos(-parentRadians);
			float sinTheta = std::sin(-parentRadians);

			// Unrotate and unscale the position
			localPosition.x = (relativePosition.x * cosTheta - relativePosition.y * sinTheta) / parentTransform.scale.x;
			localPosition.y = (relativePosition.x * sinTheta + relativePosition.y * cosTheta) / parentTransform.scale.y;

			prevLocalPosition = localPosition;
			prevLocalScale = localScale;
			prevLocalRotation = localRotation;
		}

		void RemoveChild(Entity childEntity)
		{
			// Basic validation
			if (!childEntity.Exists() || childEntity.GetId() < 0)
			{
				Logger::Error("Attempted to remove invalid child entity");
				return;
			}

			auto it = std::find(children.begin(), children.end(), childEntity);
			if (it != children.end())
			{
				// Reset the child's parent reference first
				if (it->HasComponent<ParentComponent>())
				{
					it->GetComponent<ParentComponent>().parent = Entity(-1);
				}
				children.erase(it);
			}

			//while (true)
			//{
			//	auto it = std::find(children.begin(), children.end(), childEntity);
			//	if (it != children.end())
			//	{
			//		it->GetComponent<ParentComponent>().parent = Entity(-1);
			//		children.erase(it);
			//	}
			//	else break;
			//}

   //         if (children.empty()) children.push_back(Entity(-1));

			//if (children.empty()) children = std::vector<Entity>();
		}

		bool LocalIsModified()
		{
            return localPosition != prevLocalPosition || localScale != prevLocalScale || localRotation != prevLocalRotation;
		}

		bool WorldIsModified(const TransformComponent& transform)
		{
			return transform.position != prevWorldPosition || transform.scale != prevWorldScale || 
				transform.rotation != prevWorldRotation;
		}
	};
}

================
File: LoadingScreen/Loading.frag.glsl
================
R"(
#version 460 core
in vec2 TexCoord;
out vec4 FragColor;

uniform float uTime;
uniform float uProgress;

// Useful functions
float random(vec2 st) {
    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

// SDF for basic shapes
float sdBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
}

// PBR shading functions
vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    
    float num = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = 3.14159265359 * denom * denom;
    
    return num / denom;
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;

    float num = NdotV;
    float denom = NdotV * (1.0 - k) + k;
    
    return num / denom;
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx2 = GeometrySchlickGGX(NdotV, roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, roughness);
    
    return ggx1 * ggx2;
}

// Apply PBR shading to a building
vec3 applyPBR(vec3 baseColor, vec2 uv, vec3 neonColor, float buildingMask) {
    // PBR material properties
    float metallic = 0.8 * buildingMask;  // Buildings are metallic
    float roughness = 0.3 * buildingMask; // Polished surface
    float ao = 0.5 + 0.5 * buildingMask;  // Ambient occlusion
    
    // Lighting setup
    vec3 lightPositions[3] = vec3[](
        vec3(0.3, 0.8, 3.0),  // Main light source
        vec3(0.7, 0.3, 2.0),  // Secondary light
        vec3(-0.5, 0.5, 1.0)  // Fill light
    );
    
    vec3 lightColors[3] = vec3[](
        vec3(1.0, 0.8, 0.9) * 2.0,  // Pink-ish main light
        vec3(0.2, 0.8, 1.0) * 1.5,  // Cyan secondary light
        vec3(0.5, 0.2, 0.7) * 1.0   // Purple fill light
    );
    
    // Animate lights subtly
    lightPositions[0].x += sin(uTime * 0.5) * 0.2;
    lightPositions[1].y += cos(uTime * 0.3) * 0.1;
    
    // Normal calculation - generate simple normal from position with some variation
    vec3 N = normalize(vec3(
        sin(uv.x * 10.0) * 0.1 * buildingMask, 
        cos(uv.y * 8.0) * 0.1 * buildingMask, 
        1.0
    ));
    
    // Viewing direction (toward camera)
    vec3 V = normalize(vec3(0.0, 0.0, 1.0));
    
    // Reflectance at normal incidence (F0)
    vec3 F0 = vec3(0.04); 
    F0 = mix(F0, baseColor, metallic);
    
    // Reflectance equation
    vec3 Lo = vec3(0.0);
    
    for(int i = 0; i < 3; ++i) {
        // Calculate per-light radiance
        vec3 L = normalize(lightPositions[i] - vec3(uv * 2.0 - 1.0, 0.0));
        vec3 H = normalize(V + L);
        
        // Cook-Torrance BRDF
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        vec3 kS = F;
        vec3 kD = vec3(1.0) - kS;
        kD *= 1.0 - metallic;
        
        vec3 numerator = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001;
        vec3 specular = numerator / denominator;
        
        // Add to outgoing radiance Lo
        float NdotL = max(dot(N, L), 0.0);
        Lo += (kD * baseColor / 3.14159265359 + specular) * lightColors[i] * NdotL;
    }
    
    // Ambient lighting
    vec3 ambient = vec3(0.03) * baseColor * ao;
    
    // Enhanced neon glow effect
    float rim = 1.0 - max(dot(N, V), 0.0);
    rim = pow(rim, 3.0) * buildingMask;
    vec3 neonRim = neonColor * rim * 2.0;
    
    // Combine all lighting components
    vec3 color = ambient + Lo + neonRim;
    
    // Tone mapping (simplified HDR)
    color = color / (color + vec3(1.0));
    
    // Add subtle reflections on the building surface
    float reflection = pow(1.0 - roughness, 3.0) * metallic * buildingMask;
    color += reflection * neonColor * 0.2;
    
    return color;
}

// Simple sky with subtle effects - matches reference better
vec4 skyEffect(vec2 uv, float time) {
    vec3 finalSky = vec3(0.0);
    
    // Very subtle gradient for the top part
    float topGradient = pow(1.0 - uv.y, 3.0) * 0.05;
    finalSky += vec3(0.05, 0.02, 0.1) * topGradient;
    
    // A few sparse stars
    for (int i = 0; i < 10; i++) {
        float randX = random(vec2(float(i), 0.42));
        float randY = random(vec2(float(i), 0.91));
        
        // Only place stars in the top portion
        vec2 starPos = vec2(
            randX,
            randY * 0.2 // Only in top ~20%
        );
        
        // Small star with minimal twinkling
        float starSize = 0.001 + random(vec2(float(i), 0.33)) * 0.001;
        float dist = length(uv - starPos);
        float brightness = smoothstep(starSize, 0.0, dist) * 0.3;
        brightness *= 0.7 + 0.3 * sin(time * 0.5 + randX * 10.0);
        
        finalSky += brightness * vec3(0.8, 0.8, 1.0);
    }
    
    return vec4(finalSky, 1.0);
}

// Function to create a loading bar with neon effect - matching reference image
vec4 loadingBar(vec2 uv, float progress) {
    // Bar positioning and dimensions - make it thinner as in reference
    float barY = 0.425;  // Just above middle
    float barHeight = 0.015;
    float barWidth = 0.7;
    float barX = 0.5 - (barWidth / 2.0);
    
    // Create simple bar without much glow - cleaner like in reference
    // Bar shape and mask
    float barShape = sdBox(vec2(uv.x - 0.5, uv.y - barY), vec2(barWidth/2.0, barHeight));
    float barMask = smoothstep(0.002, 0.0, abs(barShape));
    
    // Calculate progress position
    float progressPos = barX + (barWidth * progress);
    
    // Create t parameter for full bar gradient
    float t = (uv.x - barX) / barWidth;
    
    // Check if we're inside the bar boundaries
    if (uv.x >= barX && uv.x <= barX + barWidth &&
        uv.y >= barY - barHeight && uv.y <= barY + barHeight) {
        
        // Create gradient colors for the entire bar
        vec3 startColor = vec3(0.2, 0.7, 1.0); // Cyan
        vec3 endColor = vec3(1.0, 0.2, 0.7);   // Pink
        vec3 fullGradient = mix(startColor, endColor, t);
        
        // If in the filled portion, use full brightness
        if (uv.x <= progressPos) {
            return vec4(fullGradient, 1.0);
        } 
        // If in unfilled portion, use darker version of the same gradient
        else {
            // Dimmed version of the same color
            return vec4(fullGradient * 0.2, 1.0);
        }
    }
    
    // Outside bar
    return vec4(0.0);
}

// Add the missing gridBuilding function
vec4 gridBuilding(vec2 uv, float posX, float width, float height, vec3 neonColor) {
    // Building dimensions and positioning
    float buildingX = posX;
    float buildingWidth = width;
    float buildingHeight = height;
    
    // Check if we're inside the building - start from bottom of screen
    bool insideBuilding = (uv.x >= buildingX - buildingWidth/2.0) && 
                          (uv.x <= buildingX + buildingWidth/2.0) && 
                          (uv.y >= 0.0) && 
                          (uv.y <= buildingHeight);
    
    // If not inside the building, return transparent
    if (!insideBuilding) {
        return vec4(0.0);
    }
    
    // Building base color - dark with slight variation
    vec3 baseColor = vec3(0.08, 0.05, 0.15);
    
    // Grid pattern for windows
    float windowSizeX = 0.015;
    float windowSizeY = 0.018;
    float windowSpacingX = 0.025;
    float windowSpacingY = 0.03;
    
    // Normalized coordinates within the building - adjusted for bottom start
    vec2 buildingUV = vec2(
        (uv.x - (buildingX - buildingWidth/2.0)) / buildingWidth,
        uv.y / buildingHeight
    );
    
    // Create window grid
    float windowX = mod(buildingUV.x, windowSpacingX);
    float windowY = mod(buildingUV.y, windowSpacingY);
    
    // Window effect with some randomization
    bool isWindow = (windowX < windowSizeX) && (windowY < windowSizeY);
    float windowRandom = random(vec2(
        floor(buildingUV.x / windowSpacingX),
        floor(buildingUV.y / windowSpacingY)
    ));
    
    // Randomize window glow
    float windowGlow = isWindow ? 0.3 + 0.7 * windowRandom : 0.0;
    windowGlow *= 0.5 + 0.5 * sin(uTime * 0.2 + windowRandom * 10.0);
    
    // Apply PBR shading to the building
    vec3 buildingColor = applyPBR(baseColor, buildingUV, neonColor, 1.0);
    
    // Add window glow
    buildingColor += windowGlow * mix(neonColor, vec3(1.0), 0.7);
    
    // Building outline
    float outlineWidth = 0.003;
    bool isOutline = (buildingUV.x < outlineWidth) || 
                     (buildingUV.x > 1.0 - outlineWidth) || 
                     (buildingUV.y < outlineWidth) || 
                     (buildingUV.y > 1.0 - outlineWidth);
    
    // Add neon outline
    if (isOutline) {
        float outlinePulse = 0.7 + 0.3 * sin(uTime * 2.0);
        buildingColor = mix(buildingColor, neonColor, outlinePulse);
    }
    
    return vec4(buildingColor, 1.0);
}

void main() {
    // Base background - dark gradient
    vec3 topColor = vec3(0.02, 0.01, 0.05);
    vec3 bottomColor = vec3(0.15, 0.05, 0.3);
    vec3 backgroundColor = mix(bottomColor, topColor, pow(TexCoord.y, 0.5));
    
    // Apply sky effects at the top
    vec4 sky = skyEffect(TexCoord, uTime);
    backgroundColor += sky.rgb;
    
    // Final color will be built up from here
    vec4 finalColor = vec4(backgroundColor, 1.0);
    
    // Remove the horizon line - buildings should start from bottom
    // Just add a very subtle darkening at the bottom
    float groundDarkening = smoothstep(0.0, 0.2, TexCoord.y);
    finalColor.rgb *= mix(0.7, 1.0, groundDarkening);
    
    // Create the building layout - similar to the reference image
    // Building configuration:
    // 1. Array of rectangular buildings from the bottom with different heights
    // 2. Alternating cyan and pink neon outlines
    
    // Building positions and dimensions - adjusted to be taller
    vec3 buildingData[6] = vec3[](
        // x, width, height (from bottom)
        vec3(0.1, 0.15, 0.7),    // 1st building
        vec3(0.3, 0.15, 0.85),   // 2nd building  
        vec3(0.5, 0.15, 0.9),    // 3rd building - tallest center
        vec3(0.7, 0.15, 0.75),   // 4th building
        vec3(0.9, 0.15, 0.8),    // 5th building
        vec3(-0.05, 0.15, 0.65)  // Additional building slightly off-screen left
    );
    
    // Alternating pink and cyan neon colors
    vec3 neonColors[6] = vec3[](
        vec3(1.0, 0.2, 0.8),  // Pink
        vec3(0.2, 0.8, 1.0),  // Cyan
        vec3(1.0, 0.2, 0.8),  // Pink
        vec3(0.2, 0.8, 1.0),  // Cyan
        vec3(1.0, 0.2, 0.8),  // Pink
        vec3(0.2, 0.8, 1.0)   // Cyan
    );
    
    // Draw buildings
    for (int i = 0; i < 6; i++) {
        vec2 uv = TexCoord;
        float height = buildingData[i].z;
        vec4 building = gridBuilding(uv, buildingData[i].x, buildingData[i].y, height, neonColors[i]);
        finalColor.rgb = mix(finalColor.rgb, building.rgb, building.a);
    }
    
    // Add some floating particles instead of musical notes
    for (int i = 0; i < 15; i++) {
        // Generate pseudo-random position that moves slowly over time
        float randX = random(vec2(float(i), 0.42));
        float randY = random(vec2(float(i), 0.91));
        
        // Animate the particles
        vec2 particlePos = vec2(
            mod(randX + uTime * (0.02 + randX * 0.05), 1.0),
            randY * 0.6 + 0.2 + sin(uTime * (0.5 + randX) + randY * 10.0) * 0.03
        );
        
        // Calculate particle size and opacity
        float size = 0.002 + random(vec2(float(i), 0.33)) * 0.004;
        float particleOpacity = 0.5 + 0.5 * sin(uTime * (0.3 + randX) + randY * 5.0);
        
        // Calculate distance to particle
        float particleDist = length(TexCoord - particlePos);
        
        // Generate color based on position
        vec3 particleColor = mix(
            vec3(0.2, 0.8, 1.0),  // Cyan
            vec3(1.0, 0.3, 0.7),  // Pink
            random(vec2(float(i), 0.5))
        );
        
        // Add the particle with glow
        float glow = smoothstep(size, 0.0, particleDist);
        finalColor.rgb += glow * particleColor * particleOpacity * 0.5;
    }
    
    // Add the loading bar in the center
    vec4 loadingBarEffect = loadingBar(TexCoord, uProgress);
    finalColor.rgb = mix(finalColor.rgb, loadingBarEffect.rgb, loadingBarEffect.a);
    
    // Add background glow to the center area
    vec2 centerPoint = vec2(0.5, 0.5);
    float centerDistance = length(TexCoord - centerPoint);
    vec3 centerGlow = mix(vec3(0.8, 0.2, 0.9), vec3(0.2, 0.8, 1.0), sin(uTime * 0.5) * 0.5 + 0.5);
    float glowIntensity = smoothstep(0.5, 0.0, centerDistance) * 0.2 * (0.5 + 0.5 * sin(uTime));
    finalColor.rgb += centerGlow * glowIntensity;
    
    // Add subtle post-processing
    // 1. Vignette
    float vignette = length(TexCoord - vec2(0.5)) * 0.5;
    finalColor.rgb *= 1.0 - vignette;
    
    // 2. Subtle scanlines
    float scanline = 0.95 + 0.05 * sin(TexCoord.y * 200.0);
    finalColor.rgb *= scanline;
    
    // 3. Add some noise for a more gritty look
    float noise = random(TexCoord + uTime * 0.01) * 0.03;
    finalColor.rgb += noise;
    
    // Output final color
    FragColor = finalColor;
}
)"

================
File: LoadingScreen/Loading.vert.glsl
================
R"(
    #version 460 core
    layout (location = 0) in vec3 aPos;
    layout (location = 1) in vec2 aTexCoord;
        
    out vec2 TexCoord;
        
    void main()
    {
        gl_Position = vec4(aPos, 1.0);
        TexCoord = aTexCoord;
    }
)"

================
File: LoadingScreen/LoadingScreen.cpp
================
/******************************************************************************/
/*!
\file   SimpleLoadingScreen.cpp
\author Team Popplio
\par    Course : CSD2401
\par    Section : A
\date   2025/03/21
\brief
    This is a minimal loading screen implementation focused on reliable rendering.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#include <pch.h>
#include "LoadingScreen.h"
#include "../Logging/Logger.h"

namespace Popplio
{
    // Basic vertex shader with position and texture coordinates
    const std::string vertexShader = 
    { 
        #include "Loading.vert.glsl"
    };

    // Enhanced background/scene fragment shader with multiple visual elements
    const std::string sceneFragmentShader = 
    {
        #include "Loading.frag.glsl"
    };

    // Simple texture fragment shader for splash screen
    const std::string splashFragmentShader =
    {
        #include "Splash.frag.glsl"
    };

    LoadingScreen::LoadingScreen(GLFWwindow* window)
        : window(window),
        loadingShaderProgram(0),
        splashShaderProgram(0),
        quadVAO(0), quadVBO(0), quadEBO(0),
        progress(0.0f), time(0.0f),
        state(ScreenState::LOADING),
        hasFirstSplash(false),
        hasSecondSplash(false),
        fadeInDuration(0.5f),
        fadeOutDuration(0.5f)
    {
    }

    LoadingScreen::~LoadingScreen()
    {
        Cleanup();
    }

    bool LoadingScreen::Initialize()
    {
        startTime = std::chrono::high_resolution_clock::now();

        // Create shader program
        loadingShaderProgram = CreateShaderProgram(vertexShader.c_str(), sceneFragmentShader.c_str());
        if (!loadingShaderProgram) {
            Logger::Error("Failed to create shader program for loading screen");
            return false;
        }

        // Create shader program for splash screen
        splashShaderProgram = CreateShaderProgram(vertexShader.c_str(), splashFragmentShader.c_str());
        if (!splashShaderProgram) {
            Logger::Error("Failed to create shader program for splash screen");
            return false;
        }

        // Create quad geometry for rendering the entire scene
        float quadVertices[] = {
            // positions (x, y, z)         // texture coords
            -1.0f, -1.0f, 0.0f,           0.0f, 0.0f,
             1.0f, -1.0f, 0.0f,           1.0f, 0.0f,
             1.0f,  1.0f, 0.0f,           1.0f, 1.0f,
            -1.0f,  1.0f, 0.0f,           0.0f, 1.0f
        };

        unsigned int quadIndices[] = {
            0, 1, 2,
            2, 3, 0
        };

        glGenVertexArrays(1, &quadVAO);
        glGenBuffers(1, &quadVBO);
        glGenBuffers(1, &quadEBO);

        glBindVertexArray(quadVAO);

        glBindBuffer(GL_ARRAY_BUFFER, quadVBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), quadVertices, GL_STATIC_DRAW);

        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, quadEBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(quadIndices), quadIndices, GL_STATIC_DRAW);

        // Position attribute
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        // Texture coord attribute
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(float), (void*)(3 * sizeof(float)));
        glEnableVertexAttribArray(1);

        glBindVertexArray(0);

        // Enable blending for transparency
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

        // Immediately render once to avoid white screen
        Render();

        return true;
    }

    GLuint LoadingScreen::CreateShaderProgram(const char* vertexSource, const char* fragmentSource)
    {
        GLuint vertShader = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertShader, 1, &vertexSource, NULL);
        glCompileShader(vertShader);

        // Check for shader compile errors
        GLint success;
        GLchar infoLog[512];
        glGetShaderiv(vertShader, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertShader, 512, NULL, infoLog);
            Logger::Error("Vertex shader compilation failed: " + std::string(infoLog));
            return 0;
        }

        // Fragment shader
        GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragmentShader, 1, &fragmentSource, NULL);
        glCompileShader(fragmentShader);

        // Check for shader compile errors
        glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);
            Logger::Error("Fragment shader compilation failed: " + std::string(infoLog));
            return 0;
        }

        // Link shaders
        GLuint shaderProgram = glCreateProgram();
        glAttachShader(shaderProgram, vertShader);
        glAttachShader(shaderProgram, fragmentShader);
        glLinkProgram(shaderProgram);

        // Check for linking errors
        glGetProgramiv(shaderProgram, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);
            Logger::Error("Shader program linking failed: " + std::string(infoLog));
            return 0;
        }

        // Shaders are linked, they can be deleted
        glDeleteShader(vertShader);
        glDeleteShader(fragmentShader);

        return shaderProgram;
    }

    void LoadingScreen::Update(float newProgress)
    {
        progress = std::max(0.0f, std::min(1.0f, newProgress));

        // Calculate elapsed time for animations
        auto currentTime = std::chrono::high_resolution_clock::now();
        std::chrono::duration<float> elapsed = currentTime - startTime;
        time = elapsed.count();

        // Update window title with loading progress
        if (state == ScreenState::LOADING) {
            std::string title = "Loading... " + std::to_string(static_cast<int>(progress * 100)) + "%";
            glfwSetWindowTitle(window, title.c_str());
        }

        // Check if loading is complete and we should transition to first splash screen
        if (progress >= 1.0f && state == ScreenState::LOADING) {
            if (hasFirstSplash) {
                state = ScreenState::SPLASH_FIRST;
                splashStartTime = std::chrono::high_resolution_clock::now();
                glfwSetWindowTitle(window, "Game Loading"); // Update window title
            }
            else if (hasSecondSplash) {
                state = ScreenState::SPLASH_SECOND;
                splashStartTime = std::chrono::high_resolution_clock::now();
                glfwSetWindowTitle(window, "Game Loading"); // Update window title
            }
            else {
                state = ScreenState::COMPLETED;
            }
        }
    }

    void LoadingScreen::Render()
    {
        // Check if we need to transition from splash to completed
        if (state == ScreenState::SPLASH_FIRST) {
            auto currentTime = std::chrono::high_resolution_clock::now();
            std::chrono::duration<float> elapsed = currentTime - splashStartTime;

            if (elapsed.count() >= firstSplash.duration) {
                if (hasSecondSplash) {
                    state = ScreenState::SPLASH_SECOND;
                    splashStartTime = std::chrono::high_resolution_clock::now();
                }
                else {
                    state = ScreenState::COMPLETED;
                    return;
                }
            }
        }
        else if (state == ScreenState::SPLASH_SECOND) {
            auto currentTime = std::chrono::high_resolution_clock::now();
            std::chrono::duration<float> elapsed = currentTime - splashStartTime;

            if (elapsed.count() >= secondSplash.duration) {
                state = ScreenState::COMPLETED;
                return; // Done showing splash screens
            }
        }


        // Get window dimensions
        int width, height;
        glfwGetFramebufferSize(window, &width, &height);
        glViewport(0, 0, width, height);

        // Clear screen
        glClear(GL_COLOR_BUFFER_BIT);

        // Render appropriate screen based on state
        if (state == ScreenState::LOADING) {
            // Calculate elapsed time for animations
            auto currentTime = std::chrono::high_resolution_clock::now();
            std::chrono::duration<float> elapsed = currentTime - startTime;
            time = elapsed.count();

            // Use shader and set uniforms
            glUseProgram(loadingShaderProgram);
            glUniform1f(glGetUniformLocation(loadingShaderProgram, "uTime"), time);
            glUniform1f(glGetUniformLocation(loadingShaderProgram, "uProgress"), progress);

            // Draw quad that covers the entire screen
            glBindVertexArray(quadVAO);
            glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
        }
        else if (state == ScreenState::SPLASH_FIRST && hasFirstSplash) {
            RenderSplash(firstSplash);
		}
		else if (state == ScreenState::SPLASH_SECOND && hasSecondSplash) {
			RenderSplash(secondSplash);
		}

        // Reset state
        glBindVertexArray(0);
        glUseProgram(0);

        // Swap buffers
        glfwSwapBuffers(window);
    }

    void LoadingScreen::LoadAssets(const std::function<void(float)>& progressCallback)
    {
        // Set loading state
        state = ScreenState::LOADING;

        // Call the provided function to load assets
        progressCallback(progress);

        // Determine next state based on available splash screens
        if (hasFirstSplash) {
            state = ScreenState::SPLASH_FIRST;
            splashStartTime = std::chrono::high_resolution_clock::now();
            glfwSetWindowTitle(window, "Game Loading");
        }
        else if (hasSecondSplash) {
            state = ScreenState::SPLASH_SECOND;
            splashStartTime = std::chrono::high_resolution_clock::now();
            glfwSetWindowTitle(window, "Game Loading");
        }
        else {
            // If no splash textures, mark as completed
            state = ScreenState::COMPLETED;
        }
    }

    bool LoadingScreen::IsComplete() const
    {
        return state == ScreenState::COMPLETED;
    }

    void LoadingScreen::SetFirstSplashTexture(const std::string& textureName, float duration)
    {
        firstSplash.textureName = textureName;
		firstSplash.duration = duration;

        // Try to get the texture from AssetStore
        firstSplash.textureID = AssetStore::GetTexture(textureName);

        if (firstSplash.textureID != 0) {
            hasFirstSplash = true;

            // Get texture dimensions
            firstSplash.dimensions = AssetStore::GetTextureSize(textureName);

            Logger::Info("Splash screen texture loaded: " + textureName +
                " (" + std::to_string(firstSplash.dimensions.first) + "x" +
                std::to_string(firstSplash.dimensions.second) + ")", LogDestination::WINDOWS_CONSOLE);
        }
        else {
            hasFirstSplash = false;
            Logger::Warning("Failed to find splash screen texture: " + textureName, LogDestination::WINDOWS_CONSOLE);
        }
    }

    void LoadingScreen::SetSecondSplashTexture(const std::string& textureName, float duration)
    {
		secondSplash.textureName = textureName;
		secondSplash.duration = duration;

		// Try to get the texture from AssetStore
		secondSplash.textureID = AssetStore::GetTexture(textureName);

        if (secondSplash.textureID != 0) {
			hasSecondSplash = true;

			// Get texture dimensions
			secondSplash.dimensions = AssetStore::GetTextureSize(textureName);

            Logger::Info("Splash screen texture loaded: " + textureName +
                " (" + std::to_string(secondSplash.dimensions.first) + "x" +
                std::to_string(secondSplash.dimensions.second) + ")", LogDestination::WINDOWS_CONSOLE);
        }
        else {
            hasSecondSplash = false;
            Logger::Warning("Failed to find splash screen texture: " + textureName, LogDestination::WINDOWS_CONSOLE);
        }
    }

    void LoadingScreen::Cleanup()
    {
        // Delete OpenGL resources
        if (loadingShaderProgram)
            glDeleteProgram(loadingShaderProgram);

        if (splashShaderProgram)
            glDeleteProgram(splashShaderProgram);

        if (quadVAO)
            glDeleteVertexArrays(1, &quadVAO);

        if (quadVBO)
            glDeleteBuffers(1, &quadVBO);

        if (quadEBO)
            glDeleteBuffers(1, &quadEBO);
    }

    void LoadingScreen::RenderSplash(const SplashData& splashData)
    {
        // Calculate fade effect (fade in then fade out)
        auto currentTime = std::chrono::high_resolution_clock::now();
        std::chrono::duration<float> elapsed = currentTime - splashStartTime;
        float fadeTime = elapsed.count();

        float fadeAlpha;
        float holdDuration = splashData.duration - (fadeInDuration + fadeOutDuration);  // Time to hold at full opacity

        if (fadeTime < fadeInDuration) {
            // Fade in
            fadeAlpha = fadeTime / fadeInDuration;
        }
        else if (fadeTime < fadeInDuration + holdDuration) {
            // Hold at full opacity
            fadeAlpha = 1.0f;
        }
        else {
            // Fade out
            fadeAlpha = 1.0f - ((fadeTime - fadeInDuration - holdDuration) / fadeOutDuration);
        }

        fadeAlpha = std::max(0.0f, std::min(1.0f, fadeAlpha)); // Clamp between 0 and 1

        // Get window dimensions
        int width, height;
        glfwGetFramebufferSize(window, &width, &height);

        // Use splash shader program
        glUseProgram(splashShaderProgram);

        // Bind texture
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, splashData.textureID);
        glUniform1i(glGetUniformLocation(splashShaderProgram, "splashTexture"), 0);

        // Set fade uniform
        glUniform1f(glGetUniformLocation(splashShaderProgram, "fadeAlpha"), fadeAlpha);

        // Set texture and screen size for aspect ratio calculation
        glUniform2f(glGetUniformLocation(splashShaderProgram, "textureSize"),
            static_cast<float>(splashData.dimensions.first),
            static_cast<float>(splashData.dimensions.second));
        glUniform2f(glGetUniformLocation(splashShaderProgram, "screenSize"),
            static_cast<float>(width),
            static_cast<float>(height));

        // Draw quad
        glBindVertexArray(quadVAO);
        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);
    }
}

================
File: LoadingScreen/LoadingScreen.h
================
/******************************************************************************/
/*!
\file   SimpleLoadingScreen.h
\author Team Popplio
\par    Course : CSD2401
\par    Section : A
\date   2025/03/21
\brief
    This is a simplified loading screen implementation focused on reliable rendering.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once

#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <functional>
#include <string>

namespace Popplio
{
    class LoadingScreen
    {
    public:
        // Enum to track screen state
        enum class ScreenState {
            LOADING,        // Initial loading screen with progress bar
            SPLASH_FIRST,   // First splash screen (digipen logo)
            SPLASH_SECOND,  // Second splash screen (game logo)
            COMPLETED       // Loading process is complete
        };

        // Structure to hold splash screen data
        struct SplashData {
            std::string textureName;
            unsigned int textureID;
            std::pair<int, int> dimensions;
            float duration;  // Duration in seconds to show this splash

            SplashData(const std::string& name = "", float dur = 3.0f)
                : textureName(name), textureID(0), dimensions({ 0, 0 }), duration(dur) {
            }
        };

        LoadingScreen(GLFWwindow* window);
        ~LoadingScreen();

        // Initialize the loading screen
        bool Initialize();

        // Update the loading progress (0.0f to 1.0f)
        void Update(float progress);

        // Render the loading screen
        void Render();

        // Load assets with progress reporting
        void LoadAssets(const std::function<void(float)>& progressCallback);

        // Check if loading is complete
        bool IsComplete() const;

        // Set the first splash screen texture
        void SetFirstSplashTexture(const std::string & textureName, float duration = 3.0f);

        // Set the second splash screen texture
        void SetSecondSplashTexture(const std::string& textureName, float duration = 3.0f);

    private:
        // Helper function to create a shader program
        GLuint CreateShaderProgram(const char* vertexSource, const char* fragmentSource);

        // Clean up resources
        void Cleanup();

        // Render the splash screen
        void RenderSplash(const SplashData& splashData);

        // Window reference
        GLFWwindow* window;

        // Shader program and quad rendering elements
        GLuint loadingShaderProgram;
        GLuint splashShaderProgram;
        GLuint quadVAO, quadVBO, quadEBO;

        // Splash screen textures
		SplashData firstSplash;
		SplashData secondSplash;
		bool hasFirstSplash;
		bool hasSecondSplash;

        // Loading state
        float progress;
        float time;
        ScreenState state;

        // Timing for animations
        std::chrono::time_point<std::chrono::high_resolution_clock> startTime;
        std::chrono::time_point<std::chrono::high_resolution_clock> splashStartTime;

        // Fade durations
        float fadeInDuration; // Tie to fade in (seconds)
		float fadeOutDuration; // Tie to fade out (seconds)
    };
}

================
File: LoadingScreen/Splash.frag.glsl
================
R"(
    #version 460 core
    in vec2 TexCoord;
    out vec4 FragColor;
    
    uniform sampler2D splashTexture;
    uniform float fadeAlpha;     // Alpha value for fading
    uniform vec2 textureSize;    // Size of the texture (width, height)
    uniform vec2 screenSize;     // Size of the screen (width, height)
    
    void main()
    {
        // Calculate aspect ratios
        float textureAspect = textureSize.x / textureSize.y;
        float screenAspect = screenSize.x / screenSize.y;
        
        // Calculate the texture coordinates that maintain aspect ratio
        vec2 adjustedTexCoord = TexCoord;
        
        if (screenAspect > textureAspect) {
            // Screen is wider than texture
            float scale = textureAspect / screenAspect;
            adjustedTexCoord.x = 0.5 + (TexCoord.x - 0.5) / scale;
            
            // If the adjusted coordinates are outside [0,1], draw transparent
            if (adjustedTexCoord.x < 0.0 || adjustedTexCoord.x > 1.0) {
                FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                return;
            }
        } else {
            // Screen is taller than texture
            float scale = screenAspect / textureAspect;
            adjustedTexCoord.y = 0.5 + (TexCoord.y - 0.5) / scale;
            
            // If the adjusted coordinates are outside [0,1], draw transparent
            if (adjustedTexCoord.y < 0.0 || adjustedTexCoord.y > 1.0) {
                FragColor = vec4(0.0, 0.0, 0.0, 0.0);
                return;
            }
        }
        
        vec4 texColor = texture(splashTexture, adjustedTexCoord);
        FragColor = vec4(texColor.rgb, texColor.a * fadeAlpha);
    }
)"

================
File: Logging/Logger.cpp
================
/******************************************************************************/
/*!
\file   Logger.cpp
\author Team Popplio
\author Bryan Ang Wei Ze
\co-author Shawn Ng Jun Heng
\contribution Bryan - 95% | Shawn - 5%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/11/05
\brief
	This source file implements the Logger class within the Popplio namespace. 
	The Logger class is responsible for logging messages with different severity 
	levels to various destinations, such as the Windows console and ImGui console. 
	It supports different log levels, including debug, info, warning, error, and critical.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>
#include <Windows.h>

namespace Popplio
{
	// Initialize static members
	bool Logger::showEngine = true;
	bool Logger::showUser = true;

	LogLevel Logger::currentLevel = LogLevel::INFO_LOG;
	bool Logger::isInitialized = false;
	std::vector<LogEntry> Logger::logBuffer;

	void Logger::Initialize(LogLevel level)
	{
		if (!isInitialized)
		{
			currentLevel = level;
			isInitialized = true;
		}
	}

	void Logger::SetLogLevel(LogLevel level)
	{
		currentLevel = level;
	}

	LogLevel Logger::GetLogLevel()
	{
        return currentLevel;
	}

	void Logger::Debug(const std::string& message, LogDestination dest, bool isEngine)
	{
		Log(LogLevel::DEBUG_LOG, message, dest, isEngine);
	}

	void Logger::Info(const std::string& message, LogDestination dest, bool isEngine)
	{
		Log(LogLevel::INFO_LOG, message, dest, isEngine);
	}

	void Logger::Warning(const std::string& message, LogDestination dest, bool isEngine)
	{
		Log(LogLevel::WARNING_LOG, message, dest, isEngine);
	}

	void Logger::Error(const std::string& message, LogDestination dest, bool isEngine)
	{
		Log(LogLevel::ERROR_LOG, message, dest, isEngine);
	}

	void Logger::Critical(const std::string& message, LogDestination dest, bool isEngine)
	{
		Log(LogLevel::CRITICAL_LOG, message, dest, isEngine);
	}

	void Logger::Log(LogLevel level, const std::string& message, LogDestination dest, bool isEngine)
	{
		if (!isInitialized)
		{
			Initialize(); // Initialize with default values if not done explicitly
		}

		if (level < currentLevel)
		{
			return;
		}

        if (!isEngine && !showUser) return;
        if (isEngine && !showEngine) return;

		std::string timestamp = GetCurrentTimestamp();
		std::string levelStr = LogLevelToString(level);

        std::string origin = isEngine ? "ENGINE | " : "USER | ";

		std::string logMessage = origin + timestamp + " " + "[" + levelStr + "]" + " " + message;

		// Windows console colors
		WORD consoleColor = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
		// ImGui colors
#ifndef IMGUI_DISABLE
		ImVec4 imguiColor;
#endif
		switch (level)
		{
		case LogLevel::DEBUG_LOG:
			consoleColor = FOREGROUND_INTENSITY | FOREGROUND_BLUE | FOREGROUND_GREEN; // Cyan
#ifndef IMGUI_DISABLE
			imguiColor = ImVec4(0.0f, 1.0f, 1.0f, 1.0f); // Cyan
#endif
			break;
		case LogLevel::INFO_LOG:
			consoleColor = FOREGROUND_INTENSITY | FOREGROUND_GREEN; // Green
#ifndef IMGUI_DISABLE
			imguiColor = ImVec4(0.0f, 1.0f, 0.0f, 1.0f); // Green
#endif
			break;
		case LogLevel::WARNING_LOG:
			consoleColor = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN; // Yellow
#ifndef IMGUI_DISABLE
			imguiColor = ImVec4(1.0f, 1.0f, 0.0f, 1.0f); // Yellow
#endif
			break;
		case LogLevel::ERROR_LOG:
			consoleColor = FOREGROUND_INTENSITY | FOREGROUND_RED; // Red
#ifndef IMGUI_DISABLE
			imguiColor = ImVec4(1.0f, 0.0f, 0.0f, 1.0f); // Red
#endif
			break;
		case LogLevel::CRITICAL_LOG:
			consoleColor = FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_BLUE;  // Magenta
#ifndef IMGUI_DISABLE
			imguiColor = ImVec4(1.0f, 0.0f, 1.0f, 1.0f); // Magenta
#endif
			break;
		}

		// Log to Windows console if specified
		if (dest & LogDestination::WINDOWS_CONSOLE)
		{
			LogToWindowsConsole(logMessage, consoleColor);
		}

#ifndef IMGUI_DISABLE
		// Log to ImGui if specified
		if (dest & LogDestination::IMGUI_CONSOLE) {
			LogToImGui(logMessage, imguiColor, dest);
		}
#endif // !#ifndef IMGUI_DISABLE


	}

	void Logger::LogToWindowsConsole(const std::string& message, unsigned short color)
	{
		HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
		SetConsoleTextAttribute(hConsole, color);
		std::cout << message << std::endl;
		SetConsoleTextAttribute(hConsole, FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE); // Reset color
	}

#ifndef IMGUI_DISABLE
	void Logger::LogToImGui(const std::string& message, const ImVec4& color, LogDestination dest)
	{
		logBuffer.emplace_back(message, color, dest);
		if (logBuffer.size() > 1000)
		{
			logBuffer.erase(logBuffer.begin());
		}
	}
#endif

	const std::vector<LogEntry>& Logger::GetLogBuffer()
	{
		return logBuffer;
	}

	void Logger::ClearLogBuffer()
	{
		logBuffer.clear();
	}

	std::string Logger::GetCurrentTimestamp()
	{
		std::time_t now = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
		char buffer[32];

		struct tm timeinfo;
		localtime_s(&timeinfo, &now);

		std::strftime(buffer, sizeof(buffer), "%d-%b-%Y %H:%M:%S", &timeinfo);
		return std::string(buffer);
	}

	std::string Logger::LogLevelToString(LogLevel level)
	{
		switch (level)
		{
		case LogLevel::DEBUG_LOG:
			return "DEBUG";
			break;
		case LogLevel::INFO_LOG:
			return "INFO";
			break;
		case LogLevel::WARNING_LOG:
			return "WARNING";
			break;
		case LogLevel::ERROR_LOG:
			return "ERROR";
			break;
		case LogLevel::CRITICAL_LOG:
			return "CRITICAL";
			break;
		default:
			return "UMKNOWN";
		}
	}
}

================
File: Logging/Logger.h
================
/******************************************************************************/
/*!
\file   Logger.h
\author Team Popplio
\author Bryan Ang Wei Ze
\co-author Shawn Ng Jun Heng
\contribution Bryan - 95% | Shawn - 5%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/10/02
\brief
    This header file defines the Logger class within the Popplio namespace. 
    The Logger class provides logging functionality with different log levels 
    and destinations. It supports logging messages to the Windows console and 
    ImGui console, with options for different severity levels such as debug, 
    info, warning, error, and critical.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <chrono>
#include <iomanip>
#include <mutex>
#include <vector>
#include <imgui/imgui.h>

namespace Popplio
{
    enum class LogLevel
    {
        DEBUG_LOG,
        INFO_LOG,
        WARNING_LOG,
        ERROR_LOG,
        CRITICAL_LOG
    };

    enum class LogDestination
    {
        WINDOWS_CONSOLE = 1,
        IMGUI_CONSOLE = 2,
        ALL = WINDOWS_CONSOLE | IMGUI_CONSOLE
    };

    struct LogEntry
    {
        std::string message;

#ifndef IMGUI_DISABLE
        ImVec4 color;
#endif
        LogDestination destination;


#ifndef IMGUI_DISABLE
        LogEntry(const std::string& msg, const ImVec4& clr, LogDestination dest)
            : message(msg), color(clr), destination(dest) {
        }
#else
        LogEntry(const std::string& msg, LogDestination dest)
            : message(msg), destination(dest) {
        }
#endif




    };

    /**
    * @class Logger
    * @brief Provides logging functionality with different log levels.
    */
    class Logger
    {
    public:

        static bool showEngine;
        static bool showUser;

        /**
            * Initializes the Logger with the specified log level
            * @param level The log level to set. Default is LogLevel::INFO.
            * @param useColor Determines whether to use color in the log output. Default is true.
            */
        static void Initialize(LogLevel level = LogLevel::INFO_LOG);

        /**
            * Sets the log level for the Logger.
            * @param level The log level to set.
            */
        static void SetLogLevel(LogLevel level);

        /**
            * Gets the log level for the Logger.
            * @return Current log level.
            */
        static LogLevel GetLogLevel();

        /**
            * Logs a debug message.
            * @param message The message to log.
            */
        static void Debug(const std::string& message, LogDestination dest = LogDestination::ALL, bool isEngine = true);

        /**
            * Logs an info message.
            * @param message The message to log.
            */
        static void Info(const std::string& message, LogDestination dest = LogDestination::ALL, bool isEngine = true);

        /**
            * Logs a warning message.
            * @param message The message to log.
            */
        static void Warning(const std::string& message, LogDestination dest = LogDestination::ALL, bool isEngine = true);

        /**
            * Logs an error message.
            * @param message The message to log.
            */
        static void Error(const std::string& message, LogDestination dest = LogDestination::ALL, bool isEngine = true);

        /**
            * Logs a critical message.
            * @param message The message to log.
            */
        static void Critical(const std::string& message, LogDestination dest = LogDestination::ALL, bool isEngine = true);

        /**
            * Retrieves the log buffer containing all the logged entries.
            * @return A constant reference to the log buffer.
            */
        static const std::vector<LogEntry>& GetLogBuffer();

        /**
            * Clears the log buffer, removing all logged entries.
            */
        static void ClearLogBuffer();

    private:
        /**
            * Logs a message with the specified log level.
            * @param level The log level of the message.
            * @param message The message to log.
            */
        static void Log(LogLevel level, const std::string& message, LogDestination dest, bool isEngine = true);

        /**
        * Logs the message to the Windows console with the specified color.
        * @param message The message to log.
        * @param color The color to use for the log message.
        */
        static void LogToWindowsConsole(const std::string& message, unsigned short color);

        /**
            * Logs the message to the ImGui console with the specified color and destination.
            * @param message The message to log.
            * @param color The color to use for the log message.
            * @param dest The destination to log the message to.
            */
#ifndef IMGUI_DISABLE
        static void LogToImGui(const std::string& message, const ImVec4& color, LogDestination dest);
#endif
        /**
            * Gets the current timestamp in the format "YYYY-MM-DD HH:MM:SS".
            * @return The current timestamp.
            */
        static std::string GetCurrentTimestamp();

        /**
            * Converts a log level enum value to its string representation.
            * @param level The log level to convert.
            * @return The string representation of the log level.
            */
        static std::string LogLevelToString(LogLevel level);

        static LogLevel currentLevel;
        static bool isInitialized;
        static std::vector<LogEntry> logBuffer;
    };

    /**
        * @brief Overload the bitwise OR operator for combining LogDestination values.
        * @param a The first LogDestination value.
        * @param b The second LogDestination value.
        * @return The combined LogDestination value.
        */
    inline LogDestination operator|(LogDestination a, LogDestination b)
    {
        return static_cast<LogDestination>
            (
                static_cast<int>(a) | static_cast<int>(b)
                );
    }

    /**
        * @brief Overload the bitwise AND operator for checking if LogDestination values have common flags.
        * @param a The first LogDestination value.
        * @param b The second LogDestination value.
        * @return True if the LogDestination values have common flags, false otherwise.
        */
    inline bool operator&(LogDestination a, LogDestination b)
    {
        return static_cast<bool>
            (
                static_cast<int>(a) & static_cast<int>(b)
                );
    }
}

================
File: PrefabManagement/Prefab.cpp
================
/******************************************************************************/
/*!
\file   Prefab.cpp
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/03/14
\brief
    This source file defines the Prefab class within the Popplio namespace. 
    A Prefab is a template for creating entities with predefined components in a game engine. 
    The class provides methods to instantiate these prefabs into a registry, validate their state, 
    and manage their components.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>
#include "Prefab.h"
#include "PrefabManager.h"
#include "../Hierarchy/HierarchySystem.h"

namespace Popplio
{
	Prefab::Prefab(const std::string& name)
		: name(name), isValid(true)
	{
        // Add default ActiveComponent
        AddComponent<ActiveComponent>();
		// Add default TransformComponent
		AddComponent<TransformComponent>();
	}

	[[nodiscard]]
	Entity Prefab::InstantiateBase(Registry& registry) const
	{
        if (!IsValid())
        {
            Logger::Error("Cannot instantiate invalid prefab: " + name, LogDestination::IMGUI_CONSOLE);
            return Entity(-1); // Return invalid entity
        }

        // Create a brand new entity with a unique ID (don't specify ID)
        Entity entity = registry.CreateEntity();

        try
        {
            // Apply tag with instance counter
            static std::unordered_map<std::string, int> instanceCounters;
            int instanceNum = ++instanceCounters[name];
            entity.Tag(name + "_Instance_" + std::to_string(instanceNum));

            // Apply all component factories to create components on the new entity
            for (const auto& [type, factory] : componentFactories)
            {
                factory(entity);
            }

            // Add the PrefabInstanceComponent to track this instance
            entity.AddComponent<PrefabInstanceComponent>(name);

            Logger::Info("Successfully instantiated prefab base: " + name +
                " as Entity " + std::to_string(entity.GetId()), LogDestination::IMGUI_CONSOLE);
        }
        catch (const std::exception& e)
        {
            Logger::Error("Failed to instantiate prefab: " + name +
                " Error: " + e.what(), LogDestination::IMGUI_CONSOLE);
            registry.KillEntity(entity);
            return Entity(-1);
        }

        return entity;
	}

    [[nodiscard]]
    Entity Prefab::Instantiate(Registry& registry, PrefabManager& prefabManager) const
	{
        // Create the root entity for this prefab
        Entity entity = InstantiateBase(registry);
        if (entity.GetId() == -1)
        {
            return entity;
        }

        registry.Update(); // Process any pending entity changes

        // Instantiate child prefabs recursively with completely new entity IDs
        InstantiateChildPrefabs(entity, childPrefabs, registry, prefabManager);

        registry.Update(); // Make sure all entity changes are processed
        return entity;
	}

	void Prefab::InstantiateChildPrefabs(Entity& parentEntity, const std::vector<PrefabRef>& childRefs, Registry& registry, PrefabManager& prefabManager) const
	{
        auto& parentTransform = parentEntity.GetComponent<TransformComponent>();

        for (const auto& childRef : childRefs)
        {
            std::string prefabName = std::filesystem::path(childRef.prefabPath).stem().string();
            auto prefabOpt = prefabManager.GetPrefab(prefabName);

            if (!prefabOpt)
            {
                Logger::Warning("Could not find prefab: " + prefabName);
                continue;
            }

            // Create a completely new entity instance with a unique ID
            Entity childEntity = prefabOpt->get().InstantiateBase(registry);
            if (childEntity.GetId() == -1)
            {
                Logger::Warning("Failed to instantiate child prefab: " + prefabName);
                continue;
            }

            registry.Update(); // Process pending entity changes

            // Setup parent-child relationship
            // Make sure parent has ParentComponent
            if (!parentEntity.HasComponent<ParentComponent>())
            {
                parentEntity.AddComponent<ParentComponent>();
            }

            // Make sure child has proper ParentComponent
            if (!childEntity.HasComponent<ParentComponent>())
            {
                childEntity.AddComponent<ParentComponent>(parentEntity);
            }
            else
            {
                auto& childParentComp = childEntity.GetComponent<ParentComponent>();
                childParentComp.parent = parentEntity;

                // Clear any previous children the component might have had
                childParentComp.children.clear();
            }

            // Add child to parent's children list
            parentEntity.GetComponent<ParentComponent>().AddChild(childEntity, parentEntity);

            registry.Update(); // Process entity changes

            // Update child's transform based on prefab reference
            auto& childTransform = childEntity.GetComponent<TransformComponent>();
            auto& childParentComp = childEntity.GetComponent<ParentComponent>();

            // Set local transform values from the prefab reference
            childParentComp.localPosition = childRef.localPosition;
            childParentComp.localScale = childRef.localScale;
            childParentComp.localRotation = childRef.localRotation;

            // Update world transform based on parent
            childParentComp.UpdateWorldTransform(childTransform, parentTransform);

            // Log successful child instantiation
            Logger::Debug("Instantiated child prefab " + prefabName +
                " as Entity " + std::to_string(childEntity.GetId()) +
                " with parent " + std::to_string(parentEntity.GetId()));

            // Recursively instantiate this child's nested prefabs if any
            if (prefabOpt)
            {
                const auto& nestedChildRefs = prefabOpt->get().GetChildPrefabs();
                if (!nestedChildRefs.empty())
                {
                    InstantiateChildPrefabs(childEntity, nestedChildRefs, registry, prefabManager);
                }
            }
        }
	}

	[[nodiscard]]
	const std::string& Prefab::GetName() const noexcept
	{
		return name;
	}

    [[nodiscard]]
    bool Prefab::IsValid() const noexcept
    {
        return isValid && HasComponent<TransformComponent>() && HasComponent<ActiveComponent>();
    }

    void Prefab::ValidatePrefabState()
    {
        // Check for required components
        if (!HasComponent<TransformComponent>())
        {
            Logger::Warning("Prefab missing required TransformComponent: " + name);
            isValid = false;
            return;
        }

        if (!HasComponent<ActiveComponent>())
        {
            Logger::Warning("Prefab missing required ActiveComponent: " + name);
            isValid = false;
            return;
        }

        // Additional validation as needed
        isValid = true;
    }

	void Prefab::AddChildPrefab(const PrefabRef& prefabRef)
	{
		childPrefabs.push_back(prefabRef);
	}

	void Prefab::RemoveChildPrefab(const std::string& prefabPath)
	{
        childPrefabs.erase(
			std::remove_if(
                childPrefabs.begin(), 
                childPrefabs.end(),
				[&prefabPath](const PrefabRef& prefabRef) { return prefabRef.prefabPath == prefabPath; }
            ),
			childPrefabs.end()
        );
	}

    [[nodiscard]] 
    const std::vector<PrefabRef>& Prefab::GetChildPrefabs() const
    {
        return childPrefabs;
    }
}

================
File: PrefabManagement/Prefab.h
================
/******************************************************************************/
/*!
\file   Prefab.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/03/14
\brief
	This header file defines the Prefab class within the Popplio namespace.
	A Prefab is a template for creating entities with predefined components in a game engine.
	The class provides methods to instantiate these prefabs into a registry, validate their state,
	and manage their components.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include <string>
#include <unordered_map>
#include <functional>
#include <typeindex>
#include <any>
#include "../ECS/ECS.h"
#include "../Transformation/TransformComponent.h"
#include "../Script/ActiveComponent.h"
#include "PrefabRef.h"

// Forward declarations
namespace Popplio
{
	class PrefabManager;
}

namespace Popplio
{
	/**
  * @brief Represents a Prefab object that can be used to instantiate entities with predefined components.
  */
	class Prefab
	{
	public:
		/**
   * @brief Constructs a Prefab object with the specified name.
   * @param name The name of the Prefab.
   */
		explicit Prefab(const std::string& name);

		/**
   * @brief Adds a component of type T to the Prefab with the specified arguments.
   * @tparam T The type of the component to add.
   * @tparam Args The types of the arguments to pass to the component constructor.
   * @param args The arguments to pass to the component constructor.
   */
		template <typename T, typename... Args>
		void AddComponent(Args&&... args);

		/**
   * @brief Removes the component of type T from the Prefab.
   * @tparam T The type of the component to remove.
   */
		template <typename T>
		void RemoveComponent();

		/**
   * @brief Checks if the Prefab has a component of type T.
   * @tparam T The type of the component to check.
   * @return True if the Prefab has a component of type T, false otherwise.
   */
		template <typename T>
		bool HasComponent() const;

		/**
   * @brief Gets the component of type T from the Prefab.
   * @tparam T The type of the component to get.
   * @return A reference to the component of type T.
   * @throws std::runtime_error if the component of type T is not found in the Prefab.
   */
		template <typename T>
		T& GetComponent();

		/**
   * @brief Gets the component of type T from the Prefab.
   * @tparam T The type of the component to get.
   * @return A const reference to the component of type T.
   * @throws std::runtime_error if the component of type T is not found in the Prefab.
   */
		template <typename T>
		const T& GetComponent() const;

		/**
   * @brief Instantiates an entity with the components defined in the Prefab.
   * @param registry The ECS registry to create the entity in.
   * @return The instantiated entity.
   */
		[[nodiscard]] Entity InstantiateBase(Registry& registry) const;

		void InstantiateChildPrefabs(Entity& parentEntity, const std::vector<PrefabRef>& childRefs, Registry& registry, PrefabManager& prefabManager) const;

		// Handles nested prefabs
		[[nodiscard]] Entity Instantiate(Registry& registry, PrefabManager& prefabManager) const;

		/**
   * @brief Gets the name of the Prefab.
   * @return The name of the Prefab.
   */
		[[nodiscard]] const std::string& GetName() const noexcept;

		/**
   * @brief Checks if the Prefab is valid.
   * @return True if the Prefab is valid, false otherwise.
   */
		[[nodiscard]] bool IsValid() const noexcept;

		void AddChildPrefab(const PrefabRef& prefabRef);
		void RemoveChildPrefab(const std::string& prefabPath);
		[[nodiscard]] const std::vector<PrefabRef>& GetChildPrefabs() const;

	private:
		std::string name; /**< The name of the Prefab. */
		bool isValid; /**< Flag indicating if the Prefab is valid. */
		std::unordered_map<std::type_index, std::function<void(Entity&)>> componentFactories; /**< Map of component factories. */
		std::unordered_map<std::type_index, std::any> componentData; /**< Map of component data. */
		std::vector<PrefabRef> childPrefabs; /**< The children prefabs. */
		/**
   * @brief Helper function to validate the state of the Prefab.
   */
		void ValidatePrefabState();
	};

	template <typename T>
	void Prefab::RemoveComponent()
	{
		// Special handling for TransformComponent - cannot be removed
		if constexpr (std::is_same_v<T, TransformComponent>)
		{
			Logger::Warning("Cannot remove TransformComponent from prefab as it is required", LogDestination::IMGUI_CONSOLE);
			return;
		}

		// Special handling for ActiveComponent - cannot be removed
		if constexpr (std::is_same_v<T, ActiveComponent>)
		{
			Logger::Warning("Cannot remove ActiveComponent from prefab as it is required", LogDestination::IMGUI_CONSOLE);
			return;
		}

		// Check if component exists
		if (!HasComponent<T>())
		{
			Logger::Warning("Attempted to remove non-existent component type: " + std::string(typeid(T).name()), LogDestination::IMGUI_CONSOLE);
			return;
		}

		auto typeIndex = std::type_index(typeid(T));

		// Remove from component data storage
		componentData.erase(typeIndex);

		// Remove from component factories
		componentFactories.erase(typeIndex);

		ValidatePrefabState();

		Logger::Debug("Removed component type: " + std::string(typeid(T).name()) + " from prefab: " + name, LogDestination::IMGUI_CONSOLE);
	}

	template <typename T, typename... Args>
	void Prefab::AddComponent(Args&&... args)
	{
		// Update components data
		componentData[std::type_index(typeid(T))] = T(std::forward<Args>(args)...);

		// Create factory function for this component
		componentFactories[std::type_index(typeid(T))] =
			[args = std::make_tuple(std::forward<Args>(args)...)](Entity& e) {
			std::apply([&e](const auto&... params) {
				e.AddComponent<T>(params...);
			}, args);
		};

		ValidatePrefabState();

		Logger::Debug("Added component to prefab " + name + ": " + typeid(T).name(), LogDestination::IMGUI_CONSOLE);
	}

	template <typename T>
	bool Prefab::HasComponent() const
	{
		return componentData.contains(std::type_index(typeid(T)));
	}

	template <typename T>
	T& Prefab::GetComponent()
	{
		auto it = componentData.find(std::type_index(typeid(T)));
		if (it == componentData.end())
		{
			throw std::runtime_error("Component not found in prefab: " + 
				std::string(typeid(T).name()));
		}
		return std::any_cast<T&>(it->second);
	}

	template <typename T>
	const T& Prefab::GetComponent() const
	{
		auto it = componentData.find(std::type_index(typeid(T)));
		if (it == componentData.end())
		{
			throw std::runtime_error("Component not found in prefab: " + 
				std::string(typeid(T).name()));
		}
		return std::any_cast<const T&>(it->second);
	}
}

================
File: PrefabManagement/PrefabEvent.h
================
/******************************************************************************/
/*!
\file   PrefabEvent.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/11/05
\brief
	This header file defines the PrefabEvent structure within the Popplio namespace. 
	The PrefabEvent structure is used to represent events related to prefabs, 
	such as modifications or deletions. It inherits from the Event class and 
	includes information about the prefab and the type of event.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include "../EventBus/Event.h"
#include <string>
#include <typeindex>

namespace Popplio
{
	enum class PrefabEventType
	{
		Modified,
		Deleted,
	};

	struct PrefabEvent : public Event
	{
		std::string prefabName;
		PrefabEventType eventType;
		std::optional<std::type_index> modifiedComponentType;

		PrefabEvent(const std::string& name, PrefabEventType type,
			std::optional<std::type_index> componentType = std::nullopt)
			: prefabName(name), eventType(type), modifiedComponentType(componentType) {}
	};
}

================
File: PrefabManagement/PrefabInstanceComponent.h
================
/******************************************************************************/
/*!
\file   PrefabInstanceComponent.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2024/11/05
\brief
	This header file defines the PrefabInstanceComponent structure within the 
	Popplio namespace. The PrefabInstanceComponent is used to represent an instance 
	of a prefab in the game, including information about the prefab's name and 
	whether it should be synchronized with the original prefab.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include <string>

namespace Popplio
{
	struct PrefabInstanceComponent
	{
		std::string prefabName;
		bool syncWithPrefab;

		PrefabInstanceComponent(const std::string& prefabName = "", bool sync = true)
			: prefabName(prefabName), syncWithPrefab(sync) {}
	};
}

================
File: PrefabManagement/PrefabManager.cpp
================
/******************************************************************************/
/*!
\file   PrefabManager.cpp
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief
	This source file implements the PrefabManager class within the Popplio namespace. 
	The PrefabManager class is responsible for managing prefabs, including registering, 
	retrieving, instantiating, updating, and deleting prefabs. It also handles the 
	association between prefabs and their file paths.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>

#include "PrefabManager.h"
#include "PrefabEvent.h"

#include <filesystem>

namespace Popplio
{
	PrefabManager::PrefabManager(EventBus& eventBus)
		: eventBus(eventBus)
	{

	}

	void PrefabManager::RegisterPrefab(const std::string& name, std::unique_ptr<Prefab> prefab, const std::string& filePath)
	{
		prefabs.insert_or_assign(name, std::move(prefab));
		if (!filePath.empty())
		{
			prefabPaths[name] = filePath;
		}
	}

	
	[[nodiscard]] std::optional<std::reference_wrapper<const Prefab>> PrefabManager::GetPrefab(const std::string& name) const
	{
		auto it = prefabs.find(name);
		if (it != prefabs.end())
		{
			return std::cref(*it->second);
		}

		return std::nullopt;
	}

	[[nodiscard]] std::optional<Entity> PrefabManager::InstantiatePrefab(Registry& registry, const std::string& prefabName)
	{
		if (auto prefabOpt = GetPrefab(prefabName))
		{
			return prefabOpt->get().Instantiate(registry, *this);
		}

		return std::nullopt;
	}

	template <typename... Args>
	void PrefabManager::CreateAndRegisterPrefab(const std::string& name, Args&&... args)
	{
		auto prefab = std::make_unique<Prefab>(name);
		prefab->AddComponent<Args>(std::forward<Args>(args)...);
		RegisterPrefab(name, std::move(prefab));
	}

	const std::unordered_map<std::string, std::unique_ptr<Prefab>>& PrefabManager::GetPrefabs() const noexcept
	{
		return prefabs;
	}

	bool PrefabManager::DeletePrefab(const std::string& name)
	{
		auto it = prefabs.find(name);
		if(it == prefabs.end())
		{
			Logger::Warning("Attempted to delete non-existent prefab: " + name, LogDestination::IMGUI_CONSOLE);
			return false;
		}

		// Get the file path before removing from map
		std::string filePath = GetPrefabFilePath(name);

		// Notify listeners such as PrefabSyncSystem
		eventBus.EmitEvent<PrefabEvent>(name, PrefabEventType::Deleted);

		// Remove from memory
		prefabs.erase(it);
		prefabPaths.erase(name);

		// Delete the file if it exists
		if (!filePath.empty())
		{
			return DeletePrefabFile(filePath);
		}

		Logger::Info("Deleted prefab from manager: " + name, LogDestination::IMGUI_CONSOLE);

		return true;
	}

	bool PrefabManager::DeletePrefabFile(const std::string& prefabPath)
	{
		try
		{
			if (std::filesystem::exists(prefabPath))
			{
				std::filesystem::remove(prefabPath);
				Logger::Info("Deleted prefab file: " + prefabPath, LogDestination::IMGUI_CONSOLE);
				return true;
			}
			return false;
		}
		catch (const std::exception& e)
		{
			Logger::Error("Failed to delete prefab file: " + prefabPath + " Error: " + e.what(), LogDestination::IMGUI_CONSOLE);
			return false;
		}
	}

	std::string PrefabManager::GetPrefabFilePath(const std::string& name) const
	{
		auto it = prefabPaths.find(name);
		if (it != prefabPaths.end())
		{
			return it->second;
		}

		return "";
	}

	void PrefabManager::UpdatePrefab(const std::string& name, std::unique_ptr<Prefab> updatedPrefab, const std::type_index& componentType)
	{
		// Normal update without rename
		prefabs[name] = std::move(updatedPrefab);
		eventBus.EmitEvent<PrefabEvent>(name, PrefabEventType::Modified, componentType);
		Logger::Debug("Updated prefab: " + name, LogDestination::IMGUI_CONSOLE);
	}

	bool PrefabManager::PrefabExists(const std::string& name) const
	{
		auto it = prefabPaths.find(name);
		if (it != prefabPaths.end())
		{
			return true;
		}
		return false;
	}
}

================
File: PrefabManagement/PrefabManager.h
================
/******************************************************************************/
/*!
\file   PrefabManager.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief
	This header file defines the PrefabManager class within the Popplio namespace. 
	The PrefabManager class is responsible for managing prefabs, including 
	registering, retrieving, instantiating, updating, and deleting prefabs. 
	It also handles the association between prefabs and their file paths.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once
#include "Prefab.h"
#include <unordered_map>
#include <memory>
#include <string>
#include <optional>
#include "../ECS/ECS.h"
#include "../Logging/Logger.h"
#include "../EventBus/EventBus.h"

// Forward declarations
namespace Popplio
{
	class Prefab;
}

namespace Popplio
{
	/**
  * \class PrefabManager
  * \brief Class responsible for managing prefabs.
  * 
  * The PrefabManager class is responsible for managing prefabs, including
  * registering, retrieving, instantiating, updating, and deleting prefabs.
  * It also handles the association between prefabs and their file paths.
  */
	class PrefabManager
	{
	public:
		/**
   * \brief Constructor for PrefabManager.
   * \param eventBus The event bus to be used by the PrefabManager.
   */
		PrefabManager(EventBus& eventBus);

		/**
   * \brief Registers a prefab with the given name and file path.
   * \param name The name of the prefab.
   * \param prefab The prefab to be registered.
   * \param filePath The file path of the prefab.
   */
		void RegisterPrefab(const std::string& name, std::unique_ptr<Prefab> prefab, const std::string& filePath = "");

		/**
   * \brief Retrieves a prefab with the given name.
   * \param name The name of the prefab to retrieve.
   * \return An optional reference to the retrieved prefab.
   */
		[[nodiscard]] std::optional<std::reference_wrapper<const Prefab>> GetPrefab(const std::string& name) const;

		/**
   * \brief Instantiates a prefab with the given name in the specified registry.
   * \param registry The registry to instantiate the prefab in.
   * \param prefabName The name of the prefab to instantiate.
   * \return An optional entity representing the instantiated prefab.
   */
		[[nodiscard]] std::optional<Entity> InstantiatePrefab(Registry& registry, const std::string& prefabName);

		/**
   * \brief Creates and registers a prefab with the given name and constructor arguments.
   * \tparam Args The types of the constructor arguments.
   * \param name The name of the prefab.
   * \param args The constructor arguments.
   */
		template <typename... Args>
		void CreateAndRegisterPrefab(const std::string& name, Args&&... args);

		/**
   * \brief Retrieves the map of registered prefabs.
   * \return A constant reference to the map of registered prefabs.
   */
		const std::unordered_map<std::string, std::unique_ptr<Prefab>>& GetPrefabs() const noexcept;
		
		/**
   * \brief Deletes a prefab with the given name.
   * \param name The name of the prefab to delete.
   * \return True if the prefab was successfully deleted, false otherwise.
   */
		bool DeletePrefab(const std::string& name);

		/**
   * \brief Deletes the file associated with the given prefab path.
   * \param prefabPath The path of the prefab file to delete.
   * \return True if the file was successfully deleted, false otherwise.
   */
		bool DeletePrefabFile(const std::string& prefabPath);

		/**
   * \brief Retrieves the file path associated with the given prefab name.
   * \param name The name of the prefab.
   * \return The file path associated with the prefab.
   */
		std::string GetPrefabFilePath(const std::string& name) const;

		/**
   * \brief Updates a prefab with the given name and updated prefab.
   * \param name The name of the prefab to update.
   * \param updatedPrefab The updated prefab.
   * \param componentType The type of the component to update.
   */
		void UpdatePrefab(const std::string& name, std::unique_ptr<Prefab> updatedPrefab, const std::type_index& componentType);

        bool PrefabExists(const std::string& name) const;

	private:
		EventBus& eventBus;
		// Map to store prefabs
		std::unordered_map<std::string, std::unique_ptr<Prefab>> prefabs;

		// Map to store prefab file paths
		std::unordered_map<std::string, std::string> prefabPaths;
	};
}

================
File: PrefabManagement/PrefabRef.h
================
/******************************************************************************/ 
/*! 
\file   PrefabRef.h 
\author Team Popplio 
\author Bryan Ang Wei Ze 
\contribution Bryan - 100% 
\par    Course : CSD2401 / UXGD2400 / DAA2402 
\par    Section : A 
\date   2025/02/06 
\brief
This file contains the definition of the PrefabRef class, which is used to reference prefabs in the game engine. 
The PrefabRef class includes properties for the prefab path, local position, local scale, and local rotation.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology. 
Reproduction or disclosure of this file or its contents 
without the prior written consent of DigiPen Institute of 
Technology is prohibited. 
*/ 
/******************************************************************************/
#pragma once
#include <string>
#include "../Math/Vector2D.h"

namespace Popplio
{
	class PrefabRef
	{
	public:
		PrefabRef(const std::string& prefabPath = "", const PopplioMath::Vec2f& pos = { 0, 0 },
			const PopplioMath::Vec2f& scl = { 1, 1 }, double rot = 0)
			: prefabPath(prefabPath), localPosition(pos), localScale(scl), localRotation(rot)
		{

		}
		std::string prefabPath;
		PopplioMath::Vec2f localPosition;
		PopplioMath::Vec2f localScale;
		double localRotation;
	};
}

================
File: PrefabManagement/PrefabSyncSystem.cpp
================
/******************************************************************************/
/*!
\file   PrefabSyncSystem.cpp
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief
	This source file implements the PrefabSyncSystem class within the Popplio 
	namespace. The PrefabSyncSystem class is responsible for synchronizing 
	entities with their corresponding prefabs. It handles events related to 
	prefab modifications and deletions, ensuring that any changes to prefabs 
	are propagated to their instances in the game world.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>
#include "PrefabSyncSystem.h"
#include "../Utilities/Components.h"

namespace Popplio
{
	PrefabSyncSystem::PrefabSyncSystem(Registry& reg, PrefabManager& prefabMgr)
		: reg(reg), prefabMgr(prefabMgr)
	{
		RequireComponent<PrefabInstanceComponent>();
	}

	void PrefabSyncSystem::SubscribeToEvents(EventBus& eventBus)
	{
		eventBus.SubscribeToEvent<PrefabEvent>(this, &PrefabSyncSystem::OnPrefabEvent);
		eventBus.SubscribeToEvent<SceneLoadedEvent>(this, &PrefabSyncSystem::OnSceneLoaded);
	}

	void PrefabSyncSystem::Update()
	{
		// Process any pending sync requests
		while (!syncQueue.empty())
		{
			ProcessSyncRequest(syncQueue.front());
			syncQueue.pop();
		}
	}

	void PrefabSyncSystem::OnSceneLoaded(SceneLoadedEvent& event)
	{
		Logger::Info("Scene loaded, synchronizing prefab instances: " + event.scenePath);

		for (auto entity : GetSystemEntities())
		{
			auto& instanceComponent = entity.GetComponent<PrefabInstanceComponent>();

			// Create a sync request for this prefab
			syncQueue.push(SyncRequest(
				instanceComponent.prefabName,
				PrefabEventType::Modified
			));
		}

		// Process all sync requests immediately
		Update();
	}

	void PrefabSyncSystem::OnPrefabEvent(PrefabEvent& event)
	{
		syncQueue.push(SyncRequest(event.prefabName, event.eventType, event.modifiedComponentType));
	}

	void PrefabSyncSystem::ProcessSyncRequest(const SyncRequest& request)
	{
		switch (request.eventType)
		{
		case PrefabEventType::Modified:
		{
			auto prefabOpt = prefabMgr.GetPrefab(request.prefabName);
			if (!prefabOpt)
			{
				Logger::Error("Cannot sync instances: Prefab not found: " + request.prefabName);
				return;
			}
			const Prefab& prefab = prefabOpt->get();

			for (auto entity : GetSystemEntities())
			{
				auto& instanceComponent = entity.GetComponent<PrefabInstanceComponent>();
				if (instanceComponent.prefabName == request.prefabName &&
					instanceComponent.syncWithPrefab)
				{
					if (request.modifiedComponentType)
					{
						// Sync only the modified component
						SyncSpecificComponent(entity, prefab, *request.modifiedComponentType);
					}
					else
					{
						// If no specific component was modified, sync all components
						SyncEntityWithPrefab(entity, prefab);
					}
				}
			}
			break;
		}
		case PrefabEventType::Deleted:
			HandlePrefabDeletion(request.prefabName);
			break;
		}
	}

	void PrefabSyncSystem::SyncSpecificComponent(Entity& entity, const Prefab& prefab, const std::type_index& componentType)
	{
		if (componentType == typeid(ActiveComponent))
		{
			SyncComponent<ActiveComponent>(entity, prefab);
		}
		else if (componentType == typeid(RenderComponent))
		{
			SyncComponent<RenderComponent>(entity, prefab);
		}
		else if (componentType == typeid(RigidBodyComponent))
		{
			SyncComponent<RigidBodyComponent>(entity, prefab);
		}
		else if (componentType == typeid(BoxColliderComponent))
		{
			SyncComponent<BoxColliderComponent>(entity, prefab);
		}
		else if (componentType == typeid(TextComponent))
		{
			SyncComponent<TextComponent>(entity, prefab);
		}
		else if (componentType == typeid(LogicComponent))
		{
			SyncComponent<LogicComponent>(entity, prefab);
		}
		else if (componentType == typeid(AudioComponent))
		{
			SyncComponent<AudioComponent>(entity, prefab);
		}
		else if (componentType == typeid(AnimationComponent))
		{
			SyncComponent<AnimationComponent>(entity, prefab);
		}
        else if (componentType == typeid(PersistOnLoadComponent))
        {
            SyncComponent<PersistOnLoadComponent>(entity, prefab);
        }
        else if (componentType == typeid(ParticleComponent))
        {
            SyncComponent<ParticleComponent>(entity, prefab);
        }
		else if (componentType == typeid(UIComponent))
		{
			SyncComponent<UIComponent>(entity, prefab);
		}
		else
		{
			Logger::Warning("Cannot sync component of type: " + std::string(componentType.name()),
				LogDestination::IMGUI_CONSOLE);
		}
	}

	void PrefabSyncSystem::SyncEntityWithPrefab(Entity& entity, const Prefab& prefab)
	{
		// Sync all components
		SyncComponent<ActiveComponent>(entity, prefab);
		SyncComponent<RenderComponent>(entity, prefab);
		SyncComponent<RigidBodyComponent>(entity, prefab);
		SyncComponent<BoxColliderComponent>(entity, prefab);
		SyncComponent<TextComponent>(entity, prefab);
		SyncComponent<LogicComponent>(entity, prefab);
		SyncComponent<AnimationComponent>(entity, prefab);
		SyncComponent<ActiveComponent>(entity, prefab);
		SyncComponent<AudioComponent>(entity, prefab);
        SyncComponent<PersistOnLoadComponent>(entity, prefab);
		SyncComponent<UIComponent>(entity, prefab);
        SyncComponent<ParticleComponent>(entity, prefab);
	}

	void PrefabSyncSystem::HandlePrefabDeletion(const std::string& prefabName)
	{
		int instancesDetached = 0;
		for (auto entity : GetSystemEntities())
		{
			auto& instanceComponent = entity.GetComponent<PrefabInstanceComponent>();
			if (instanceComponent.prefabName == prefabName)
			{
				entity.RemoveComponent<PrefabInstanceComponent>();
				++instancesDetached;
			}
		}

		if (instancesDetached > 0)
		{
			Logger::Warning("Detached " + std::to_string(instancesDetached) +
				" instances due to prefab deletion: " + prefabName,
				LogDestination::IMGUI_CONSOLE);
		}
	}
}

================
File: PrefabManagement/PrefabSyncSystem.h
================
/******************************************************************************/
/*!
\file   PrefabSyncSystem.h
\author Team Popplio
\author Bryan Ang Wei Ze
\contribution Bryan - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/02/06
\brief
	This header file defines the PrefabSyncSystem class within the Popplio namespace. 
	The PrefabSyncSystem class is responsible for synchronizing entities with their 
	corresponding prefabs. It listens for prefab events and processes synchronization 
	requests to update entities based on changes in the prefabs.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once
#include "../ECS/ECS.h"
#include "PrefabInstanceComponent.h"
#include "PrefabManager.h"
#include "PrefabEvent.h"
#include "../Logging/Logger.h"
#include "../EventBus/EventBus.h"
#include "../Serialization/SceneLoadedEvent.h"
#include <queue>

namespace Popplio
{
	/**
	* The PrefabSyncSystem class is responsible for synchronizing entities with their corresponding prefabs.
	* It listens for prefab events and processes sync requests to update entities based on the changes in the prefabs.
	*/
	class PrefabSyncSystem : public System
	{
	public:
		/**
		* Constructs a PrefabSyncSystem object.
		* @param reg The registry used to access entities and components.
		* @param prefabMgr The prefab manager used to retrieve prefabs.
		*/
		PrefabSyncSystem(Registry& reg, PrefabManager& prefabMgr);

		/**
		* Subscribes to prefab events from the event bus.
		* @param eventBus The event bus to subscribe to.
		*/
		void SubscribeToEvents(EventBus& eventBus);

		/**
		* Updates the PrefabSyncSystem.
		* This method is called every frame to process sync requests.
		*/
		void Update();

		void OnSceneLoaded(SceneLoadedEvent& event);

	private:
		Registry& reg; /**< The registry used to access entities and components. */
		PrefabManager& prefabMgr; /**< The prefab manager used to retrieve prefabs. */

		/**
		* Represents a sync request to update an entity based on changes in a prefab.
		*/
		struct SyncRequest
		{
			std::string prefabName; /**< The name of the prefab. */
			PrefabEventType eventType; /**< The type of prefab event. */
			std::optional<std::type_index> modifiedComponentType; /**< The type of the modified component, if applicable. */

			/**
			* Constructs a SyncRequest object.
			* @param name The name of the prefab.
			* @param type The type of prefab event.
			* @param componentType The type of the modified component, if applicable.
			*/
			SyncRequest(const std::string& name, PrefabEventType type, std::optional<std::type_index> componentType = std::nullopt)
				: prefabName(name), eventType(type), modifiedComponentType(componentType) {}
		};

		std::queue<SyncRequest> syncQueue; /**< The queue of sync requests to be processed. */

		/**
		* Handles the PrefabEvent.
		* @param event The PrefabEvent to handle.
		*/
		void OnPrefabEvent(PrefabEvent& event);

		/**
		* Processes a sync request.
		* @param request The sync request to process.
		*/
		void ProcessSyncRequest(const SyncRequest& request);

		/**
		* Syncs a specific component of an entity with the corresponding component in a prefab.
		* @param entity The entity to sync.
		* @param prefab The prefab to sync with.
		* @param componentType The type of the component to sync.
		*/
		void SyncSpecificComponent(Entity& entity, const Prefab& prefab, const std::type_index& componentType);

		/**
		* Syncs an entity with its corresponding prefab.
		* @param entity The entity to sync.
		* @param prefab The prefab to sync with.
		*/
		void SyncEntityWithPrefab(Entity& entity, const Prefab& prefab);

		/**
		* Syncs a component of an entity with the corresponding component in a prefab.
		* @tparam TComponent The type of the component to sync.
		* @param entity The entity to sync.
		* @param prefab The prefab to sync with.
		*/
		template <typename TComponent>
		void SyncComponent(Entity& entity, const Prefab& prefab);

		/**
		* Handles the deletion of a prefab.
		* @param prefabName The name of the prefab to handle deletion for.
		*/
		void HandlePrefabDeletion(const std::string& prefabName);
	};

	template <typename TComponent>
	void PrefabSyncSystem::SyncComponent(Entity& entity, const Prefab& prefab)
	{
		if (prefab.HasComponent<TComponent>())
		{
			const auto& prefabComponent = prefab.GetComponent<TComponent>();
			if (entity.HasComponent<TComponent>())
			{
				// Update existing component
				entity.GetComponent<TComponent>() = prefabComponent;
			}
			else
			{
				// Add component if it doesn't exist
				entity.AddComponent<TComponent>(prefabComponent);
			}
		}
		else if (entity.HasComponent<TComponent>())
		{
			// Remove component if prefab doesn't have it
			entity.RemoveComponent<TComponent>();
		}
	}
}

================
File: repomix.config.json
================
{
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  }
}

================
File: Runtime/RuntimeSystem.cpp
================
/******************************************************************************/
/*!
\file   Runtime.cpp
\author Team Popplio
\author Ng Jun Heng Shawn
\contribution Shawn - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/03/13 08:55:22 PM (Last Edit)
\brief
        This is the source file for engine runtime library

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contentsv
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#include <pch.h>

#include "RuntimeSystem.h"

#include "../Cloning/CloneSystem.h"

namespace Popplio
{
    RuntimeSystem::RuntimeSystem(Registry& r, EventBus& eBus, PopplioScriptAPI::MonoAPI& mono)
        : reg(r), eventBus(eBus), monoAPI(mono) {}

    namespace
    {
        // l-value required
        static CloneEntityEvent cloneEvent = CloneEntityEvent(-1);
    }

    //void RuntimeSystem::InstantiateEntity(int const& id)
    //{
    //    eventBus.EmitEvent<CloneEntityEvent>(id);
    //}
    int RuntimeSystem::InstantiateEntity(int const& id)
    {
        return reg.GetSystem<CloneSystem>().CloneEntity(cloneEvent = CloneEntityEvent(id)); // TODO test
    }
}

================
File: Runtime/RuntimeSystem.h
================
/******************************************************************************/
/*!
\file   Runtime.h
\author Team Popplio
\author Ng Jun Heng Shawn
\contribution Shawn - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/03/13 08:55:22 PM (Last Edit)
\brief
        This is the header file for engine runtime library

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contentsv
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once

#include "../ECS/ECS.h"
#include "../EventBus/EventBus.h"
#include "../Mono/MonoAPI.h"

namespace Popplio
{
    class RuntimeSystem : public System
    {
    private:
        Registry& reg;
        EventBus& eventBus;
        PopplioScriptAPI::MonoAPI& monoAPI;
    public:
        RuntimeSystem(Registry& r, EventBus& eBus, PopplioScriptAPI::MonoAPI& mono);

        //void InstantiateEntity(int const& id);

        /*
        *   instantiate entity
        */
        int InstantiateEntity(int const& id);
    };
}

================
File: Serialization/ChartEditorSerialization.cpp
================
/******************************************************************************/
/*!
\file           ChartEditorSerialization.cpp
\author         Team Popplio
\author         Val Tay Yun Ying
\co-author
\contribution   Val - 100%
\par            Course : CSD2401 / CSD2400
\par            Section : A
\date           2025/3/3
\brief
	This is the header file for the serializer of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#include "pch.h"
#include "ChartEditorSerialization.h"
#include "Windows.h"
namespace Popplio
{
	std::string ChartEditorSerialization::_fileExtension{ ".grookey" };

	bool ChartEditorSerialization::NewChart(LevelChart*& outLevel, std::string chartName, double songDuration, double bpm, int timeSigTop, int timeSigBot, std::string const& audioFilePath, std::string const& saveFilePath)
	{
		std::stringstream ss;
		ss << "Generating chart: " << chartName + _fileExtension << " at " << saveFilePath;
		Logger::Info(ss.str());
		outLevel = new LevelChart(chartName, songDuration, bpm, timeSigTop, timeSigBot, audioFilePath, saveFilePath);

		// save the document to this location
		std::string fileName = chartName + _fileExtension;
		Logger::Debug(saveFilePath + fileName);

		// open a new json document
		rapidjson::Document document;
		document.SetObject();
		auto& allocator = document.GetAllocator();

		rapidjson::StringBuffer buffer;
		rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);

		//rapidjson::Value levelVal{ rapidjson::kObjectType };
		//std::string stringRefName{ "chart" };

		// name of chart
		rapidjson::Value name{ rapidjson::kStringType };
		name.SetString(chartName.c_str(), allocator);
		document.AddMember("name", name, allocator);

		// duration of the song
		rapidjson::Value duration{ rapidjson::kObjectType };
		duration.SetDouble(songDuration);
		document.AddMember("duration", duration, allocator);

		// bpm of the song
		rapidjson::Value beatspm{ rapidjson::kObjectType };
		beatspm.SetDouble(bpm);
		document.AddMember("bpm", beatspm, allocator);

		// time sig of the song
		rapidjson::Value timeSigT{ rapidjson::kObjectType };
		timeSigT.SetInt(timeSigTop);
		document.AddMember("time sig top", timeSigT, allocator);

		rapidjson::Value timeSigB{ rapidjson::kObjectType };
		timeSigB.SetInt(timeSigBot);
		document.AddMember("time sig bot", timeSigB, allocator);

		// nfilepath of the audio
		rapidjson::Value audiopath{ rapidjson::kStringType };
		audiopath.SetString(audioFilePath.c_str(), allocator);
		document.AddMember("audio file path", audiopath, allocator);

		// chart file's save location
		rapidjson::Value savefile{ rapidjson::kStringType };
		savefile.SetString((saveFilePath + fileName).c_str(), allocator);
		document.AddMember("save file path", savefile, allocator);

		rapidjson::Value notes{ rapidjson::kArrayType };
		notes.SetArray();
		document.AddMember("notes", notes, allocator);

		//// adding the chart into the document
		//document.AddMember(rapidjson::StringRef(stringRefName.c_str()), levelVal, allocator);

		document.Accept(writer);


		std::ofstream outFile(saveFilePath + fileName);
		if (!outFile)
		{
			Logger::Error("Failed to open file for writing: " + fileName);
			return false;
		}

		outFile << buffer.GetString();
		outFile.close();

		return true;
	}

	bool ChartEditorSerialization::LoadChart(LevelChart*& outLevel, std::filesystem::path const& filePath)
	{

		// if the filepath given is not a .grookey file
		if (filePath.extension().string() != _fileExtension)
		{
			Logger::Warning("Given path is not a valid chart file! \nGiven file: " + filePath.string());
			return false;
		}

		//open file 
		std::ifstream inFile(filePath.string());
		if (!inFile)
		{
			Logger::Error("Failed to open file for reading: " + filePath.string());
			return false;
		}

		rapidjson::IStreamWrapper isw(inFile);
		rapidjson::Document chartDoc;
		chartDoc.ParseStream(isw);

		if (chartDoc.HasParseError())
		{
			Logger::Error("Failed to parse prefab JSON file: " + filePath.string(),
				LogDestination::WINDOWS_CONSOLE);

			inFile.close(); // added to fix error that cant save / load after
			return false;
		}

		outLevel->chartName = chartDoc["name"].GetString();
		outLevel->songDuration = chartDoc["duration"].GetDouble();
		outLevel->bpm = chartDoc["bpm"].GetDouble();
		outLevel->timeSig[0] = chartDoc["time sig top"].GetInt();
		outLevel->timeSig[1] = chartDoc["time sig bot"].GetInt();
		outLevel->audioFilePath = chartDoc["audio file path"].GetString();
		outLevel->chartSavePath = chartDoc["save file path"].GetString();

		auto notesArray = chartDoc["notes"].GetArray();
		std::vector<Note> noteVector;
		for (const auto& note : notesArray)
		{
			Note newNote = Note();
			newNote.id = note["id"].GetInt();
			//newNote.barstart = note["barstart"].GetInt();
			newNote.bar = note["bar"].GetInt();
			newNote.beat = note["beat"].GetFloat();
			newNote.beatLength = note["beatlength"].GetFloat();
			newNote.lane = note["lane"].GetInt();
			newNote.noteType = (Note::NOTETYPE)note["notetype"].GetInt();
			newNote.rainbow = note["rainbow"].GetBool();
			newNote.spriteID = note["spriteid"].GetInt();

			noteVector.push_back(newNote);
		}

		outLevel->notesList = noteVector;


		return true;
	}

	void SortNotes(std::vector<Note>& notesList)
	{
		auto compareNotesLambda = [](const Note& a, const Note& b) {
			if (a.bar != b.bar) {
				return a.bar < b.bar;
			}
			return a.beat < b.beat;
			};

		std::sort(notesList.begin(), notesList.end(), compareNotesLambda);
	}

	bool ChartEditorSerialization::SaveChart(LevelChart* const& level)
	{
		//sort the notes in the level according to note position & beat first
		//std::vector<Note> sortedNotes{ level->notesList };
		//sortedNotes.reserve(level->notesList.size());

		SortNotes(level->notesList);


		std::stringstream ss;
		ss << "Generating chart: " << level->chartName + _fileExtension << " at " << level->chartSavePath;
		Logger::Info(ss.str());

		// save the document to this location
		std::string fileName = level->chartName + _fileExtension;
		Logger::Debug(level->chartSavePath + fileName);

		// open a new json document
		rapidjson::Document document;
		document.SetObject();
		auto& allocator = document.GetAllocator();


		rapidjson::StringBuffer buffer;
		rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);

		//rapidjson::Value levelVal{ rapidjson::kObjectType };
		//std::string stringRefName{ "chart" };

		// name of chart
		rapidjson::Value name{ rapidjson::kStringType };
		name.SetString(level->chartName.c_str(), allocator);
		document.AddMember("name", name, allocator);

		// duration of the song
		rapidjson::Value duration{ rapidjson::kObjectType };
		duration.SetDouble(level->songDuration);
		document.AddMember("duration", duration, allocator);

		// bpm of the song
		rapidjson::Value bpm{ rapidjson::kObjectType };
		bpm.SetDouble(level->bpm);
		document.AddMember("bpm", bpm, allocator);

		// time sig of the song
		rapidjson::Value timeSigTop{ rapidjson::kObjectType };
		timeSigTop.SetInt(level->timeSig[0]);
		document.AddMember("time sig top", timeSigTop, allocator);

		rapidjson::Value timeSigBot{ rapidjson::kObjectType };
		timeSigBot.SetInt(level->timeSig[1]);
		document.AddMember("time sig bot", timeSigBot, allocator);

		// nfilepath of the audio
		rapidjson::Value audiopath{ rapidjson::kStringType };
		audiopath.SetString(level->audioFilePath.c_str(), allocator);
		document.AddMember("audio file path", audiopath, allocator);

		// chart file's save location
		rapidjson::Value savefile{ rapidjson::kStringType };
		savefile.SetString(level->chartSavePath.c_str(), allocator);
		document.AddMember("save file path", savefile, allocator);

		rapidjson::Value notes{ rapidjson::kArrayType };
		notes.SetArray();

		// lambda for saving notes
		auto addNoteMember = [&allocator, &notes, &level, &document](int index)
			{
				rapidjson::Value note{ rapidjson::kObjectType };

				//1 
				rapidjson::Value id{ rapidjson::kNumberType };
				id.SetInt(index);
				note.AddMember("id", id, allocator);

				////2
				//rapidjson::Value barstart{ rapidjson::kNumberType };
				//barstart.SetInt(level->notesList[index].barstart);
				//note.AddMember("barstart", barstart, allocator);

				//3
				rapidjson::Value bar{ rapidjson::kNumberType };
				bar.SetInt(level->notesList[index].bar);
				note.AddMember("bar", bar, allocator);

				//4
				rapidjson::Value beat{ rapidjson::kNumberType };
				beat.SetFloat(level->notesList[index].beat);
				note.AddMember("beat", beat, allocator);

				////5
				//rapidjson::Value beatFractionTop{ rapidjson::kNumberType };
				//beatFractionTop.SetInt(level->notesList[index].beatFractionTop);
				//note.AddMember("beatfractiontop", beatFractionTop, allocator);

				////6
				//rapidjson::Value beatFractionBot{ rapidjson::kNumberType };
				//beatFractionBot.SetInt(level->notesList[index].beatFractionBot);
				//note.AddMember("beatfractionbot", beatFractionBot, allocator);

				//7
				rapidjson::Value beatLength{ rapidjson::kNumberType };
				beatLength.SetFloat(level->notesList[index].beatLength);
				note.AddMember("beatlength", beatLength, allocator);

				////8
				//rapidjson::Value beatLengthFractionTop{ rapidjson::kNumberType };
				//beatLengthFractionTop.SetInt(level->notesList[index].beatLengthFractionTop);
				//note.AddMember("beatlengthfractiontop", beatLengthFractionTop, allocator);

				////9
				//rapidjson::Value beatLengthFractionBot{ rapidjson::kNumberType };
				//beatLengthFractionBot.SetInt(level->notesList[index].beatLengthFractionBot);
				//note.AddMember("beatlengthfractionbot", beatLengthFractionBot, allocator);

				//10
				rapidjson::Value lane{ rapidjson::kNumberType };
				lane.SetInt(level->notesList[index].lane);
				note.AddMember("lane", lane, allocator);

				//11
				rapidjson::Value noteType{ rapidjson::kNumberType };
				noteType.SetInt(level->notesList[index].noteType);
				note.AddMember("notetype", noteType, allocator);

				//12
				rapidjson::Value rainbow{ rapidjson::kObjectType };
				rainbow.SetBool(level->notesList[index].rainbow);
				note.AddMember("rainbow", rainbow, allocator);

				//13
				rapidjson::Value spriteID{ rapidjson::kNumberType };
				spriteID.SetInt(level->notesList[index].spriteID);
				note.AddMember("spriteid", spriteID, allocator);

				notes.PushBack(note, allocator);
			};

		for (size_t i = 0; i < level->notesList.size(); ++i)
		{
			addNoteMember(static_cast<int>(i));
		}

		document.AddMember("notes", notes, allocator);

		document.Accept(writer);

		std::cout << level->chartSavePath + fileName << std::endl;
		std::ofstream outFile(level->chartSavePath + fileName);
		if (!outFile)
		{
			Logger::Error("Failed to open file for writing: " + fileName);
			return false;
		}

		outFile << buffer.GetString();
		outFile.close();

		return true;
	}

}

================
File: Serialization/ChartEditorSerialization.h
================
/******************************************************************************/
/*!
\file           ChartEditorSerialization.h
\author         Team Popplio
\author         Val Tay Yun Ying
\co-author
\contribution   Val - 100%
\par            Course : CSD2401 / CSD2400
\par            Section : A
\date           2025/3/3
\brief
	This is the header file for the serializer of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#include <rapidjson/document.h>
#include <rapidjson/prettywriter.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/istreamwrapper.h>

#include "../ChartEditor/LevelChart.h"

namespace Popplio
{
	class ChartEditorSerialization
	{
	public:
		static std::string _fileExtension;

		// New chart (Serialize new .Grookey file)
		static bool NewChart(LevelChart*& outLevel, std::string chartName, double songDuration, double bpm, int timeSigTop, int timeSigBot, std::string const& audioFilePath, std::string const& saveFilePath);

		// Load chart (Deserialize)
		static bool LoadChart(LevelChart*& outLevel, std::filesystem::path const& filePath);

		// Save chart (Serialize)
		static bool SaveChart(LevelChart* const& level);

	};
}

================
File: Serialization/SceneLoadedEvent.h
================
#pragma once
#include "../EventBus/Event.h"
#include <string>

namespace Popplio
{
	// Event triggered when a scene has finished loading
	struct SceneLoadedEvent : public Event
	{
		std::string scenePath;
		SceneLoadedEvent(const std::string& name) : scenePath(name) {}
	};
}

================
File: Serialization/Serialization.cpp
================
/******************************************************************************/
/*!
\file			Serialization.cpp
\author         Team Popplio
\author         Bryan Ang Wei Ze
\co-author      Hafawati Binte Mohd Ali | Ng Jun Heng Shawn | Shannon
\contribution   Bryan - 65%, Hafawati - 20%, Shawn - 10%, Shannon - 5%
\par            Course : CSD2401 / CSD2400
\par            Section : A
\date           2025/03/13
\brief
	This is the source file for the serializer of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#include <pch.h>

#include "Serialization.h"

#include <rapidjson/istreamwrapper.h>
#include <rapidjson/ostreamwrapper.h>
#include <rapidjson/prettywriter.h>

#include "../PrefabManagement/PrefabSyncSystem.h"
#include "../Hierarchy/HierarchySystem.h"
#include "../Engine/Engine.h"
#include "../Serialization/ChartEditorSerialization.h"
#include "../PerformanceViewer/PerformanceViewer.h"

#include "../Cloning/CloneSystem.h"

#include <filesystem>

namespace Popplio
{
	Serializer::Serializer(Registry& reg, LayerManager& layerMgr, PrefabManager& prefabMgr, EventBus& eventBus)
		: registry(reg), configuration(), layerManager(layerMgr), prefabManager(prefabMgr), eventBus(eventBus)
	{

	}

	bool Serializer::LoadSceneFromFile(const std::string& filename, CameraManager& cameraMgr, const bool& clearPersistent)
	{
		PerformanceViewer::GetInstance()->start("Serializer");
		std::filesystem::current_path(std::filesystem::path(Popplio::Engine::programPath));

		Logger::Info("Loading scene data from file: " + filename);

		std::ifstream ifs(filename);
		if (!ifs)
		{
			Logger::Error("Error opening file: " + filename + " for reading");
			std::filesystem::current_path(std::filesystem::path(Popplio::Engine::programPath));
			return false;
		}

		//registry.GetSystem<LogicSystem>().monoAPI.UnloadAssembly();

		std::set<Popplio::Entity> persistent{};

		// Clear existing scene before loading new one
		persistent = ClearCurrentScene(clearPersistent);

		rapidjson::IStreamWrapper isw(ifs);
		document.ParseStream(isw);

		if (document.HasParseError())
		{
			Logger::Error("JSON parse error: " + std::to_string(document.GetParseError()));
			std::filesystem::current_path(std::filesystem::path(Popplio::Engine::programPath));
			return false;
		}

		// Persistent doesnt work currently

		registry.ClearFreeIds();
		//if (clearPersistent) registry.ResetEntityComponentSignatures();
		registry.ResetEntityComponentSignatures();

		//     std::vector<Popplio::Signature> signatures = 
				 //registry.StashPersistentEntities(persistent); // Stash persistent entities before deserializing scene entities

			 //else
			 //{
			 //	int entIndex = document["entities"].GetArray().Size();

			 //	for (Entity e : persistent)
			 //	{
			 //		CloneEntityEvent cloneEvent(e.GetId(), entIndex++);
			 //		registry.GetSystem<CloneSystem>().CloneEntity(cloneEvent);
			 //		e.Kill(); // kill queue
			 //	}

			 //	registry.Update();
			 //}

			 ////registry.KillAllEntities();
			 ////registry.ResetEntityComponentSignatures();
			 //registry.ClearFreeIds();

		registry.Update();

		// reset mono if we are loading a new scene at runtime
		if (!clearPersistent)
		{
			registry.GetSystem<LogicSystem>().monoAPI.CallMethod(
				registry.GetSystem<LogicSystem>().monoAPI.GetAssClass(
					"Team_Popplio.ECS", "Entity"), "ResetEntities");
			registry.GetSystem<LogicSystem>().monoAPI.CallMethod(
				registry.GetSystem<LogicSystem>().monoAPI.GetAssClass(
					"Team_Popplio", "PopplioMonoScript"), "ResetScripts");

			//registry.GetSystem<LogicSystem>().monoAPI.ClearAllGC();
		}

		DeserializeLayers();
		DeserializeEntities();
		DeserializeCameraSettings(cameraMgr);

		//registry.RestorePersistentEntities(signatures); // Restore persistent entities after deserializing scene

		// Emit event when scene loading is complete
		eventBus.EmitEvent<SceneLoadedEvent>(filename);

		ifs.close();

		//registry.GetSystem<LogicSystem>().monoAPI.StartMono();

		Logger::Info("Successfully loaded level data from: " + filename);
		std::filesystem::current_path(std::filesystem::path(Popplio::Engine::programPath));
		PerformanceViewer::GetInstance()->end("Serializer");

		Logger::Info("Scene Load | Time taken: " +
			std::to_string(PerformanceViewer::GetInstance()->GetSystemTime("Serializer").count() / 1000000.0) +
			" seconds");

		return true;
	}

	bool Serializer::LoadConfiguration(const std::string& filename)
	{
		std::ifstream ifs(filename);
		if (!ifs)
		{
			Logger::Error("Error opening file: " + filename + " for reading");
			return false;
		}

		rapidjson::IStreamWrapper isw(ifs);
		document.ParseStream(isw);

		if (document.HasParseError())
		{
			Logger::Error("JSON parse error: " + std::to_string(document.GetParseError()));
			return false;
		}

		if (!document.IsObject())
		{
			Logger::Error("Invalid JSON structure");
			return false;
		}

        if (document.HasMember("engine version") && document["engine version"].IsString())
        {
            configuration.engineVer = document["engine version"].GetString();
        }

        if (document.HasMember("app version") && document["app version"].IsString())
        {
            configuration.appVer = document["app version"].GetString();
        }

		if (document.HasMember("window width") && document["window width"].IsInt())
		{
			configuration.width = document["window width"].GetInt();
		}

		if (document.HasMember("window height") && document["window height"].IsInt())
		{
			configuration.height = document["window height"].GetInt();
		}

		if (document.HasMember("v-sync") && document["v-sync"].IsBool())
		{
			configuration.vSync = document["v-sync"].GetBool();
		}

		if (document.HasMember("safe mode") && document["safe mode"].IsBool())
		{
			configuration.safeMode = document["safe mode"].GetBool();
		}

		if (document.HasMember("last scene") && document["last scene"].IsString())
		{
			configuration.lastScene = document["last scene"].GetString();
		}

		if (document.HasMember("start scene") && document["start scene"].IsString())
		{
			configuration.startScene = document["start scene"].GetString();
		}

        if (document.HasMember("verbose") && document["verbose"].IsBool())
        {
            configuration.verbose = document["verbose"].GetBool();
        }

		std::ostringstream config;
		config << "Loaded configuration ~ "
            << "Engine Version: " << configuration.engineVer
            << ", App Version: " << configuration.appVer
			<< ", Window: " << configuration.width << "x" << configuration.height
			<< ", V-Sync: " << (configuration.vSync ? "On" : "Off")
			<< ", Safe Mode: " << (configuration.safeMode ? "On" : "Off")
			<< ", Last Scene: " << (configuration.lastScene)
			<< ", Start Scene: " << (configuration.startScene)
			<< ", Verbose: " << (configuration.verbose ? "On" : "Off");
		Logger::Info(config.str());

		ifs.close(); // added to fix error that cant save / load after

		return true;
	}

#pragma region REWORKING


	////TODO: this function should not be used anymore, this should be handled by the AssetLoader class
	//bool Serializer::LoadAsset(const std::string& filename, AudioSystem& audioSystem, LogicSystem& logicSystem)
	//{
	//	std::ifstream ifs(filename);
	//	if (!ifs)
	//	{
	//		Logger::Error("Error opening file: " + filename + " for reading");
	//		return false;
	//	}

	//	rapidjson::IStreamWrapper isw(ifs);
	//	document.ParseStream(isw);

	//	if (document.HasParseError())
	//	{
	//		Logger::Error("JSON parse error: " + std::to_string(document.GetParseError()));
	//		ifs.close(); // added to fix error that cant save / load after
	//		return false;
	//	}

	//	if (!document.IsObject())
	//	{
	//		Logger::Error("Invalid JSON structure");
	//		ifs.close(); // added to fix error that cant save / load after
	//		return false;
	//	}
	//	// Load different asset types
	//	//if (document.HasMember("Texture") && document["Texture"].IsArray()) {
	//	//	if (!LoadTextures(document["Texture"])) return false;
	//	//}

	//	//if (document.HasMember("Shader") && document["Shader"].IsArray()) {
	//	//	if (!LoadShaders(document["Shader"])) return false;
	//	//}

	//	/*if (document.HasMember("Font") && document["Font"].IsArray()) {
	//		if (!LoadFonts(document["Font"])) return false;
	//	}*/

	//	if (document.HasMember("Audio") && document["Audio"].IsArray()) {
	//		if (!LoadAudio(document["Audio"], audioSystem)) return false;
	//	}

		//if (document.HasMember("Logic") && document["Logic"].IsArray()) {
		//	if (!LoadCPPScripts(document["Logic"], logicSystem)) return false;
		//}

		//if (document.HasMember("Prefab") && document["Prefab"].IsArray()) {
		//	if (!LoadPrefabs(document["Prefab"])) return false;
		//}

	//	ifs.close(); // added to fix error that cant save / load after

	//	return true;
	//}

	//bool Serializer::LoadTextures(const rapidjson::Value& texturesArray) {
	//	for (const auto& texturePath : texturesArray.GetArray()) {
	//		if (!texturePath.IsString()) continue;

	//		std::string path = texturePath.GetString();
	//		std::string assetName = GenerateAssetName(path);

	//		try {
	//			AssetStore::StoreTextureAsset(
	//				assetName,
	//				Texture(path).GetTextureID()
	//			);
	//			Logger::Info("Loaded texture: " + path);
	//		}
	//		catch (const std::exception&) {
	//			Logger::Error("Failed to load texture: " + path);
	//			return false;
	//		}
	//	}
	//	return true;
	//}

	//bool Serializer::LoadShaders(const rapidjson::Value& shadersArray) {
	//	for (const auto& shaderPath : shadersArray.GetArray()) {
	//		if (!shaderPath.IsString()) continue;

	//		std::string path = shaderPath.GetString();
	//		std::string assetName = GenerateAssetName(path);

	//		try {
	//			AssetStore::StoreShaderAsset(
	//				assetName,
	//				std::make_unique<Shader>(path)
	//			);
	//			Logger::Info("Loaded shader: " + path);
	//		}
	//		catch (const std::exception&) {
	//			Logger::Error("Failed to load shader: " + path);
	//			return false;
	//		}
	//	}
	//	return true;
	//}

	//bool Serializer::LoadFonts(const rapidjson::Value& fontsArray) {
	//	for (const auto& fontPath : fontsArray.GetArray()) {
	//		if (!fontPath.IsObject()) continue;

	//		// Retrieve the font path
	//		if (!fontPath.HasMember("path") || !fontPath["path"].IsString()) {
	//			Logger::Error("Font resource missing 'path' or 'path' is not a string.");
	//			continue;
	//		}
	//		std::string path = fontPath["path"].GetString();


	//}


	//bool Serializer::LoadAudio(const rapidjson::Value& audioArray, AudioSystem& audioSystem)
	//{
	//	for (const auto& audio : audioArray.GetArray()) {
	//		if (!audio.IsObject()) continue;

	//		std::string path = audio["path"].GetString();
	//		std::string key = audio["key"].GetString();
	//		int channelGroup = audio["channelGroup"].GetInt();

	//		try {
	//			audioSystem.SetAudio(path.c_str(), key, audioSystem.GetCGroup(channelGroup), beatsPM, timeSignature);
	//			Logger::Info("Loaded audio: " + path);
	//		}
	//		catch (const std::exception&) {
	//			Logger::Error("Failed to load audio: " + path);
	//			return false;
	//		}
	//	}
	//	return true;
	////}

	bool Serializer::LoadPrefabs(const rapidjson::Value& prefabsArray)
	{
		for (const auto& prefabPath : prefabsArray.GetArray())
		{
			if (!prefabPath.IsString()) continue;

			std::string path = prefabPath.GetString();
			auto loadedPrefab = LoadPrefabFromFile(path);

			if (loadedPrefab)
			{
				// Register with absolute file path
				prefabManager.RegisterPrefab(
					loadedPrefab->GetName(),
					std::make_unique<Prefab>(*loadedPrefab),
					std::filesystem::absolute(std::filesystem::path(path)).string()
				);
				Logger::Info("Prefab loaded successfully from: " + path, LogDestination::IMGUI_CONSOLE);
			}
			else
			{
				Logger::Error("Failed to load prefab from: " + path, LogDestination::IMGUI_CONSOLE);
				return false;
			}
		}

		return true;
	}

	//bool Serializer::LoadCPPScripts(const rapidjson::Value& logicArray, LogicSystem& logicSystem) // C++ scripts
	//{
	//	for (const auto& script : logicArray.GetArray()) {
	//		if (!script.IsObject()) continue;

	//		std::string scriptClass = script["class"].GetString();

	//		try
	//		{
	//			logicSystem.LoadByName(scriptClass);
	//			Logger::Info("Loaded script: " + scriptClass);
	//		}
	//		catch (const std::exception&) {
	//			Logger::Error("Failed to load script: " + scriptClass);
	//			return false;
	//		}
	//	}
	//	return true;
	//}
#pragma endregion

	std::string Serializer::GenerateAssetName(const std::string& filepath) {
		// Extract filename without extension
		size_t lastSlash = filepath.find_last_of("/\\");
		size_t lastDot = filepath.find_last_of(".");

		std::string filename = filepath.substr(
			lastSlash + 1,
			lastDot - lastSlash - 1
		);
		return filename;
	}

	bool Serializer::SerializeMetaFile(const std::filesystem::path& filename)
	{
		std::string fileExtension = filename.filename().string().substr(filename.filename().string().find('.'));
		std::string fileNoExtension = filename.string().substr(0, filename.string().find('.'));
		std::string metaFileName = filename.string().substr(0, filename.string().find('.')) + AssetLoader::_metaExtension;
		bool isSerializable = false;


		rapidjson::Document document;
		document.SetObject();
		auto& allocator = document.GetAllocator();

		rapidjson::StringBuffer buffer;
		rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);

		rapidjson::Value metaVal{ rapidjson::kObjectType };
		std::string stringRefName{};
		if (fileExtension == ".wav")
		{
			stringRefName = "Audio";
			rapidjson::Value metaMetaVal{ rapidjson::kNumberType };
			if (filename.filename().string().find("sfx") != std::string::npos)
			{
				metaMetaVal.SetInt(2);
				metaVal.AddMember(rapidjson::StringRef("channelGroup"), metaMetaVal, allocator);
			}
			else
			{
				metaMetaVal.SetInt(1);
				metaVal.AddMember(rapidjson::StringRef("channelGroup"), metaMetaVal, allocator);
				metaMetaVal.SetFloat(75.0);
				metaVal.AddMember(rapidjson::StringRef("beatsPM"), metaMetaVal, allocator);

				rapidjson::Value arrayVal{ rapidjson::kArrayType };
				arrayVal.SetArray();
				arrayVal.PushBack(4, allocator);
				arrayVal.PushBack(4, allocator);
				metaVal.AddMember(rapidjson::StringRef("timeSignature"), arrayVal, allocator);
			}
			isSerializable = true;
		}
		else if (fileExtension == ".ttf")
		{
			stringRefName = "Font";
			rapidjson::Value metaMetaVal{ rapidjson::kArrayType };
			metaMetaVal.SetArray();
			//[8, 12, 16, 24, 32, 48, 72, 96]
			metaMetaVal.PushBack(8, allocator);
			metaMetaVal.PushBack(12, allocator);
			metaMetaVal.PushBack(16, allocator);
			metaMetaVal.PushBack(24, allocator);
			metaMetaVal.PushBack(32, allocator);
			metaMetaVal.PushBack(48, allocator);
			metaMetaVal.PushBack(72, allocator);
			metaMetaVal.PushBack(96, allocator);
			metaVal.AddMember(rapidjson::StringRef("sizes"), metaMetaVal, allocator);
			isSerializable = true;

		}
		else if (fileExtension == ".png")
		{
			stringRefName = "Image";
			isSerializable = true;
		}
		else if (fileExtension == ".vert" || fileExtension == ".frag")
		{
			stringRefName = "Shader";
			//check if either one of the shaders dont exist
			if (!std::filesystem::exists(std::filesystem::path(fileNoExtension + ".frag")) || !std::filesystem::exists(std::filesystem::path(fileNoExtension + ".vert")))
			{
				Logger::Error("Shader file missing one of the pair! File we have: " + filename.string());
				return false;
			}
			isSerializable = true;

		}
		else if (fileExtension == ".cpp" || fileExtension == ".h")
		{
			stringRefName = "Script";

			rapidjson::Value metametaVal{ rapidjson::kStringType };

			std::ifstream ifs;
			ifs.open(filename);
			if (!ifs.is_open())
			{
				ifs.close();
				Logger::Error("Unable to read script: " + filename.string());
			}

			std::string extractedClass{};
			while (getline(ifs, extractedClass))
			{
				if (extractedClass.find("class") != std::string::npos)
				{
					break;
				}
			}
			ifs.close();

			// want the word after "class"
			std::stringstream ss{ extractedClass };
			std::list<std::string> classless;
			std::string token;
			while (ss >> token)
			{
				classless.push_back(token);
			}

			std::string className;
			for (std::list<std::string>::iterator it = classless.begin(); it != classless.end(); ++it)
			{
				if (*it != "class")continue;

				//next one is the 
				className = *(++it);
			}
			className = "BassNKick::" + className;
			metametaVal.SetString(className.c_str(), allocator);
			metaVal.AddMember(rapidjson::StringRef("class"), metametaVal, allocator);


			isSerializable = true;
		}
		else if (fileExtension == ".scene")
		{
			stringRefName = "Scene";
			isSerializable = true;
		}

		if (isSerializable)
		{
			std::ofstream outFile(metaFileName);
			if (!outFile)
			{
				Logger::Error("Failed to open file for writing: " + metaFileName);
				return false;
			}
			document.AddMember(rapidjson::StringRef(stringRefName.c_str()), metaVal, allocator);

			document.Accept(writer);
			outFile << buffer.GetString();
			outFile.close();
		}

		return true;
	}

	bool Serializer::DeserializeMetaFile(const std::filesystem::path& filename)
	{
		if (!AssetLoader::IsAsset(filename.filename().string()))
			return true;

		// Use replace_extension to construct the meta file path
		std::filesystem::path metaFileName = filename;
		metaFileName.replace_extension(AssetLoader::_metaExtension);

		// Open file using RAII
		std::ifstream inFile(metaFileName);
		if (!inFile) {
			Logger::Error("Failed to open file for reading: " + metaFileName.string());
			return false;
		}

		// Parse JSON
		rapidjson::Document metaDoc;
		{
			rapidjson::IStreamWrapper isw(inFile);
			metaDoc.ParseStream(isw);
		}

		if (metaDoc.HasParseError()) {
			Logger::Error("Failed to parse prefab JSON file: " + metaFileName.string(), LogDestination::WINDOWS_CONSOLE);
			return false;
		}

		// Determine file extension
		std::string fileExtension = filename.extension().string();

		try {
			// Use structured bindings to avoid repeated lookups
			if (fileExtension == ".wav") {
				if (!metaDoc.HasMember("Audio")) {
					Logger::Error("Invalid audio meta file: " + metaFileName.string());
					return false;
				}

				const auto& audioMeta = metaDoc["Audio"];
				int channelGroup = audioMeta.HasMember("channelGroup") ? audioMeta["channelGroup"].GetInt() : 0;
				float beatsPM = audioMeta.HasMember("beatsPM") ? audioMeta["beatsPM"].GetFloat() : 0.0f;

				std::pair<int, int> timeSignature = { 4, 4 }; // Default
				if (audioMeta.HasMember("timeSignature") && audioMeta["timeSignature"].IsArray()) {
					const auto& tsArray = audioMeta["timeSignature"].GetArray();
					timeSignature = { tsArray[0].GetInt(), tsArray[1].GetInt() };
				}

				return AssetLoader::LoadAudio(
					filename.string().c_str(),
					Serializer::GenerateAssetName(filename.filename().string()),
					channelGroup, beatsPM, timeSignature
				);
			}

			if (fileExtension == ".ttf") {
				if (!metaDoc.HasMember("Font") || !metaDoc["Font"].HasMember("sizes") || !metaDoc["Font"]["sizes"].IsArray()) {
					Logger::Error("Invalid font meta file: " + metaFileName.string());
					return false;
				}

				std::list<unsigned int> fontSizes;
				for (const auto& size : metaDoc["Font"]["sizes"].GetArray()) {
					fontSizes.push_back(size.GetUint());
				}

				return AssetLoader::LoadFont(filename.string(), fontSizes);
			}

			if (fileExtension == ".png") {
				if (!metaDoc.HasMember("Image")) {
					Logger::Error("Invalid image meta file: " + metaFileName.string());
					return false;
				}
				return AssetLoader::LoadTexture(filename.string());
			}

			if (fileExtension == ".vert" || fileExtension == ".frag") {
				if (!metaDoc.HasMember("Shader")) {
					Logger::Error("Invalid shader meta file: " + metaFileName.string());
					return false;
				}
				return AssetLoader::LoadShader(filename.string());
			}

			if (fileExtension == ".cpp" || fileExtension == ".h") {
				if (!metaDoc.HasMember("Script") || !metaDoc["Script"].HasMember("class")) {
					Logger::Error("Invalid script meta file: " + metaFileName.string());
					return false;
				}

				return AssetLoader::LoadCPPScripts(metaDoc["Script"]["class"].GetString());
			}

			if (fileExtension == ".scene") {
				if (!metaDoc.HasMember("Scene")) {
					Logger::Error("Invalid scene meta file: " + metaFileName.string());
					return false;
				}
				return AssetLoader::LoadScene(filename.string());
			}

			Logger::Warning("Unsupported asset type: " + fileExtension);
			return false;
		}
		catch (const std::exception& e) {
			Logger::Error("Exception while processing meta file: " + metaFileName.string() + " - " + e.what());
			return false;
		}
	}

	std::unique_ptr<Prefab> Serializer::LoadPrefabFromFile(const std::string& filename)
	{
		// Store full path for child prefab resolution
		std::unordered_set<std::string> loadedPrefabs;
		return LoadPrefabFromFileInternal(filename, loadedPrefabs);
	}

	std::unique_ptr<Prefab> Serializer::LoadPrefabFromFileInternal(const std::string& filename,
		std::unordered_set<std::string>& loadedPrefabs)
	{
		// Prevent circular dependencies by checking absolute paths
		std::filesystem::path absolutePath = std::filesystem::absolute(filename);
		if (loadedPrefabs.find(absolutePath.string()) != loadedPrefabs.end()) {
			Logger::Error("Circular prefab dependency detected: " + filename);
			return nullptr;
		}
		loadedPrefabs.insert(absolutePath.string());

		std::ifstream ifs(filename);
		if (!ifs) {
			Logger::Error("Failed to open prefab file: " + filename);
			return nullptr;
		}

		rapidjson::IStreamWrapper isw(ifs);
		rapidjson::Document prefabDoc;
		prefabDoc.ParseStream(isw);
		ifs.close();

		if (prefabDoc.HasParseError() || !prefabDoc.HasMember("prefab")) {
			Logger::Error("Invalid prefab file: " + filename);
			return nullptr;
		}

		const auto& prefabData = prefabDoc["prefab"];
		if (!prefabData.HasMember("name") || !prefabData.HasMember("components")) {
			Logger::Error("Invalid prefab structure in: " + filename);
			return nullptr;
		}

		// Create base prefab
		std::string prefabName = prefabData["name"].GetString();
		auto prefab = std::make_unique<Prefab>(prefabName);

		// Deserialize components
		DeserializePrefabComponents(*prefab, prefabData["components"]);

		// Handle child prefabs if present
		if (prefabData.HasMember("childPrefabs") && prefabData["childPrefabs"].IsArray()) {
			std::filesystem::path parentDir = std::filesystem::path(filename).parent_path();

			for (const auto& childRef : prefabData["childPrefabs"].GetArray()) {
				if (!childRef.HasMember("path")) {
					Logger::Warning("Child prefab missing path in: " + filename);
					continue;
				}

				// Construct absolute path for child prefab
				std::filesystem::path childPath = parentDir / childRef["path"].GetString();

				// Try to get existing prefab first
				std::string childPrefabName = std::filesystem::path(childRef["path"].GetString()).stem().string();
				auto existingPrefab = prefabManager.GetPrefab(childPrefabName);

				if (!existingPrefab) {
					// Load child prefab if not already loaded
					auto childPrefab = LoadPrefabFromFileInternal(childPath.string(), loadedPrefabs);
					if (!childPrefab) {
						Logger::Error("Failed to load child prefab: " + childPath.string());
						continue;
					}

					// Register child prefab
					prefabManager.RegisterPrefab(
						childPrefab->GetName(),
						std::make_unique<Prefab>(*childPrefab),
						childPath.string()
					);
				}

				// Extract transform data with defaults
				PopplioMath::Vec2f position{ 0, 0 }, scale{ 1, 1 };
				double rotation = 0;

				if (childRef.HasMember("position")) {
					position.x = childRef["position"]["x"].GetFloat();
					position.y = childRef["position"]["y"].GetFloat();
				}
				if (childRef.HasMember("scale")) {
					scale.x = childRef["scale"]["x"].GetFloat();
					scale.y = childRef["scale"]["y"].GetFloat();
				}
				if (childRef.HasMember("rotation")) {
					rotation = childRef["rotation"].GetDouble();
				}

				// Add child reference to parent using relative path
				prefab->AddChildPrefab(PrefabRef(
					std::filesystem::path(childRef["path"].GetString()).string(),
					position,
					scale,
					rotation
				));
			}
		}

		return prefab;
	}

	void Serializer::DeserializePrefabComponents(Prefab& prefab, const rapidjson::Value& components)
	{
		DeserializeComponent<ActiveComponent>(prefab, components["active"]);
		DeserializeComponent<TransformComponent>(prefab, components["transform"]);

		if (components.HasMember("render"))
			DeserializeComponent<RenderComponent>(prefab, components["render"]);
		if (components.HasMember("rigidbody"))
			DeserializeComponent<RigidBodyComponent>(prefab, components["rigidbody"]);
		if (components.HasMember("boxcollider"))
			DeserializeComponent<BoxColliderComponent>(prefab, components["boxcollider"]);
		if (components.HasMember("text"))
			DeserializeComponent<TextComponent>(prefab, components["text"]);
		if (components.HasMember("animation"))
			DeserializeComponent<AnimationComponent>(prefab, components["animation"]);
		if (components.HasMember("logic"))
			DeserializeComponent<LogicComponent>(prefab, components["logic"]);
		if (components.HasMember("audio"))
			DeserializeComponent<AudioComponent>(prefab, components["audio"]);
		if (components.HasMember("parent"))
			DeserializeComponent<ParentComponent>(prefab, components["parent"]);
		if (components.HasMember("persist"))
			DeserializeComponent<PersistOnLoadComponent>(prefab, components["persist"]);
        if (components.HasMember("ui"))
            DeserializeComponent<UIComponent>(prefab, components["ui"]);
        if (components.HasMember("particles"))
            DeserializeComponent<ParticleComponent>(prefab, components["particles"]);
	}

	void Serializer::DeserializeEntities()
	{
		if (!document.IsObject() || !document.HasMember("entities") || !document["entities"].IsArray())
		{
			Logger::Error("Invalid JSON structure : expected 'entities' array");
			return;
		}

		Logger::Info("Starting entity deserialization");

		// First pass: Deserialize all entities
		const auto& entities = document["entities"];
		for (const auto& entityVal : entities.GetArray())
		{
			DeserializeEntity(entityVal);
		}

		// Update local transforms for entities with parents
		for (const auto obj : registry.GetAllEntities())
		{
			if (!obj.HasComponent<ParentComponent>()) continue;
			if (!obj.GetComponent<ParentComponent>().parent.Exists()) continue;

			obj.GetComponent<ParentComponent>().SetLocalToWorld(obj.GetComponent<TransformComponent>());
		}

		// Third pass: Set up child relationships if they exist
		if (document.HasMember("child_relationships") && document["child_relationships"].IsArray())
		{
			const auto& relationships = document["child_relationships"].GetArray();
			for (const auto& rel : relationships)
			{
				if (rel.HasMember("parentId") && rel.HasMember("childrenIds"))
				{
					int parentId = rel["parentId"].GetInt();
					if (registry.EntityExists(parentId))
					{
						Entity parent = registry.GetEntityById(parentId);
						if (parent.HasComponent<ParentComponent>())
						{
							auto& parentComp = parent.GetComponent<ParentComponent>();

							const auto& childrenIds = rel["childrenIds"].GetArray();
							for (const auto& childId : childrenIds)
							{
								if (childId.IsInt() && registry.EntityExists(childId.GetInt()))
								{
									Entity child = registry.GetEntityById(childId.GetInt());

									parentComp.AddChild(child, parent);

									// Set up child's parent component if needed
									if (!child.HasComponent<ParentComponent>())
									{
										child.AddComponent<ParentComponent>(parent);
									}
									else
									{
										child.GetComponent<ParentComponent>().parent = parent;
									}

									child.GetComponent<ParentComponent>().UpdateLocalTransform(
										child.GetComponent<TransformComponent>(), parent.GetComponent<TransformComponent>());
								}
							}

							// Initialize the transform tracking for this parent
							registry.GetSystem<HierarchySystem>().InitializeParentTransform(parent);
						}
					}
				}
			}
		}

		Logger::Info("Entity deserialization completed");
	}

	void Serializer::DeserializeEntity(const rapidjson::Value& entityVal)
	{
		if (!entityVal.IsObject())
		{
			Logger::Error("Invalid entity structure: expected object");
			return;
		}

		Entity entity = Entity(-1);

		if (entityVal.HasMember("id"))
		{
			entity = registry.CreateEntity(-1, entityVal["id"].GetInt());
		}
		else
		{
			Logger::Error("Entity missing 'id' field");
			return;
			//entity = registry.CreateEntity();
		}

		if (entity.GetId() < 0) return;

		if (entityVal.HasMember("tag"))
		{
			DeserializeTag(entity, entityVal["tag"]);
		}

		if (entityVal.HasMember("group"))
		{
			DeserializeGroup(entity, entityVal["group"]);
		}

		if (entityVal.HasMember("layer"))
		{
			layerManager.AddEntityToLayer(entity, entityVal["layer"].GetString());
		}

		if (entityVal.HasMember("active"))
		{
			DeserializeComponent<ActiveComponent>(entity, entityVal["active"]);
		}

		if (entityVal.HasMember("transform"))
		{
			DeserializeComponent<TransformComponent>(entity, entityVal["transform"]);
		}

		if (entityVal.HasMember("rigidbody"))
		{
			DeserializeComponent<RigidBodyComponent>(entity, entityVal["rigidbody"]);
		}

		if (entityVal.HasMember("boxcollider"))
		{
			DeserializeComponent<BoxColliderComponent>(entity, entityVal["boxcollider"]);
		}

		if (entityVal.HasMember("render"))
		{
			DeserializeComponent<RenderComponent>(entity, entityVal["render"]);
		}

		if (entityVal.HasMember("text"))
		{
			DeserializeComponent<TextComponent>(entity, entityVal["text"]);
		}

		if (entityVal.HasMember("animation"))
		{
			DeserializeComponent<AnimationComponent>(entity, entityVal["animation"]);
		}

		if (entityVal.HasMember("ui"))
		{
			DeserializeComponent<UIComponent>(entity, entityVal["ui"]);
		}


		if (entityVal.HasMember("logic"))
		{
			DeserializeComponent<LogicComponent>(entity, entityVal["logic"]);
		}

		if (entityVal.HasMember("audio"))
		{
			DeserializeComponent<AudioComponent>(entity, entityVal["audio"]);
		}

		if (entityVal.HasMember("prefab_instance"))
		{
			Logger::Info("- This entity is a prefab instance");
			DeserializeComponent<PrefabInstanceComponent>(entity, entityVal["prefab_instance"]);
		}

		if (entityVal.HasMember("parent"))
		{
			DeserializeComponent<ParentComponent>(entity, entityVal["parent"]);
		}

        if (entityVal.HasMember("persist"))
        {
            DeserializeComponent<PersistOnLoadComponent>(entity, entityVal["persist"]);
        }

        if (entityVal.HasMember("particles"))
        {
            DeserializeComponent<ParticleComponent>(entity, entityVal["particles"]);
        }

		Logger::Debug("Deserialized Entity: " + std::to_string(entity.GetId()));
	}

	std::unique_ptr<Prefab> Serializer::DeserializePrefab(const rapidjson::Value& prefabValue)
	{
		if (!prefabValue.HasMember("name") || !prefabValue.HasMember("components"))
		{
			Logger::Error("Invalid prefab format: missing required fields");
			return nullptr;
		}

		std::string prefabName = prefabValue["name"].GetString();
		auto prefab = std::make_unique<Prefab>(prefabName);
		const auto& components = prefabValue["components"];

		Logger::Info("Deserializing prefab components:");

		// Use the generic template for each component type

		if (components.HasMember("active"))
		{
			Logger::Info("- Found active component");
			DeserializeComponent<ActiveComponent>(*prefab, components["active"]);
		}

		if (components.HasMember("transform"))
		{
			Logger::Info("- Found transform component");
			DeserializeComponent<TransformComponent>(*prefab, components["transform"]);
		}

		if (components.HasMember("rigidbody"))
		{
			Logger::Info("- Found rigidbody component");
			DeserializeComponent<RigidBodyComponent>(*prefab, components["rigidbody"]);
		}

		if (components.HasMember("boxcollider"))
		{
			Logger::Info("- Found boxcollider component");
			DeserializeComponent<BoxColliderComponent>(*prefab, components["boxcollider"]);
		}

		if (components.HasMember("render"))
		{
			Logger::Info("- Found render component");
			DeserializeComponent<RenderComponent>(*prefab, components["render"]);
		}

		if (components.HasMember("text"))
		{
			Logger::Info("- Found text component");
			DeserializeComponent<TextComponent>(*prefab, components["text"]);
		}

		if (components.HasMember("logic"))
		{
			Logger::Info("- Found logic component");
			DeserializeComponent<LogicComponent>(*prefab, components["logic"]);
		}

		if (components.HasMember("audio"))
		{
			Logger::Info("- Found audio component");
			DeserializeComponent<AudioComponent>(*prefab, components["audio"]);
		}

		if (components.HasMember("animation"))
		{
			Logger::Info("- Found animation component");
			DeserializeComponent<AnimationComponent>(*prefab, components["animation"]);
		}

		if (components.HasMember("parent"))
		{
			Logger::Info("- Found parent component");
			DeserializeComponent<ParentComponent>(*prefab, components["parent"]);
		}

		if (components.HasMember("persist"))
		{
			Logger::Info("- Found persist component");
			DeserializeComponent<PersistOnLoadComponent>(*prefab, components["persist"]);
		}

        if (components.HasMember("ui"))
        {
            Logger::Info("- Found ui component");
            DeserializeComponent<UIComponent>(*prefab, components["ui"]);
        }

        if (components.HasMember("particles"))
        {
            Logger::Info("- Found particles component");
            DeserializeComponent<ParticleComponent>(*prefab, components["particles"]);
        }

		if (prefabValue.HasMember("childPrefabs") && prefabValue["childPrefabs"].IsArray())
		{
			Logger::Info("- Found child prefabs");
			const auto& childPrefabs = prefabValue["childPrefabs"].GetArray();

			for (const auto& childRef : childPrefabs)
			{
				if (!childRef.IsObject() || !childRef.HasMember("path"))
				{
					Logger::Warning("Invalid child prefab reference structure");
					continue;
				}

				std::string path = childRef["path"].GetString();
				PopplioMath::Vec2f position = { 0, 0 };
				PopplioMath::Vec2f scale = { 1, 1 };
				double rotation = 0;

				if (childRef.HasMember("position"))
				{
					position.x = childRef["position"]["x"].GetFloat();
					position.y = childRef["position"]["y"].GetFloat();
				}

				if (childRef.HasMember("scale"))
				{
					scale.x = childRef["scale"]["x"].GetFloat();
					scale.y = childRef["scale"]["y"].GetFloat();
				}

				if (childRef.HasMember("rotation"))
				{
					rotation = childRef["rotation"].GetDouble();
				}

				prefab->AddChildPrefab(PrefabRef(path, position, scale, rotation));
				Logger::Info("  - Added child prefab reference: " + path);
			}
		}

		return prefab;
	}

	void Serializer::DeserializeTag(Entity entity, const rapidjson::Value& tagVal)
	{
		if (!tagVal.IsString())
		{
			Logger::Error("Error: Entity " + std::to_string(entity.GetId()) +
				" has invalid tag: expected string", LogDestination::WINDOWS_CONSOLE);
			return;
		}

		entity.Tag(tagVal.GetString());
	}

	void Serializer::DeserializeGroup(Entity entity, const rapidjson::Value& groupVal)
	{
		if (!groupVal.IsString())
		{
			Logger::Error("Error: Entity " + std::to_string(entity.GetId()) +
				" has invalid group: expected string", LogDestination::WINDOWS_CONSOLE);
			return;
		}

		entity.Group(groupVal.GetString());
	}

	bool Serializer::SaveSceneToFile(const std::string& filename, CameraManager& cameraMgr)
	{
		std::filesystem::current_path(std::filesystem::path(Popplio::Engine::programPath));

		// Clear the existing document and set it as an object
		document.SetObject();

		SerializeEntities();
		SerializeLayers();
		SerializeCameraSettings(cameraMgr);

		rapidjson::StringBuffer buffer;
		rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
		document.Accept(writer);

		std::ofstream outFile(filename);
		if (!outFile)
		{
			Logger::Error("Failed to open file for writing: " + filename);
			std::filesystem::current_path(std::filesystem::path(Popplio::Engine::programPath));
			return false;
		}

		outFile << buffer.GetString();
		outFile.close();

		Logger::Info("Saved level data to file: " + filename);
		std::filesystem::current_path(std::filesystem::path(Popplio::Engine::programPath));
		return true;
	}

	bool Serializer::SavePrefabToFile(const std::string& filename, const Prefab& prefab)
	{
		document.SetObject();
		auto& allocator = document.GetAllocator();

		rapidjson::Value prefabValue(rapidjson::kObjectType);
		SerializePreFab(prefab, prefabValue, allocator, document);

		//document.AddMember("prefab", prefabValue, allocator);

		rapidjson::StringBuffer buffer;
		rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
		document.Accept(writer);

		std::ofstream outFile(filename);
		if (!outFile)
		{
			Logger::Error("Failed to open file for writing: " + filename);
			return false;
		}

		outFile << buffer.GetString();
		outFile.close();
		Logger::Info("Saved prefab data to file: " + filename);
		return true;
	}

	void Serializer::SerializeEntities()
	{
		rapidjson::Value entities(rapidjson::kArrayType);
		auto& allocator = document.GetAllocator();

		// Store child relationships separately
		rapidjson::Value childRelationships(rapidjson::kArrayType);

		for (const auto& entity : registry.GetAllEntities())
		{
			rapidjson::Value entityValue(rapidjson::kObjectType);
			SerializeEntity(entity, entityValue, allocator);
			entities.PushBack(entityValue, allocator);

			if (entity.HasComponent<ParentComponent>())
			{
				const auto& parentComp = entity.GetComponent<ParentComponent>();
				if (!parentComp.children.empty())
				{
					rapidjson::Value relationship(rapidjson::kObjectType);
					relationship.AddMember("parentId", entity.GetId(), allocator);

					rapidjson::Value children(rapidjson::kArrayType);
					for (const auto& child : parentComp.children)
					{
						children.PushBack(child.GetId(), allocator);
					}
					relationship.AddMember("childrenIds", children, allocator);
					childRelationships.PushBack(relationship, allocator);
				}
			}
		}
		document.AddMember("entities", entities, allocator);
		document.AddMember("child_relationships", childRelationships, allocator);
	}

	void Serializer::SerializeEntity(Entity entity, rapidjson::Value& entityValue, rapidjson::Document::AllocatorType& allocator)
	{
		entityValue.AddMember("id", entity.GetId(), allocator);

		if (registry.EntityHasAnyTag(entity))
		{
			std::string tag = registry.GetEntityTag(entity);
			rapidjson::Value tagValue;
			tagValue.SetString(tag.c_str(), allocator);
			entityValue.AddMember("tag", tagValue, allocator);
		}

		if (registry.EntityBelongsToAnyGroup(entity))
		{
			std::string group = registry.GetEntityGroup(entity);
			rapidjson::Value groupValue;
			groupValue.SetString(group.c_str(), allocator);
			entityValue.AddMember("group", groupValue, allocator);
		}

		// Add Layer information
		std::string layerName = layerManager.GetEntityLayer(entity);
		if (!layerName.empty())
		{
			rapidjson::Value layerValue;
			layerValue.SetString(layerName.c_str(), allocator);
			entityValue.AddMember("layer", layerValue, allocator);
		}

		SerializeComponent<ActiveComponent>(entity, entityValue, allocator);
		SerializeComponent<TransformComponent>(entity, entityValue, allocator);
		SerializeComponent<RigidBodyComponent>(entity, entityValue, allocator);
		SerializeComponent<BoxColliderComponent>(entity, entityValue, allocator);
		SerializeComponent<RenderComponent>(entity, entityValue, allocator);
		SerializeComponent<TextComponent>(entity, entityValue, allocator);
		SerializeComponent<AnimationComponent>(entity, entityValue, allocator);
		SerializeComponent<AudioComponent>(entity, entityValue, allocator);
		SerializeComponent<LogicComponent>(entity, entityValue, allocator);
		SerializeComponent<PrefabInstanceComponent>(entity, entityValue, allocator);
		SerializeComponent<ParentComponent>(entity, entityValue, allocator);
		SerializeComponent<PersistOnLoadComponent>(entity, entityValue, allocator);
		SerializeComponent<UIComponent>(entity, entityValue, allocator);
        SerializeComponent<ParticleComponent>(entity, entityValue, allocator);
	}

	void Serializer::SerializePreFab(const Prefab& prefab, rapidjson::Value& prefabValue, 
		rapidjson::Document::AllocatorType& allocator, rapidjson::Document& doc)
	{
        static_cast<void>(doc);

		// Serialize prefab name
		rapidjson::Value nameValue;
		nameValue.SetString(prefab.GetName().c_str(), allocator);
		prefabValue.AddMember("name", nameValue, allocator);
		Logger::Info("Added prefab name: " + prefab.GetName());

		// Create components value
		rapidjson::Value components(rapidjson::kObjectType);

		// Use the generic template for each component type
		SerializeComponent<ActiveComponent>(prefab, components, allocator);
		SerializeComponent<TransformComponent>(prefab, components, allocator);
		SerializeComponent<RigidBodyComponent>(prefab, components, allocator);
		SerializeComponent<BoxColliderComponent>(prefab, components, allocator);
		SerializeComponent<RenderComponent>(prefab, components, allocator);
		SerializeComponent<TextComponent>(prefab, components, allocator);
		SerializeComponent<AudioComponent>(prefab, components, allocator);
		SerializeComponent<LogicComponent>(prefab, components, allocator);
		SerializeComponent<AnimationComponent>(prefab, components, allocator);
		SerializeComponent<ParentComponent>(prefab, components, allocator);
        SerializeComponent<PersistOnLoadComponent>(prefab, components, allocator);
        SerializeComponent<UIComponent>(prefab, components, allocator);
        SerializeComponent<ParticleComponent>(prefab, components, allocator);

		prefabValue.AddMember("components", components, allocator);

		// Serialize child prefabs
		if (!prefab.GetChildPrefabs().empty())
		{
			rapidjson::Value childPrefs(rapidjson::kArrayType);

			for (const auto& childRef : prefab.GetChildPrefabs())
			{
				rapidjson::Value childPrefab(rapidjson::kObjectType);

				// Serialize prefab path
				rapidjson::Value path;
				path.SetString(childRef.prefabPath.c_str(), allocator);
				childPrefab.AddMember("path", path, allocator);

				// Serialize transform data
				rapidjson::Value position(rapidjson::kObjectType);
				position.AddMember("x", childRef.localPosition.x, allocator);
				position.AddMember("y", childRef.localPosition.y, allocator);
				childPrefab.AddMember("position", position, allocator);

				rapidjson::Value scale(rapidjson::kObjectType);
				scale.AddMember("x", childRef.localScale.x, allocator);
				scale.AddMember("y", childRef.localScale.y, allocator);
				childPrefab.AddMember("scale", scale, allocator);

				childPrefab.AddMember("rotation", childRef.localRotation, allocator);

				childPrefs.PushBack(childPrefab, allocator);
			}

			prefabValue.AddMember("childPrefabs", childPrefs, allocator);
			Logger::Info("Added child prefab references");
		}

		//std::string prefabName = ;
		document.AddMember("prefab", prefabValue, allocator);
	}

	void Serializer::SerializeLayers()
	{
		auto& allocator = document.GetAllocator();

		// Create layers array
		rapidjson::Value layersArray(rapidjson::kArrayType);

		// Get sorted layers
		auto sortedLayers = layerManager.GetSortedLayers();

		for (const auto& layer : sortedLayers)
		{
			rapidjson::Value layerObj(rapidjson::kObjectType);

			// Serialize layer properties
			rapidjson::Value nameValue;
			nameValue.SetString(layer.name.c_str(), allocator);
			layerObj.AddMember("name", nameValue, allocator);
			layerObj.AddMember("order", layer.order, allocator);
			layerObj.AddMember("active", layer.active, allocator);

			// Get entities in this layer
			rapidjson::Value entitiesArray(rapidjson::kArrayType);
			auto layerEntities = layerManager.GetEntitiesInLayer(layer.name);

			for (const auto& entity : layerEntities)
			{
				entitiesArray.PushBack(entity.GetId(), allocator);
			}

			layerObj.AddMember("entities", entitiesArray, allocator);
			layersArray.PushBack(layerObj, allocator);
		}

		// Add Layers array to document
		document.AddMember("layers", layersArray, allocator);

		// Serialize layer order interactions
		rapidjson::Value interactionsObj(rapidjson::kObjectType);
		const auto& interactions = layerManager.GetLayerInteractions();

		for (const auto& [layer1, layerInteractions] : interactions)
		{
			rapidjson::Value layer1Interactions(rapidjson::kObjectType);

			for (const auto& [layer2, interacts] : layerInteractions)
			{
				layer1Interactions.AddMember(
					rapidjson::Value(layer2.c_str(), allocator).Move(),
					interacts,
					allocator
				);
			}

			interactionsObj.AddMember(
				rapidjson::Value(layer1.c_str(), allocator).Move(),
				layer1Interactions,
				allocator
			);
		}

		document.AddMember("layer_interactions", interactionsObj, allocator);
	}

	void Serializer::DeserializeLayers()
	{
		if (!document.HasMember("layers"))
		{
			Logger::Warning("No layer data found in file");
			return;
		}

		const auto& layersArray = document["layers"];
		if (!layersArray.IsArray())
		{
			Logger::Error("Invalid layer data format");
			return;
		}

		// Clear existing layers
		layerManager.Clear();

		// First pass: Create all Layers
		for (const auto& layerObj : layersArray.GetArray())
		{
			if (!layerObj.HasMember("name") || !layerObj.HasMember("active"))
			{
				Logger::Warning("Skipping invalid layer entry");
				continue;
			}

			std::string name = layerObj["name"].GetString();
			bool active = layerObj["active"].GetBool();

			layerManager.AddLayer(name, active);
		}

		// Second pass: Set orders and restore entity assignments
		for (const auto& layerObj : layersArray.GetArray())
		{
			std::string name = layerObj["name"].GetString();

			// Set order
			if (layerObj.HasMember("order"))
			{
				int order = layerObj["order"].GetInt();
				layerManager.SetLayerOrder(name, order);
			}

			// Restore entity assignments
			if (layerObj.HasMember("entities") && layerObj["entities"].IsArray())
			{
				const auto& entitiesArray = layerObj["entities"].GetArray();
				for (const auto& entityId : entitiesArray)
				{
					if (!entityId.IsInt())
					{
						continue;
					}

					if (registry.EntityExists(entityId.GetInt()))
					{
						Entity entity = registry.GetEntityById(entityId.GetInt());
						layerManager.AddEntityToLayer(entity, name);
					}
				}
			}
		}

		// Deserialize layer interactions
		if (document.HasMember("layer_interactions"))
		{
			const auto& interactionsObj = document["layer_interactions"];
			if (interactionsObj.IsObject())
			{
				// Create temporary map to store all interactions
				std::unordered_map<std::string, std::unordered_map<std::string, bool>> interactions;

				// Parse the interactions
				for (auto it1 = interactionsObj.MemberBegin(); it1 != interactionsObj.MemberEnd(); ++it1)
				{
					const std::string layer1 = it1->name.GetString();
					const auto& layer1Interactions = it1->value;

					if (layer1Interactions.IsObject())
					{
						for (auto it2 = layer1Interactions.MemberBegin();
							it2 != layer1Interactions.MemberEnd(); ++it2)
						{
							const std::string layer2 = it2->name.GetString();
							bool interacts = it2->value.GetBool();

							layerManager.SetLayerInteraction(layer1, layer2, interacts);
						}
					}
				}
			}
		}

		Logger::Info("Successfully deserialized layers and interactions");
	}

	// doesnt clear children currently
	std::set<Popplio::Entity>& Serializer::ClearEntitiesIfNotPersistent(std::set<Popplio::Entity>& persistentEntities, Entity entity)
	{
		//if (std::find(persistentLayers.begin(), persistentLayers.end(), layerManager.GetEntityLayer(entity)) 
		//	== persistentLayers.end())
//                   persistentLayers.push_back(layerManager.GetEntityLayer(entity));

		persistentEntities.insert(entity);

		//if (entity.HasComponent<ParentComponent>())
		//{
		//	for (auto& child : entity.GetComponent<ParentComponent>().children)
		//	{
		//		persistentEntities = ClearEntitiesIfNotPersistent(persistentEntities, child); // recursion to add children
		//	}
		//}

		return persistentEntities;
	}

	std::set<Popplio::Entity> Serializer::ClearCurrentScene(bool const& clearPersistent)
	{
		Logger::Info("Clearing current scene...");

		// Clear all layers first
		//layerManager.Clear();

		std::set<Popplio::Entity> persistentEntities{};

		// Get all entities and remove them
		auto entities = registry.GetAllEntities();
		for (auto entity : entities)
		{
			if (!clearPersistent)
			{
				if (entity.HasComponent<PersistOnLoadComponent>())
				{
					if (entity.GetComponent<PersistOnLoadComponent>().persistOnLoad)
					{
						persistentEntities = ClearEntitiesIfNotPersistent(persistentEntities, entity);
					}
					else registry.KillEntity(entity);
				}
				else registry.KillEntity(entity);
			}
			else registry.KillEntity(entity);
		}

		//for (auto entity : persistentEntities)
		//{
		//    registry.KillEntity(entity);
		//}

		//std::vector<Popplio::Signature> signatures{};

  //      for (auto entity : registry.GetAllEntities())
  //      {
  //          signatures.push_back(registry.entityComponentSignatures[entity.GetId()]);
  //      }

		layerManager.Clear(persistentEntities); // clear layers

		// Process any pending entity deletions
		registry.Update();

		registry.ClearFreeIds();

		//if (clearPersistent) registry.ResetNumEntities();
		//else registry.UpdateNumEntities();

		Logger::Info("Scene cleared successfully");

		return persistentEntities;
	}

	bool Serializer::SaveEntityAsPrefab(const Entity& entity, const std::string& prefabName, const std::string& filePath,
		bool isChild, std::unordered_map<int, std::string>* savedPrefabs)
	{
        static_cast<void>(isChild);

		if (prefabName.empty()) {
			Logger::Error("Cannot save prefab with empty name", LogDestination::IMGUI_CONSOLE);
			return false;
		}

		// Create map for tracking saved prefabs if this is the root call
		std::unordered_map<int, std::string> localSavedPrefabs;
		if (!savedPrefabs) {
			savedPrefabs = &localSavedPrefabs;
		}

		// Check if this entity was already saved as a prefab
		if (savedPrefabs->find(entity.GetId()) != savedPrefabs->end()) {
			return true;
		}

		// Create a new document for each prefab
		rapidjson::Document prefabDoc;
		prefabDoc.SetObject();
		auto& allocator = prefabDoc.GetAllocator();

		rapidjson::Value prefabValue(rapidjson::kObjectType);

		// Basic prefab properties
		rapidjson::Value nameValue;
		nameValue.SetString(prefabName.c_str(), allocator);
		prefabValue.AddMember("name", nameValue, allocator);

		// Serialize components
		rapidjson::Value components(rapidjson::kObjectType);
		SerializeEntity(entity, components, allocator);
		prefabValue.AddMember("components", components, allocator);

		// Handle child prefabs
		if (entity.HasComponent<ParentComponent>() && !entity.GetComponent<ParentComponent>().children.empty()) {
			rapidjson::Value childPrefabs(rapidjson::kArrayType);
			std::filesystem::path parentPath = std::filesystem::path(filePath).parent_path();

			for (auto& child : entity.GetComponent<ParentComponent>().children) {
				std::string childPrefabName = prefabName + "_" + std::to_string(child.GetId());
				std::string childFileName = childPrefabName + ".prefab";
				std::string childPath = (parentPath / childFileName).string();

				// Save child to its own file
				if (SaveEntityAsPrefab(child, childPrefabName, childPath, true, savedPrefabs)) {
					rapidjson::Value childRef(rapidjson::kObjectType);

					// Add child reference
					rapidjson::Value pathValue;
					pathValue.SetString(childFileName.c_str(), allocator);
					childRef.AddMember("path", pathValue, allocator);

					// Add transform data
					auto& childTransform = child.GetComponent<TransformComponent>();
					rapidjson::Value position(rapidjson::kObjectType);
					position.AddMember("x", childTransform.position.x, allocator);
					position.AddMember("y", childTransform.position.y, allocator);
					childRef.AddMember("position", position, allocator);

					rapidjson::Value scale(rapidjson::kObjectType);
					scale.AddMember("x", childTransform.scale.x, allocator);
					scale.AddMember("y", childTransform.scale.y, allocator);
					childRef.AddMember("scale", scale, allocator);

					childRef.AddMember("rotation", childTransform.rotation, allocator);

					childPrefabs.PushBack(childRef, allocator);
				}
			}
			prefabValue.AddMember("childPrefabs", childPrefabs, allocator);
		}

		prefabDoc.AddMember("prefab", prefabValue, allocator);

		// Save to file
		rapidjson::StringBuffer buffer;
		rapidjson::PrettyWriter<rapidjson::StringBuffer> writer(buffer);
		prefabDoc.Accept(writer);

		std::ofstream outFile(filePath);
		if (!outFile) {
			Logger::Error("Failed to open file for writing: " + filePath);
			return false;
		}

		outFile << buffer.GetString();
		outFile.close();

		// Record that this prefab has been saved
		(*savedPrefabs)[entity.GetId()] = std::filesystem::path(filePath).filename().string();

		//prefabManager.RegisterPrefab(prefabName, CreatePrefabFromEntity(entity), filePath);
		Logger::Info("Successfully saved prefab: " + prefabName);
		return true;
	}

	std::unique_ptr<Prefab> Serializer::CreatePrefabFromEntity(Entity const& entity)
	{
		auto prefab = std::make_unique<Prefab>(registry.GetEntityTag(entity));
		CopyEntityToPrefab(entity, *prefab);
		return prefab;
	}

	void Serializer::CopyEntityToPrefab(Entity const& entity, Prefab& prefab)
	{
		// Copy transform component
		if (entity.HasComponent<TransformComponent>())
		{
			prefab.AddComponent<TransformComponent>(entity.GetComponent<TransformComponent>());
		}

		// Copy render component
		if (entity.HasComponent<RenderComponent>())
		{
			prefab.AddComponent<RenderComponent>(entity.GetComponent<RenderComponent>());
		}

		// Copy box collider component
		if (entity.HasComponent<BoxColliderComponent>())
		{
			prefab.AddComponent<BoxColliderComponent>(entity.GetComponent<BoxColliderComponent>());
		}

		// Copy rigid body component
		if (entity.HasComponent<RigidBodyComponent>())
		{
			prefab.AddComponent<RigidBodyComponent>(entity.GetComponent<RigidBodyComponent>());
		}

		// Copy text component
		if (entity.HasComponent<TextComponent>())
		{
			prefab.AddComponent<TextComponent>(entity.GetComponent<TextComponent>());
		}

		// Copy animation component
		if (entity.HasComponent<AnimationComponent>())
		{
			prefab.AddComponent<AnimationComponent>(entity.GetComponent<AnimationComponent>());
		}

		// Copy audio component
		if (entity.HasComponent<AudioComponent>())
		{
			prefab.AddComponent<AudioComponent>(entity.GetComponent<AudioComponent>());
		}

		// Copy script component
		if (entity.HasComponent<LogicComponent>())
		{
			prefab.AddComponent<LogicComponent>(entity.GetComponent<LogicComponent>());
		}

		// Copy active component
		if (entity.HasComponent<ActiveComponent>())
		{
			prefab.AddComponent<ActiveComponent>(entity.GetComponent<ActiveComponent>());
		}

		// Copy parent component
		if (entity.HasComponent<ParentComponent>())
		{
			prefab.AddComponent<ParentComponent>(entity.GetComponent<ParentComponent>());
		}

		// Copy persist on load component
		if (entity.HasComponent<PersistOnLoadComponent>())
		{
			prefab.AddComponent<PersistOnLoadComponent>(entity.GetComponent<PersistOnLoadComponent>());
		}

        // Copy UI component
        if (entity.HasComponent<UIComponent>())
        {
            prefab.AddComponent<UIComponent>(entity.GetComponent<UIComponent>());
        }

        // Copy Particle component
        if (entity.HasComponent<ParticleComponent>())
        {
            prefab.AddComponent<ParticleComponent>(entity.GetComponent<ParticleComponent>());
        }
	}

	bool Serializer::HasCircularReference(Entity const& entity, std::set<int>& visitedIds)
	{
		if (visitedIds.find(entity.GetId()) != visitedIds.end())
		{
			return true;
		}

		visitedIds.insert(entity.GetId());

		if (entity.HasComponent<ParentComponent>())
		{
			auto& parentComp = entity.GetComponent<ParentComponent>();
			for (auto& child : parentComp.children)
			{
				if (HasCircularReference(child, visitedIds))
				{
					return true;
				}
			}
		}

		visitedIds.erase(entity.GetId());
		return false;
	}

	void Serializer::SerializeCameraSettings(CameraManager& cameraManager)
	{
		auto& allocator = document.GetAllocator();

		// Create camera settings object
		rapidjson::Value cameraSettings(rapidjson::kObjectType);

		// Get camera reference
		const auto& camera = cameraManager.GetGameCamera();

		// Serialize position
		rapidjson::Value position(rapidjson::kObjectType);
		position.AddMember("x", camera.GetPosition().x, allocator);
		position.AddMember("y", camera.GetPosition().y, allocator);
		cameraSettings.AddMember("position", position, allocator);

		// Serialize zoom
		cameraSettings.AddMember("zoom", camera.GetZoom(), allocator);

		// Add to main document
		document.AddMember("camera_settings", cameraSettings, allocator);
	}

	void Serializer::DeserializeCameraSettings(CameraManager& cameraManager)
	{
		if (!document.HasMember("camera_settings"))
		{
			Logger::Info("No camera settings found in scene file");
			return;
		}

		const auto& cameraSettings = document["camera_settings"];

		// Get camera reference
		auto& camera = cameraManager.GetGameCamera();

		// Deserialize position
		if (cameraSettings.HasMember("position"))
		{
			const auto& position = cameraSettings["position"];
			PopplioMath::Vec2f pos(
				position["x"].GetFloat(),
				position["y"].GetFloat()
			);
			camera.SetPosition(pos);
		}

		// Deserialize zoom
		if (cameraSettings.HasMember("zoom"))
		{
			camera.SetZoom(cameraSettings["zoom"].GetFloat());
		}
	}
}

================
File: Serialization/Serialization.h
================
/******************************************************************************/
/*!
\file           Serialization.h
\author         Team Popplio
\author         Bryan Ang Wei Ze
\co-author      Hafawati Binte Mohd Ali | Ng Jun Heng Shawn | Shannon | Val
\contribution   Bryan - 60%, Hafawati - 20%, Shawn - 10%, Shannon - 5%, Val - 5%
\par            Course : CSD2401 / CSD2400
\par            Section : A
\date           2025/03/13 10:01:45 AM (Last Edit)
\brief
	This is the header file for the serializer of the engine

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/
#pragma once

#include <rapidjson/document.h>

#include <algorithm>
#include <typeinfo>
#include <filesystem>
#include <unordered_set>

//#include "../Engine/Engine.h"

#include "../Transformation/TransformComponent.h"
#include "../Physics/RigidBodyComponent.h"
#include "../Graphic/GraphicComponent.h"
#include "../Collision/BoxColliderComponent.h"
#include "../Collision/CircleColliderComponent.h"
#include "../Animation/AnimationComponent.h"
#include "../UI/UIComponent.h"
#include "../ECS/ECS.h"
#include "../PrefabManagement/Prefab.h"
#include "../AssetStore/AssetStore.h"
#include "../Audio/AudioSystem.h"
#include "../Script/LogicSystem.h"
#include "../Utilities/Components.h"
#include "../Layering/LayerManager.h"
#include "../AssetStore/AssetLoader.h"
#include "../PrefabManagement/PrefabManager.h"
#include "../Graphic/Color.h"

#include "../Utilities/QueueSystem.h"

#include "SerializeTypes.h"

namespace Popplio
{
	/**
	 * \struct Config
	 * \brief Represents the configuration settings for the serializer.
	 */
	struct Config
	{
		std::string engineVer; /**< The version of the engine. */
		std::string appVer; /**< The version of the application. */

		// program settings
		int width; /**< The width of the configuration. */
		int height; /**< The height of the configuration. */
		bool vSync; /**< The vSync flag of the configuration. */

		// editor
		bool safeMode; /**< The safe mode flag (editor) of the configuration. */
		std::string lastScene; /**< The last scene opened of the configuration. */
		bool verbose; /**< The verbose flag of the configuration. */

		// build settings
		std::string startScene; /**< The start scene of the configuration. */
	};

	/**
	 * \class Serializer
	 * \brief Responsible for serializing and deserializing entities.
	 */
	class Serializer
	{
	public:
		/**
		 * \brief Constructs a Serializer object.
		 * \param registry The registry to access entities.
		 */
		Serializer(Registry& reg, LayerManager& layerMgr, PrefabManager& prefabMgr, EventBus& eventBus);

		/**
		 * \brief Loads entities from a file.
		 * \param filename The name of the file to load from.
		 * \param clearPersistent Flag to clear persistent entities.
		 * \return True if the loading is successful, false otherwise.
		 */
		bool LoadSceneFromFile(const std::string& filename, CameraManager& cameraMgr, const bool& clearPersistent = true);

		// TODO save config

		/**
		 * \brief Loads the configuration from a file.
		 * \param filename The name of the file to load the configuration from.
		 * \return True if the loading is successful, false otherwise.
		 */
		bool LoadConfiguration(const std::string& filename);

		//**
		// * \brief Load assets from a JSON file.
		// *
		// * This function reads a JSON file and loads various types of assets, such as textures,
		// * shaders, fonts, and audio. It checks the JSON structure and delegates the loading
		// * of different asset types to specific functions.
		// *
		// * \param filename The path to the JSON file containing asset information.
		// * \param audioSystem Reference to the audio system for loading audio assets.
		// * \return True if all assets are loaded successfully, otherwise false.
		// */
		//bool LoadAsset(const std::string& filename, AudioSystem& audioSystem, LogicSystem& logicSystem);

		/* void DeserializeTexture(const rapidjson::Value& entityValue);
		 void DeserializeShader(const rapidjson::Value& entityValue);
		 void DeserializeFont(const rapidjson::Value& entityValue);

		 void DeserializeFileNames(const std::string& filename);*/

		 /**
		  * \brief Deserializes the entities.
		  */
		void DeserializeEntities();

		/**
		 * \brief Saves the current scene to a file.
		 * \param filename The name of the file to save the scene to.
		 * \return True if the saving is successful, false otherwise.
		 */
		bool SaveSceneToFile(const std::string& filename, CameraManager& cameraMgr);

		/**
		 * \brief Saves a prefab to a file.
		 * \param filename The name of the file to save the prefab to.
		 * \param prefab The prefab to save.
		 * \return True if the saving is successful, false otherwise.
		 */
		bool SavePrefabToFile(const std::string& filename, const Prefab& prefab);

		/**
		 * \brief Loads a prefab from a file.
		 * \param filename The name of the file to load the prefab from.
		 * \return A unique pointer to the loaded prefab, or nullptr if the loading fails.
		 */
		std::unique_ptr<Prefab> LoadPrefabFromFile(const std::string& filename);

		std::unique_ptr<Prefab> LoadPrefabFromFileInternal(const std::string& filename,
			std::unordered_set<std::string>& loadedPrefabs);

		/**
		 * \brief Serializes the entities in the current scene.
		 */
		void SerializeEntities();

		/**
		 * \brief Serializes the layers in the layer manager.
		 * \param layerManager The layer manager containing the layers to serialize.
		 */
		void SerializeLayers();

		/**
		 * \brief Deserializes the layers into the layer manager.
		 * \param layerManager The layer manager to deserialize the layers into.
		 */
		void DeserializeLayers();

		/**
		 * \brief Clears the current scene by removing all entities.
		 * \param clearPersistent Flag to clear persistent entities.
		 * \return persistent entities that were not cleared.
		 */
		std::set<Popplio::Entity> ClearCurrentScene(bool const& clearPersistent);

		/**
		 * \brief Gets the configuration.
		 * \return The configuration.
		 */
		Config GetConfiguration() const { return configuration; }

		/** * \brief Generate an asset name from a file path.
		 *
		 * This function extracts the filename without its extension from a given file path.
		 * It identifies the position of the last slash ("/" or "\\") and the last dot ("."),
		 * then extracts the substring between them to form the asset name.
		 *
		 * \param filepath The full path to the file.
		 * \return The generated asset name without the file extension.
		 */
		static std::string GenerateAssetName(const std::string& filepath);

		/**
		 * \brief Serializes a meta file for assets
		 * \param filename The path to the asset
		 * \return Returns true if meta file was generated from the asset, returns false otherwise
		 */
		static bool SerializeMetaFile(const std::filesystem::path& filename);

		/**
		 * \brief Deserializes a meta file for assets
		 * \param filename The path to the META file
		 * \return Returns true if asset was successfully loaded into the engine
		 */
		static bool DeserializeMetaFile(const std::filesystem::path& filename);

		bool SaveEntityAsPrefab(const Entity& entity, const std::string& prefabName, const std::string& filePath,
			bool isChild = false, std::unordered_map<int, std::string>* savedPrefabs = nullptr);

		std::unique_ptr<Prefab> CreatePrefabFromEntity(const Entity& entity);

		void DeserializePrefabComponents(Prefab& prefab, const rapidjson::Value& components);
	private:

		///**
		// * \brief Load texture assets from a JSON array.
		// *
		// * This function iterates over a JSON array of texture paths, generates asset names,
		// * and stores the texture assets in the AssetStore.
		// *
		// * \param texturesArray The JSON array containing texture file paths.
		// * \return True if all textures are loaded successfully, otherwise false.
		// */
		//bool LoadTextures(const rapidjson::Value& texturesArray);
		///**
		// * \brief Load shader assets from a JSON array.
		// *
		// * This function iterates over a JSON array of shader paths, generates asset names,
		// * and stores the shader assets in the AssetStore.
		// *
		// * \param shadersArray The JSON array containing shader file paths.
		// * \return True if all shaders are loaded successfully, otherwise false.
		// */
		//bool LoadShaders(const rapidjson::Value& shadersArray);

		///**
		// * \brief Load font assets from a JSON array.
		// *
		// * This function iterates over a JSON array of font paths, generates asset names,
		// * and stores the font assets in the AssetStore.
		// *
		// * \param fontsArray The JSON array containing font file paths.
		// * \return True if all fonts are loaded successfully, otherwise false.
		// */
		//bool LoadFonts(const rapidjson::Value& fontsArray);
		///**
		// * \brief Load audio assets from a JSON array.
		// *
		// * This function iterates over a JSON array of audio paths and metadata, generates asset names,
		// * and stores the audio assets in the AudioSystem.
		// *
		// * \param audioArray The JSON array containing audio file paths and metadata.
		// * \param audioSystem Reference to the audio system for loading audio assets.
		// * \return True if all audio assets are loaded successfully, otherwise false.
		// */
		//bool LoadAudio(const rapidjson::Value& audioArray, AudioSystem& audioSystem);
		///**
		// * \brief Load script assets from a JSON array.
		// *
		// * This function iterates over a JSON array of script paths and metadata, generates asset names,
		// * and stores the script assets in the LogicSystem.
		// *
		// * \param logicArray The JSON array containing script file paths and metadata.
		// * \param logicSystem Reference to the logic system for loading script assets.
		// * \return True if all script assets are loaded successfully, otherwise false.
		// */
		//bool LoadCPPScripts(const rapidjson::Value& logicArray, LogicSystem& logicSystem);

		bool LoadPrefabs(const rapidjson::Value& prefabsArray);

		/**
		 * \brief Serializes an entity.
		 * \param entity The entity to serialize.
		 * \param entityValue The JSON value to store the serialized entity.
		 * \param allocator The allocator for JSON document.
		 */
		void SerializeEntity(Entity entity, rapidjson::Value& entityValue, rapidjson::Document::AllocatorType& allocator);

		/**
		 * \brief Deserializes an entity.
		 * \param entityVal The JSON value representing the entity.
		 */
		void DeserializeEntity(const rapidjson::Value& entityVal);


		/**
		 * \brief Deserializes the Tag of an entity.
		 * \param entity The entity to deserialize the Tag for.
		 * \param tagVal The JSON value representing the Tag.
		 */
		void DeserializeTag(Entity entity, const rapidjson::Value& tagVal);

		/**
		 * \brief Deserializes the Group of an entity.
		 * \param entity The entity to deserialize the Group for.
		 * \param groupVal The JSON value representing the Group.
		 */
		void DeserializeGroup(Entity entity, const rapidjson::Value& groupVal);

		/**
		 * \brief Serializes a prefab.
		 * \param prefab The prefab to serialize.
		 * \param prefabValue The JSON value to store the serialized prefab.
		 * \param allocator The allocator for JSON document.
		 * \param doc The document object.
		 */
		void SerializePreFab(const Prefab& prefab, rapidjson::Value& prefabValue,
			rapidjson::Document::AllocatorType& allocator, rapidjson::Document& doc);

		/**
		 * \brief Deserializes a prefab.
		 * \param prefabValue The JSON value representing the prefab.
		 * \return A unique pointer to the deserialized prefab, or nullptr if the deserialization fails.
		 */
		std::unique_ptr<Prefab> DeserializePrefab(const rapidjson::Value& prefabValue);

		/**
		 * \brief Serializes a component of an object.
		 * \tparam T The type of the component.
		 * \tparam ObjectType The type of the object.
		 * \param object The object containing the component.
		 * \param objectValue The JSON value to store the serialized component.
		 * \param allocator The allocator for JSON document.
		 */
		template <typename T, typename ObjectType>
		void SerializeComponent(ObjectType& object, rapidjson::Value& objectValue, rapidjson::Document::AllocatorType& allocator);

		/**
		 * \brief Deserializes a component of an object.
		 * \tparam T The type of the component.
		 * \tparam ObjectType The type of the object.
		 * \param object The object to deserialize the component for.
		 * \param componentVal The JSON value representing the component.
		 */
		template <typename T, typename ObjectType>
		void DeserializeComponent(ObjectType& object, const rapidjson::Value& componentVal);

		std::set<Popplio::Entity>& ClearEntitiesIfNotPersistent(std::set<Popplio::Entity>& persistentEntities, Entity e);

		// Helper methods for saving entities as prefabs
		bool HasCircularReference(Entity const& entity, std::set<int>& visitedIds);
		void CopyEntityToPrefab(Entity const& entity, Prefab& prefab);

		void SerializeCameraSettings(CameraManager& cameraManager);
		void DeserializeCameraSettings(CameraManager& cameraManager);

		Registry& registry; /**< The registry to access entities. */
		rapidjson::Document document; /**< The JSON document. */
		Config configuration; /**< The configuration settings. */
		PrefabManager& prefabManager; /**< The prefab manager. */
		LayerManager& layerManager; /**< The layer manager. */
		EventBus& eventBus; /**< The event bus. */
	};

	template <typename T, typename ObjectType>
	void Serializer::SerializeComponent(ObjectType& object, rapidjson::Value& objectValue, rapidjson::Document::AllocatorType& allocator)
	{
		// Early return if object doesn't have the component
		if (!object.HasComponent<T>())
		{
			return;
		}

		// Add additional components here

		// Get component reference (valid for both Entity and Prefab)
		const auto& component = object.GetComponent<T>();
		rapidjson::Value componentValue(rapidjson::kObjectType);

		if constexpr (std::is_same_v<T, ActiveComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			objectValue.AddMember("active", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, TransformComponent>)
		{
			rapidjson::Value position(rapidjson::kObjectType);
			position.AddMember("x", component.position.x, allocator);
			position.AddMember("y", component.position.y, allocator);
			componentValue.AddMember("position", position, allocator);

			rapidjson::Value scaleValue(rapidjson::kObjectType);
			scaleValue.AddMember("x", component.scale.x, allocator);
			scaleValue.AddMember("y", component.scale.y, allocator);
			componentValue.AddMember("scale", scaleValue, allocator);

			componentValue.AddMember("rotation", component.rotation, allocator);

			objectValue.AddMember("transform", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, RigidBodyComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			rapidjson::Value velocityValue(rapidjson::kObjectType);
			velocityValue.AddMember("x", component.velocity.x, allocator);
			velocityValue.AddMember("y", component.velocity.y, allocator);
			componentValue.AddMember("velocity", velocityValue, allocator);

			//serialize acceleration
			rapidjson::Value accelerationValue(rapidjson::kObjectType);
			accelerationValue.AddMember("x", component.acceleration.x, allocator);
			accelerationValue.AddMember("y", component.acceleration.y, allocator);
			componentValue.AddMember("acceleration", accelerationValue, allocator);

			//serialize force
			rapidjson::Value forceValue(rapidjson::kObjectType);
			forceValue.AddMember("x", component.force.x, allocator);
			forceValue.AddMember("y", component.force.y, allocator);
			componentValue.AddMember("force", forceValue, allocator);

			//serialize scalar properties
			componentValue.AddMember("mass", component.mass, allocator);
			componentValue.AddMember("useGravity", component.useGravity, allocator);
			componentValue.AddMember("gravityScale", component.gravityScale, allocator);
			componentValue.AddMember("dragCoefficient", component.dragCoefficient, allocator);

			objectValue.AddMember("rigidbody", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, RenderComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			componentValue.AddMember("mesh", static_cast<int>(component.meshType), allocator);

			rapidjson::Value shaderNameValue;
			shaderNameValue.SetString(component.shaderName.c_str(), static_cast<rapidjson::SizeType>(component.shaderName.length()), allocator);
			componentValue.AddMember("shader_name", shaderNameValue, allocator);

			rapidjson::Value textureNameValue;
			textureNameValue.SetString(component.textureName.c_str(), static_cast<rapidjson::SizeType>(component.textureName.length()), allocator);
			componentValue.AddMember("texture_name", textureNameValue, allocator);

			componentValue.AddMember("use_instancing", component.useInstancing, allocator);

			rapidjson::Value colorValue(rapidjson::kObjectType);
			colorValue.AddMember("r", component.color.r, allocator);
			colorValue.AddMember("g", component.color.g, allocator);
			colorValue.AddMember("b", component.color.b, allocator);
			componentValue.AddMember("color", colorValue, allocator);

			componentValue.AddMember("alpha", component.alpha, allocator);
			componentValue.AddMember("texture_width", component.textureWidth, allocator);
			componentValue.AddMember("texture_height", component.textureHeight, allocator);

			// Add 9-Slice Scaling Properties
			componentValue.AddMember("enable_nine_slice", component.enableNineSlice, allocator);

			rapidjson::Value borderValues(rapidjson::kObjectType);
			borderValues.AddMember("left", component.borderLeft, allocator);
			borderValues.AddMember("right", component.borderRight, allocator);
			borderValues.AddMember("top", component.borderTop, allocator);
			borderValues.AddMember("bottom", component.borderBottom, allocator);
			componentValue.AddMember("nine_slice_borders", borderValues, allocator);

			objectValue.AddMember("render", componentValue, allocator);

			return;
		}

		else if constexpr (std::is_same_v<T, BoxColliderComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			rapidjson::Value sizeValue(rapidjson::kObjectType);
			sizeValue.AddMember("x", component.size.x, allocator);
			sizeValue.AddMember("y", component.size.y, allocator);
			componentValue.AddMember("size", sizeValue, allocator);

			rapidjson::Value offsetValue(rapidjson::kObjectType);
			offsetValue.AddMember("x", component.offset.x, allocator);
			offsetValue.AddMember("y", component.offset.y, allocator);
			componentValue.AddMember("offset", offsetValue, allocator);

			componentValue.AddMember("isTrigger", component.isTrigger, allocator);
			componentValue.AddMember("isEnabled", component.isEnabled, allocator);

			objectValue.AddMember("boxcollider", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, CircleColliderComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			componentValue.AddMember("radius", component.radius, allocator);

			rapidjson::Value offsetValue(rapidjson::kObjectType);
			offsetValue.AddMember("x", component.offset.x, allocator);
			offsetValue.AddMember("y", component.offset.y, allocator);
			componentValue.AddMember("offset", offsetValue, allocator);

			componentValue.AddMember("isTrigger", component.isTrigger, allocator);
			componentValue.AddMember("isEnabled", component.isEnabled, allocator);

			objectValue.AddMember("circleCollider", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, TextComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			rapidjson::Value textValue;
			textValue.SetString(component.text.c_str(), allocator);
			componentValue.AddMember("text", textValue, allocator);

			rapidjson::Value fontNameValue;
			fontNameValue.SetString(component.fontName.c_str(), allocator);
			componentValue.AddMember("font_name", fontNameValue, allocator);

			rapidjson::Value sizeValue;
			sizeValue.SetInt(static_cast<int>(component.fontSize));
			componentValue.AddMember("size", sizeValue, allocator);

			rapidjson::Value colorValue(rapidjson::kObjectType);
			colorValue.AddMember("r", component.color.x, allocator);
			colorValue.AddMember("g", component.color.y, allocator);
			colorValue.AddMember("b", component.color.z, allocator);
			componentValue.AddMember("color", colorValue, allocator);

			componentValue.AddMember("alpha", component.alpha, allocator);

			objectValue.AddMember("text", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, AnimationComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			rapidjson::Value spriteSheetSize(rapidjson::kObjectType);
			spriteSheetSize.AddMember("width", component.sheetWidth, allocator);
			spriteSheetSize.AddMember("height", component.sheetHeight, allocator);
			componentValue.AddMember("sprite_sheet_size", spriteSheetSize, allocator);

			rapidjson::Value playOnce;
			playOnce.SetBool(component.playOnce);
			componentValue.AddMember("playOnce", playOnce, allocator);

			// Create JSON object for animation states
			rapidjson::Value animationState(rapidjson::kObjectType);
			for (const auto& [name, anim] : component.animations) {
				rapidjson::Value animValue(rapidjson::kObjectType);

				rapidjson::Value startFrame(rapidjson::kObjectType);
				startFrame.AddMember("x", anim.startX, allocator);
				startFrame.AddMember("y", anim.startY, allocator);
				animValue.AddMember("start_frame", startFrame, allocator);

				rapidjson::Value endFrame(rapidjson::kObjectType);
				endFrame.AddMember("x", anim.endX, allocator);
				endFrame.AddMember("y", anim.endY, allocator);
				animValue.AddMember("end_frame", endFrame, allocator);

				rapidjson::Value frameSize(rapidjson::kObjectType);
				frameSize.AddMember("width", anim.frameWidth, allocator);
				frameSize.AddMember("height", anim.frameHeight, allocator);
				animValue.AddMember("frame_size", frameSize, allocator);

				animValue.AddMember("animation_speed", anim.animationSpeed, allocator);

				rapidjson::Value animName;
				animName.SetString(name.c_str(), static_cast<rapidjson::SizeType>(name.length()), allocator);
				animationState.AddMember(animName, animValue, allocator);
			}
			componentValue.AddMember("animation_state", animationState, allocator);
			objectValue.AddMember("animation", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, UIComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			// Serialize UI type as a string
			rapidjson::Value uiTypeValue;
			std::string uiTypeStr;

			switch (component.type) {
			case UIType::BUTTON: uiTypeStr = "BUTTON"; break;
			case UIType::CHECKBOX: uiTypeStr = "CHECKBOX"; break;
			case UIType::SLIDER_TRACK: uiTypeStr = "SLIDER_TRACK"; break;
			case UIType::SLIDER_HANDLE: uiTypeStr = "SLIDER_HANDLE"; break;
			}

			uiTypeValue.SetString(uiTypeStr.c_str(), allocator);
			componentValue.AddMember("uiType", uiTypeValue, allocator);

			// Serialize additional properties based on type
			if (component.type == UIType::CHECKBOX) {
				componentValue.AddMember("checked", component.checked, allocator);
			}

			if (component.type == UIType::SLIDER_TRACK) {
				componentValue.AddMember("sliderValue", component.sliderValue, allocator);
			}

			if (component.type == UIType::SLIDER_HANDLE || component.type == UIType::SLIDER_TRACK) {
				componentValue.AddMember("linkedEntityId", component.linkedEntityId, allocator);
			}

			// Serialize multiple OnClick actions as an array
			if ((component.type == UIType::BUTTON || component.type == UIType::CHECKBOX) && !component.onClickActions.empty())
			{
				rapidjson::Value actionsArray(rapidjson::kArrayType);
				for (const std::string& action : component.onClickActions)
				{
					rapidjson::Value actionValue;
					actionValue.SetString(action.c_str(), allocator);
					actionsArray.PushBack(actionValue, allocator);
				}
				componentValue.AddMember("onClickActions", actionsArray, allocator);
			}

			// Serialize hover effect
			componentValue.AddMember("hasHoverEffect", component.hasHoverEffect, allocator);

			if (component.hasHoverEffect)
			{
				// Serialize spritesheet data (only if they are set)
				componentValue.AddMember("frameX", component.frameX, allocator);
				componentValue.AddMember("frameY", component.frameY, allocator);
				componentValue.AddMember("hoverFrameX", component.hoverFrameX, allocator);
				componentValue.AddMember("hoverFrameY", component.hoverFrameY, allocator);
				componentValue.AddMember("totalColumns", component.totalColumns, allocator);
				componentValue.AddMember("totalRows", component.totalRows, allocator);
				componentValue.AddMember("sheetWidth", component.sheetWidth, allocator);
				componentValue.AddMember("sheetHeight", component.sheetHeight, allocator);
			}

			objectValue.AddMember("ui", componentValue, allocator);
			return;
		}
		else if constexpr (std::is_same_v<T, LogicComponent>)
		{
			component.Serialize(objectValue, componentValue, allocator, registry.GetSystem<LogicSystem>());

			//rapidjson::Value boolVal;
			//boolVal.SetBool(component.isActive);
			//componentValue.AddMember("isActive", boolVal, allocator);

			//rapidjson::Value name;
			//name.SetString(component.scriptName.c_str(), static_cast<rapidjson::SizeType>(component.scriptName.length()), allocator);
			//componentValue.AddMember("name", name, allocator);

			//rapidjson::Value lang;
			//lang.SetInt(static_cast<int>(component.scriptLang));
			//componentValue.AddMember("scriptLang", lang, allocator);

			// variables //

			// variables //

			//AssetStore::GetScript();

			//for (std::pair<const std::string, std::pair<std::type_info&, void*>> v : component.vars) // serialize variables
			//{
			//    val.Clear();
			//    val.Set<v.second.first>(v.second.second, allocator);
			//    componentValue.AddMember(v.first, val, allocator);
			//}

			//objectValue.AddMember("logic", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, AudioComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			rapidjson::Value val;
			val.SetString(component.audio.c_str(), static_cast<rapidjson::SizeType>(component.audio.length()), allocator);
			componentValue.AddMember("name", val, allocator);

			rapidjson::Value vol;
			vol.SetFloat(component.volume);
			componentValue.AddMember("volume", vol, allocator);

			rapidjson::Value mute;
			mute.SetBool(component.mute);
			componentValue.AddMember("mute", mute, allocator);

			rapidjson::Value loop;
			loop.SetBool(component.loop);
			componentValue.AddMember("loop", loop, allocator);

			rapidjson::Value bpm;
			bpm.SetFloat(component.bpm);
			componentValue.AddMember("bpm", bpm, allocator);

			SerializeObjType("timeSig", componentValue, allocator, "top",
				component.timeSig.first, "bot", component.timeSig.second);
			//rapidjson::Value timeSig(rapidjson::kObjectType);
			//timeSig.AddMember("top", component.timeSig.first, allocator);
			//timeSig.AddMember("bot", component.timeSig.second, allocator);
			//componentValue.AddMember("timeSig", timeSig, allocator);

			rapidjson::Value playOnAwake;
			playOnAwake.SetBool(component.playOnAwake);
			componentValue.AddMember("playOnAwake", playOnAwake, allocator);

			rapidjson::Value grp;
			grp.SetInt(component.grp);
			componentValue.AddMember("grp", grp, allocator);

			objectValue.AddMember("audio", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, PrefabInstanceComponent>)
		{
			rapidjson::Value prefabName;
			prefabName.SetString(component.prefabName.c_str(), static_cast<rapidjson::SizeType>(component.prefabName.length()), allocator);
			componentValue.AddMember("prefab_name", prefabName, allocator);

			rapidjson::Value syncPrefab;
			syncPrefab.SetBool(component.syncWithPrefab);
			componentValue.AddMember("sync_prefab", syncPrefab, allocator);

			objectValue.AddMember("prefab_instance", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, ParentComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.inheritActive);
			componentValue.AddMember("inheritActive", boolVal, allocator);

			boolVal.SetBool(component.inheritTransform);
			componentValue.AddMember("inheritTransform", boolVal, allocator);

			// Serialize parent entity ID
			componentValue.AddMember("parentId", component.parent.GetId(), allocator);

			objectValue.AddMember("parent", componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, PersistOnLoadComponent>)
		{
			component.Serialize(objectValue, componentValue, allocator);

			return;
		}
		else if constexpr (std::is_same_v<T, ParticleComponent>)
		{
			rapidjson::Value boolVal;
			boolVal.SetBool(component.isActive);
			componentValue.AddMember("isActive", boolVal, allocator);

			rapidjson::Value intVal;
			intVal.SetInt(component.renderOption);
			componentValue.AddMember("renderOption", intVal, allocator);

			boolVal.SetBool(component.usePhysics);
			componentValue.AddMember("usePhysics", boolVal, allocator);

			intVal.SetInt(static_cast<int>(component.countEmission));
			componentValue.AddMember("countEmission", intVal, allocator);

			rapidjson::Value floatVal;

			// Emitters
			rapidjson::Value emitters(rapidjson::kObjectType);
			for (size_t i{}; i < component.emission.size(); ++i)
			{
				if (!component.emission[i].active) continue;

				rapidjson::Value emitter(rapidjson::kObjectType);

				boolVal.SetBool(component.emission[i].loop);
				emitter.AddMember("loop", boolVal, allocator);

				floatVal.SetFloat(component.emission[i].elapsedTime);
				emitter.AddMember("elapsedTime", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].rate);
				emitter.AddMember("rate", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].tLoop);
				emitter.AddMember("tLoop", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].minLifeTime);
				emitter.AddMember("minLifeTime", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].maxLifeTime);
				emitter.AddMember("maxLifeTime", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].minRot);
				emitter.AddMember("minRot", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].maxRot);
				emitter.AddMember("maxRot", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].minSpinVel);
				emitter.AddMember("minSpinVel", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].maxSpinVel);
				emitter.AddMember("maxSpinVel", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].minSpinAccel);
				emitter.AddMember("minSpinAccel", floatVal, allocator);

				floatVal.SetFloat(component.emission[i].maxSpinAccel);
				emitter.AddMember("maxSpinAccel", floatVal, allocator);

				rapidjson::Value minPos(rapidjson::kObjectType);
				minPos.AddMember("x", component.emission[i].minPos.x, allocator);
				minPos.AddMember("y", component.emission[i].minPos.y, allocator);
				emitter.AddMember("minPos", minPos, allocator);

				rapidjson::Value maxPos(rapidjson::kObjectType);
				maxPos.AddMember("x", component.emission[i].maxPos.x, allocator);
				maxPos.AddMember("y", component.emission[i].maxPos.y, allocator);
				emitter.AddMember("maxPos", maxPos, allocator);

				rapidjson::Value minScale(rapidjson::kObjectType);
				minScale.AddMember("x", component.emission[i].minScale.x, allocator);
				minScale.AddMember("y", component.emission[i].minScale.y, allocator);
				emitter.AddMember("minScale", minScale, allocator);

				rapidjson::Value maxScale(rapidjson::kObjectType);
				maxScale.AddMember("x", component.emission[i].maxScale.x, allocator);
				maxScale.AddMember("y", component.emission[i].maxScale.y, allocator);
				emitter.AddMember("maxScale", maxScale, allocator);

				rapidjson::Value minVel(rapidjson::kObjectType);
				minVel.AddMember("x", component.emission[i].minVel.x, allocator);
				minVel.AddMember("y", component.emission[i].minVel.y, allocator);
				emitter.AddMember("minVel", minVel, allocator);

				rapidjson::Value maxVel(rapidjson::kObjectType);
				maxVel.AddMember("x", component.emission[i].maxVel.x, allocator);
				maxVel.AddMember("y", component.emission[i].maxVel.y, allocator);
				emitter.AddMember("maxVel", maxVel, allocator);

				rapidjson::Value minScaleVel(rapidjson::kObjectType);
				minScaleVel.AddMember("x", component.emission[i].minScaleVel.x, allocator);
				minScaleVel.AddMember("y", component.emission[i].minScaleVel.y, allocator);
				emitter.AddMember("minScaleVel", minScaleVel, allocator);

				rapidjson::Value maxScaleVel(rapidjson::kObjectType);
				maxScaleVel.AddMember("x", component.emission[i].maxScaleVel.x, allocator);
				maxScaleVel.AddMember("y", component.emission[i].maxScaleVel.y, allocator);
				emitter.AddMember("maxScaleVel", maxScaleVel, allocator);

				rapidjson::Value minAccel(rapidjson::kObjectType);
				minAccel.AddMember("x", component.emission[i].minAccel.x, allocator);
				minAccel.AddMember("y", component.emission[i].minAccel.y, allocator);
				emitter.AddMember("minAccel", minAccel, allocator);

				rapidjson::Value maxAccel(rapidjson::kObjectType);
				maxAccel.AddMember("x", component.emission[i].maxAccel.x, allocator);
				maxAccel.AddMember("y", component.emission[i].maxAccel.y, allocator);
				emitter.AddMember("maxAccel", maxAccel, allocator);

				rapidjson::Value minScaleAccel(rapidjson::kObjectType);
				minScaleAccel.AddMember("x", component.emission[i].minScaleAccel.x, allocator);
				minScaleAccel.AddMember("y", component.emission[i].minScaleAccel.y, allocator);
				emitter.AddMember("minScaleAccel", minScaleAccel, allocator);

				rapidjson::Value maxScaleAccel(rapidjson::kObjectType);
				maxScaleAccel.AddMember("x", component.emission[i].maxScaleAccel.x, allocator);
				maxScaleAccel.AddMember("y", component.emission[i].maxScaleAccel.y, allocator);
				emitter.AddMember("maxScaleAccel", maxScaleAccel, allocator);

				rapidjson::Value minCol(rapidjson::kObjectType);
				minCol.AddMember("r", component.emission[i].minCol.r, allocator);
				minCol.AddMember("g", component.emission[i].minCol.g, allocator);
				minCol.AddMember("b", component.emission[i].minCol.b, allocator);
				minCol.AddMember("a", component.emission[i].minCol.a, allocator);
				emitter.AddMember("minCol", minCol, allocator);

				rapidjson::Value maxCol(rapidjson::kObjectType);
				maxCol.AddMember("r", component.emission[i].maxCol.r, allocator);
				maxCol.AddMember("g", component.emission[i].maxCol.g, allocator);
				maxCol.AddMember("b", component.emission[i].maxCol.b, allocator);
				maxCol.AddMember("a", component.emission[i].maxCol.a, allocator);
				emitter.AddMember("maxCol", maxCol, allocator);

				rapidjson::Value minColVel(rapidjson::kObjectType);
				minColVel.AddMember("r", component.emission[i].minColVel.r, allocator);
				minColVel.AddMember("g", component.emission[i].minColVel.g, allocator);
				minColVel.AddMember("b", component.emission[i].minColVel.b, allocator);
				minColVel.AddMember("a", component.emission[i].minColVel.a, allocator);
				emitter.AddMember("minColVel", minColVel, allocator);

				rapidjson::Value maxColVel(rapidjson::kObjectType);
				maxColVel.AddMember("r", component.emission[i].maxColVel.r, allocator);
				maxColVel.AddMember("g", component.emission[i].maxColVel.g, allocator);
				maxColVel.AddMember("b", component.emission[i].maxColVel.b, allocator);
				maxColVel.AddMember("a", component.emission[i].maxColVel.a, allocator);
				emitter.AddMember("maxColVel", maxColVel, allocator);

				rapidjson::Value minColAccel(rapidjson::kObjectType);
				minColAccel.AddMember("r", component.emission[i].minColAccel.r, allocator);
				minColAccel.AddMember("g", component.emission[i].minColAccel.g, allocator);
				minColAccel.AddMember("b", component.emission[i].minColAccel.b, allocator);
				minColAccel.AddMember("a", component.emission[i].minColAccel.a, allocator);
				emitter.AddMember("minColAccel", minColAccel, allocator);

				rapidjson::Value maxColAccel(rapidjson::kObjectType);
				maxColAccel.AddMember("r", component.emission[i].maxColAccel.r, allocator);
				maxColAccel.AddMember("g", component.emission[i].maxColAccel.g, allocator);
				maxColAccel.AddMember("b", component.emission[i].maxColAccel.b, allocator);
				maxColAccel.AddMember("a", component.emission[i].maxColAccel.a, allocator);
				emitter.AddMember("maxColAccel", maxColAccel, allocator);

				rapidjson::Value id;
				id.SetString(std::to_string(i).c_str(), static_cast<rapidjson::SizeType>(std::to_string(i).length()), allocator);
				emitters.AddMember(id, emitter, allocator);
			}
			componentValue.AddMember("emitters", emitters, allocator);

			objectValue.AddMember("particles", componentValue, allocator);

			return;
		}

		else Logger::Error("Unsupported component type for serialization");
	}

	template <typename T, typename ObjectType>
	void Serializer::DeserializeComponent(ObjectType& object, const rapidjson::Value& componentVal)
	{
		// add components here+
		if constexpr (std::is_same_v<T, ActiveComponent>)
		{
			bool isActive;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid active component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();
			}
			else
			{
				isActive = componentVal["isActive"].GetBool();
			}

			if constexpr (std::is_same_v<ObjectType, Entity>)
			{
				// Update existing active component instead of adding new one
				auto& active = object.GetComponent<ActiveComponent>();
				active.isActive = isActive;
			}
			else if constexpr (std::is_same_v<ObjectType, Prefab>)
			{
				object.AddComponent<ActiveComponent>(isActive);
			}

			return;
		}

		else if constexpr (std::is_same_v<T, TransformComponent>)
		{
			PopplioMath::Vec2f position, scale;
			double rot;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid transform component structure");
					return;
				}

				if (!componentVal.HasMember("position"))
				{
					position = { 0.0f, 0.0f };
					Logger::Warning("Invalid structure, using defaults");
				}
				else position = { componentVal["position"]["x"].GetFloat(),
					componentVal["position"]["y"].GetFloat() };

				if (!componentVal.HasMember("scale"))
				{
					scale = { 1.0f, 1.0f };
					Logger::Warning("Invalid structure, using defaults");
				}
				else scale = { componentVal["scale"]["x"].GetFloat(),
					componentVal["scale"]["y"].GetFloat() };

				if (!componentVal.HasMember("rotation"))
				{
					rot = 0.0;
					Logger::Warning("Invalid structure, using defaults");
				}
				else rot = componentVal["rotation"].GetDouble();
			}
			else
			{
				position = { componentVal["position"]["x"].GetFloat(),
					componentVal["position"]["y"].GetFloat() };
				scale = { componentVal["scale"]["x"].GetFloat(),
					componentVal["scale"]["y"].GetFloat() };
				rot = componentVal["rotation"].GetDouble();
			}

			if constexpr (std::is_same_v<ObjectType, Entity>)
			{
				// Update existing transform component instead of adding new one
				auto& transform = object.GetComponent<TransformComponent>();
				transform.position = PopplioMath::Vec2f(position.x, position.y);
				transform.scale = PopplioMath::Vec2f(scale.x, scale.y);
				transform.rotation = rot;
			}
			else if constexpr (std::is_same_v<ObjectType, Prefab>)
			{
				object.AddComponent<TransformComponent>(position.x, position.y, scale.x, scale.y, rot);
			}

			return;
		}

		else if constexpr (std::is_same_v<T, RigidBodyComponent>)
		{
			bool isActive, useGravity;

			float mass, gravityScale, vel_x, vel_y, dragCoefficient;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid rigidbody component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();

				if (!componentVal.HasMember("velocity"))
				{
					vel_x = 0.0f;
					vel_y = 0.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else
				{
					vel_x = componentVal["velocity"]["x"].GetFloat();
					vel_y = componentVal["velocity"]["y"].GetFloat();
				}

				if (!componentVal.HasMember("acceleration"))
				{
					// ???
					Logger::Warning("Invalid structure, using defaults");
				}
				if (!componentVal.HasMember("force"))
				{
					// ???
					Logger::Warning("Invalid structure, using defaults");
				}
				if (!componentVal.HasMember("mass"))
				{
					mass = 1.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else mass = componentVal["mass"].GetFloat();

				if (!componentVal.HasMember("useGravity"))
				{
					useGravity = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else useGravity = componentVal["useGravity"].GetBool();

				if (!componentVal.HasMember("gravityScale"))
				{
					gravityScale = 1.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else gravityScale = componentVal["gravityScale"].GetFloat();

				if (!componentVal.HasMember("dragCoefficient"))
				{
					dragCoefficient = 0.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else dragCoefficient = componentVal["dragCoefficient"].GetFloat();
			}
			else
			{
				//read all the values from JSON
				isActive = componentVal["isActive"].GetBool();

				mass = componentVal["mass"].GetFloat();
				useGravity = componentVal["useGravity"].GetBool();
				gravityScale = componentVal["gravityScale"].GetFloat();
				vel_x = componentVal["velocity"]["x"].GetFloat();
				vel_y = componentVal["velocity"]["y"].GetFloat();
				dragCoefficient = componentVal["dragCoefficient"].GetFloat();
			}

			object.AddComponent<RigidBodyComponent>(
				mass,
				useGravity,
				gravityScale,
				vel_x,
				vel_y,
				dragCoefficient
			);

			object.GetComponent<RigidBodyComponent>().isActive = isActive;
		}

		else if constexpr (std::is_same_v<T, RenderComponent>)
		{
			bool isActive, useInstancing;

			MeshType mesh;
			std::string shaderName, textureName;
			Color color;
			float alpha;
			int textureWidth, textureHeight; // Initialize width and height

			bool enableNineSlice;
			float borderLeft, borderRight, borderTop, borderBottom;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid render component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();

				if (!componentVal.HasMember("mesh"))
				{
					mesh = MeshType::Quad;
					Logger::Warning("Invalid structure, using defaults");
				}
				else mesh = static_cast<MeshType>(componentVal["mesh"].GetInt());

				if (!componentVal.HasMember("shader_name"))
				{
					shaderName = "";
					Logger::Warning("Invalid structure, using defaults");
				}
				else shaderName = componentVal["shader_name"].GetString();

				if (!componentVal.HasMember("texture_name"))
				{
					textureName = "";
					Logger::Warning("Invalid structure, using defaults");
				}
				else textureName = componentVal["texture_name"].GetString();

				if (!componentVal.HasMember("use_instancing"))
				{
					useInstancing = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else useInstancing = componentVal["use_instancing"].GetBool();

				if (!componentVal.HasMember("color"))
				{
					color = { 1.0f, 1.0f, 1.0f };
					Logger::Warning("Invalid structure, using defaults");
				}
				else
				{
					color = { componentVal["color"]["r"].GetFloat(),
						componentVal["color"]["g"].GetFloat(),
						componentVal["color"]["b"].GetFloat() };
				}

				if (!componentVal.HasMember("alpha"))
				{
					alpha = 1.0f;
					Logger::Warning("Invalid alpha structure, using defaults");
				}
				else alpha = componentVal["alpha"].GetFloat();

				//  Load 9-Slice Scaling Properties Safely
				if (!componentVal.HasMember("enable_nine_slice"))
				{
					enableNineSlice = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else enableNineSlice = componentVal["enable_nine_slice"].GetBool();

				if (!componentVal.HasMember("nine_slice_borders"))
				{
					borderLeft = 0.0f;
					borderRight = 0.0f;
					borderTop = 0.0f;
					borderBottom = 0.0f;
					Logger::Warning("Invalid nine slice border structure, using defaults");
				}
				else
				{
					const auto& borderVals = componentVal["nine_slice_borders"];
					if (borderVals.HasMember("left")) borderLeft = borderVals["left"].GetFloat();
					if (borderVals.HasMember("right")) borderRight = borderVals["right"].GetFloat();
					if (borderVals.HasMember("top")) borderTop = borderVals["top"].GetFloat();
					if (borderVals.HasMember("bottom")) borderBottom = borderVals["bottom"].GetFloat();
				}
			}
			else
			{
				isActive = componentVal["isActive"].GetBool();

				mesh = static_cast<MeshType>(componentVal["mesh"].GetInt());
				shaderName = componentVal["shader_name"].GetString();
				textureName = componentVal["texture_name"].GetString();
				useInstancing = componentVal["use_instancing"].GetBool();
				color = { componentVal["color"]["r"].GetFloat(),
					componentVal["color"]["g"].GetFloat(), componentVal["color"]["b"].GetFloat() };
				alpha = componentVal["alpha"].GetFloat();

				// Load 9-Slice Scaling Properties in Unsafe Mode
				enableNineSlice = componentVal["enable_nine_slice"].GetBool();
				const auto& borderVals = componentVal["nine_slice_borders"];
				borderLeft = borderVals["left"].GetFloat();
				borderRight = borderVals["right"].GetFloat();
				borderTop = borderVals["top"].GetFloat();
				borderBottom = borderVals["bottom"].GetFloat();
			}

			// Retrieve texture dimensions if a texture is assigned
			if (!textureName.empty())
			{
				auto [width, height] = Popplio::AssetStore::GetTextureSize(textureName);
				textureWidth = width;
				textureHeight = height;
			}

			object.AddComponent<RenderComponent>(mesh, shaderName, textureName, useInstancing, color.ToGLMVec3(), alpha, textureWidth, textureHeight
				, enableNineSlice, borderLeft, borderRight, borderTop, borderBottom);
			auto& renderComp = object.GetComponent<RenderComponent>();
			renderComp.isActive = isActive;
		}

		else if constexpr (std::is_same_v<T, BoxColliderComponent>)
		{
			bool isActive, isTrigger, isEnabled;
			PopplioMath::Vec2f size, offset;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid box collider component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();

				if (!componentVal.HasMember("size"))
				{
					size = { 1.0f, 1.0f };
					Logger::Warning("Invalid structure, using defaults");
				}
				else size = { componentVal["size"]["x"].GetFloat(),
					componentVal["size"]["y"].GetFloat() };

				if (!componentVal.HasMember("offset"))
				{
					offset = { 0.0f, 0.0f };
					Logger::Warning("Invalid structure, using defaults");
				}
				else offset = { componentVal["offset"]["x"].GetFloat(),
					componentVal["offset"]["y"].GetFloat() };

				if (!componentVal.HasMember("isTrigger"))
				{
					isTrigger = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isTrigger = componentVal["isTrigger"].GetBool();

				if (!componentVal.HasMember("isEnabled"))
				{
					isEnabled = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isEnabled = componentVal["isEnabled"].GetBool();
			}
			else
			{
				isActive = componentVal["isActive"].GetBool();
				size = { componentVal["size"]["x"].GetFloat(),
					componentVal["size"]["y"].GetFloat() };
				offset = { componentVal["offset"]["x"].GetFloat(),
					componentVal["offset"]["y"].GetFloat() };
				isTrigger = componentVal["isTrigger"].GetBool();
				isEnabled = componentVal["isEnabled"].GetBool();
			}

			object.AddComponent<BoxColliderComponent>(size.x, size.y, offset.x, offset.y, isTrigger, isEnabled);
			object.GetComponent<BoxColliderComponent>().isActive = isActive;

			return;

			//entity.AddComponent<BoxColliderComponent>(size.X(), size.Y(), offset.X(), offset.Y());
		}

		else if constexpr (std::is_same_v<T, CircleColliderComponent>)
		{
			const bool isActive, isTrigger, isEnabled;
			float radius;
			PopplioMath::Vec2f offset;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid circle collider component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();

				if (!componentVal.HasMember("radius"))
				{
					radius = 1.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else radius = componentVal["radius"].GetFloat();

				if (!componentVal.HasMember("offset"))
				{
					offset = { 0.0f, 0.0f };
					Logger::Warning("Invalid structure, using defaults");
				}
				else offset = { componentVal["offset"]["x"].GetFloat(),
					componentVal["offset"]["y"].GetFloat() };

				if (!componentVal.HasMember("isTrigger"))
				{
					isTrigger = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isTrigger = componentVal["isTrigger"].GetBool();

				if (!componentVal.HasMember("isEnabled"))
				{
					isEnabled = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isEnabled = componentVal["isEnabled"].GetBool();
			}
			else
			{
				isActive = componentVal["isActive"].GetBool();
				radius = componentVal["radius"].GetFloat();
				offset = { componentVal["offset"]["x"].GetFloat(),
					componentVal["offset"]["y"].GetFloat() };
				isTrigger = componentVal["isTrigger"].GetBool();
				isEnabled = componentVal["isEnabled"].GetBool();
			}

			object.AddComponent<CircleColliderComponent>(radius, offset.x, offset.y, isTrigger, isEnabled);
			object.GetComponent<CircleColliderComponent>().isActive = isActive;

			return;
		}

		else if constexpr (std::is_same_v<T, TextComponent>)
		{
			bool isActive;
			std::string text, fontName;
			float alpha, r, g, b;
			unsigned int size;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid text component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();

				if (!componentVal.HasMember("text"))
				{
					text = "";
					Logger::Warning("Invalid structure, using defaults");
				}
				else text = componentVal["text"].GetString();

				if (!componentVal.HasMember("font_name"))
				{
					fontName = "";
					Logger::Warning("Invalid structure, using defaults");
				}
				else fontName = componentVal["font_name"].GetString();

				if (!componentVal.HasMember("size"))
				{
					size = 32;
					Logger::Warning("Invalid structure, using defaults");
				}
				else size = static_cast<unsigned int>(componentVal["size"].GetInt());

				if (!componentVal.HasMember("color"))
				{
					r = 1.0f;
					g = 1.0f;
					b = 1.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else
				{
					r = componentVal["color"]["r"].GetFloat();
					g = componentVal["color"]["g"].GetFloat();
					b = componentVal["color"]["b"].GetFloat();
				}

				if (!componentVal.HasMember("alpha"))
				{
					alpha = 1.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else alpha = componentVal["alpha"].GetFloat();

			}
			else
			{
				isActive = componentVal["isActive"].GetBool();
				text = componentVal["text"].GetString();
				fontName = componentVal["font_name"].GetString();
				r = componentVal["color"]["r"].GetFloat();
				g = componentVal["color"]["g"].GetFloat();
				b = componentVal["color"]["b"].GetFloat();
				alpha = componentVal["alpha"].GetFloat();
				size = static_cast<unsigned int>(componentVal["size"].GetInt());
			}

			object.AddComponent<TextComponent>(text, fontName, size, alpha);
			object.GetComponent<TextComponent>().isActive = isActive;
			//object.GetComponent<TextComponent>().fontSize = size;

			object.GetComponent<TextComponent>().color.x = r;
			object.GetComponent<TextComponent>().color.y = g;
			object.GetComponent<TextComponent>().color.z = b;

			return;
		}

		else if constexpr (std::is_same_v<T, AnimationComponent>)
		{
			bool isActive, playOnce;
			float sheetWidth, sheetHeight;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid animation component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();

				if (!componentVal.HasMember("sprite_sheet_size"))
				{
					sheetWidth = 1.0f;
					sheetHeight = 1.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else
				{
					sheetWidth = componentVal["sprite_sheet_size"]["width"].GetFloat();
					sheetHeight = componentVal["sprite_sheet_size"]["height"].GetFloat();
				}

				if (!componentVal.HasMember("playOnce"))
				{
					playOnce = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else playOnce = componentVal["playOnce"].GetBool();
			}
			else
			{
				isActive = componentVal["isActive"].GetBool();

				// Get basic animation properties
				sheetWidth = componentVal["sprite_sheet_size"]["width"].GetFloat();
				sheetHeight = componentVal["sprite_sheet_size"]["height"].GetFloat();

				playOnce = componentVal["playOnce"].GetBool();
			}

			// Add component first
			object.AddComponent<AnimationComponent>();
			object.GetComponent<AnimationComponent>().isActive = isActive;
			object.GetComponent<AnimationComponent>().playOnce = playOnce;

			// Get reference to component and initialize it
			auto& animComp = object.GetComponent<AnimationComponent>();
			animComp.Initialize(sheetWidth, sheetHeight);

			// check
			if (GetConfiguration().safeMode)
			{
				if (!componentVal.HasMember("animation_state"))
				{
					Logger::Warning("Invalid structure, using defaults"); // no animations
					return;
				}
			}

			// Parse all animations
			const auto& animations = componentVal["animation_state"].GetObject();
			for (auto it = animations.MemberBegin(); it != animations.MemberEnd(); ++it) {
				const std::string& animName = it->name.GetString();
				const auto& animData = it->value;

				if (!animData.HasMember("start_frame") || !animData.HasMember("end_frame") ||
					!animData.HasMember("animation_speed") || !animData.HasMember("frame_size"))
				{
					Logger::Warning("Animation '" + animName + "' has invalid structure");
					continue;
				}

				// Start and End frame
				int startX = animData["start_frame"]["x"].GetInt();
				int startY = animData["start_frame"]["y"].GetInt();
				int endX = animData["end_frame"]["x"].GetInt();
				int endY = animData["end_frame"]["y"].GetInt();

				//Frame size
				float frameWidth = animData["frame_size"]["width"].GetFloat();
				float frameHeight = animData["frame_size"]["height"].GetFloat();

				float speed = animData["animation_speed"].GetFloat();

				animComp.AddAnimation(animName, startX, startY, endX, endY, speed, frameWidth, frameHeight);
			}

			return;
		}

		else if constexpr (std::is_same_v<T, UIComponent>)
		{
			bool isActive;
			UIType type = UIType::BUTTON;
			bool checked;
			float sliderValue;
			int linkedEntityId;
			std::vector<std::string> onClickActions;

			// Spritesheet properties
			int frameX, frameY;
			int hoverFrameX, hoverFrameY;

			int totalColumns;
			int totalRows;

			float sheetWidth;
			float sheetHeight;

			bool hasHoverEffect;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid UI component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();

				if (componentVal.HasMember("uiType") && componentVal["uiType"].IsString()) {
					std::string uiTypeStr = componentVal["uiType"].GetString();
					if (uiTypeStr == "BUTTON") type = UIType::BUTTON;
					else if (uiTypeStr == "CHECKBOX") type = UIType::CHECKBOX;
					else if (uiTypeStr == "SLIDER_TRACK") type = UIType::SLIDER_TRACK;
					else if (uiTypeStr == "SLIDER_HANDLE") type = UIType::SLIDER_HANDLE;
					else Logger::Warning("Unknown UI type: " + uiTypeStr);
				}
				else
				{
					type = UIType::BUTTON;
					Logger::Warning("Invalid UItype structure, using defaults");
				}

				//if (type == UIType::CHECKBOX && !componentVal.HasMember("checked"))
				//{
				//	checked = false;
				//	Logger::Warning("Invalid checked structure, using defaults");
				//}
				//else if (type != UIType::CHECKBOX)
				//else checked = componentVal["checked"].GetBool();

				if (type == UIType::CHECKBOX)
				{
					if (!componentVal.HasMember("checked"))
					{
						Logger::Warning("Invalid checked structure, using defaults");
						checked = false;
					}
					else
						checked = componentVal["checked"].GetBool();
				}
				else
				{
					checked = false;
				}

				if (type == UIType::SLIDER_TRACK)
				{
					if (!componentVal.HasMember("sliderValue"))
					{
						sliderValue = 0.5f;
						Logger::Warning("Invalid sliderValue structure, using defaults");
					}
					else sliderValue = componentVal["sliderValue"].GetFloat();
				}

				if (type == UIType::SLIDER_HANDLE || type == UIType::SLIDER_TRACK)
				{
					if (!componentVal.HasMember("linkedEntityId"))
					{
						linkedEntityId = -1;
						Logger::Warning("Invalid linkedEntityId structure, using defaults");
					}
					else linkedEntityId = componentVal["linkedEntityId"].GetInt();
				}

				// Deserialize OnClick actions
				if (type == UIType::BUTTON || type == UIType::CHECKBOX)
				{
					if (componentVal.HasMember("onClickActions") && componentVal["onClickActions"].IsArray())
					{
						for (const auto& actionValue : componentVal["onClickActions"].GetArray())
						{
							if (actionValue.IsString())
							{
								onClickActions.push_back(actionValue.GetString());
							}
						}
					}

					if (onClickActions.empty())
					{
						onClickActions.push_back("None");
						Logger::Warning("[UIComponent] No OnClickActions found. Defaulting to 'None'.");
					}
				}

				// Deserialize hover effect
				if (!componentVal.HasMember("hasHoverEffect")) {
					hasHoverEffect = false;
					Logger::Warning("Invalid hasHoverEffect structure, using defaults");
				}
				else hasHoverEffect = componentVal["hasHoverEffect"].GetBool();

				if (hasHoverEffect)
				{
					// Deserialize spritesheet properties if they exist
					if (!componentVal.HasMember("frameX"))
					{
						frameX = 0;
						Logger::Warning("Invalid frameX structure, using defaults");
					}
					else frameX = componentVal["frameX"].GetInt();

					if (!componentVal.HasMember("frameY"))
					{
						frameY = 0;
						Logger::Warning("Invalid frameY structure, using defaults");
					}
					else frameY = componentVal["frameY"].GetInt();

					if (!componentVal.HasMember("hoverFrameX"))
					{
						hoverFrameX = 0;
						Logger::Warning("Invalid hoverFrameX structure, using defaults");
					}
					else hoverFrameX = componentVal["hoverFrameX"].GetInt();

					if (!componentVal.HasMember("hoverFrameY"))
					{
						hoverFrameY = 0;
						Logger::Warning("Invalid hoverFrameY structure, using defaults");
					}
					else hoverFrameY = componentVal["hoverFrameY"].GetInt();

					if (!componentVal.HasMember("totalColumns"))
					{
						totalColumns = 1;
						Logger::Warning("Invalid totalColumns structure, using defaults");
					}
					else totalColumns = componentVal["totalColumns"].GetInt();

					if (!componentVal.HasMember("totalRows"))
					{
						totalRows = 1;
						Logger::Warning("Invalid totalRows structure, using defaults");
					}
					else totalRows = componentVal["totalRows"].GetInt();

					if (!componentVal.HasMember("sheetWidth"))
					{
						sheetWidth = 0.0f;
						Logger::Warning("Invalid sheetWidth structure, using defaults");
					}
					else sheetWidth = componentVal["sheetWidth"].GetFloat();

					if (!componentVal.HasMember("sheetHeight"))
					{
						sheetHeight = 0.0f;
						Logger::Warning("Invalid sheetHeight structure, using defaults");
					}
					else sheetHeight = componentVal["sheetHeight"].GetFloat();
				}
			}
			else // Non-Safe Mode
			{
				isActive = componentVal["isActive"].GetBool();
				std::string uiTypeStr = componentVal["uiType"].GetString();

				if (uiTypeStr == "BUTTON") type = UIType::BUTTON;
				else if (uiTypeStr == "CHECKBOX") type = UIType::CHECKBOX;
				else if (uiTypeStr == "SLIDER_TRACK") type = UIType::SLIDER_TRACK;
				else if (uiTypeStr == "SLIDER_HANDLE") type = UIType::SLIDER_HANDLE;

				if (type == UIType::CHECKBOX) {
					checked = componentVal["checked"].GetBool();
				}

				if (type == UIType::SLIDER_HANDLE) {
					sliderValue = componentVal["sliderValue"].GetFloat();
				}

				if (type == UIType::SLIDER_TRACK || type == UIType::SLIDER_HANDLE) {
					linkedEntityId = componentVal["linkedEntityId"].GetInt();
				}

				if ((type == UIType::BUTTON || type == UIType::CHECKBOX) &&
					componentVal.HasMember("onClickActions") && componentVal["onClickActions"].IsArray())
				{
					for (const auto& actionValue : componentVal["onClickActions"].GetArray())
					{
						onClickActions.push_back(actionValue.GetString());
					}
				}

				// Deserialize hover effect (without checks)
				hasHoverEffect = componentVal["hasHoverEffect"].GetBool();

				if (hasHoverEffect)
				{
					frameX = componentVal["frameX"].GetInt();
					frameY = componentVal["frameY"].GetInt();
					hoverFrameX = componentVal["hoverFrameX"].GetInt();
					hoverFrameY = componentVal["hoverFrameY"].GetInt();
					totalColumns = componentVal["totalColumns"].GetInt();
					totalRows = componentVal["totalRows"].GetInt();
					sheetWidth = componentVal["sheetWidth"].GetFloat();
					sheetHeight = componentVal["sheetHeight"].GetFloat();
				}
			}

			// Assign the values to UIComponent
			object.AddComponent<UIComponent>(
				type, isActive, checked, sliderValue, linkedEntityId,
				hasHoverEffect, frameX, frameY, hoverFrameX, hoverFrameY,
				totalColumns, totalRows, sheetWidth, sheetHeight, onClickActions);

			//auto& ui = object.GetComponent<UIComponent>();
			//ui.isActive = isActive;

			//ui.checked = checked;
			//ui.sliderValue = sliderValue;
			//ui.linkedEntityId = linkedEntityId;
			//ui.onClickActions = onClickActions;
			//ui.hasHoverEffect = hasHoverEffect;

			// Assign optional spritesheet data
			/*if (frameX) ui.frameX = frameX;
			if (frameY) ui.frameY = frameY;
			if (hoverFrameX) ui.hoverFrameX = hoverFrameX;
			if (hoverFrameY) ui.hoverFrameY = hoverFrameY;
			if (totalColumns) ui.totalColumns = totalColumns;
			if (totalRows) ui.totalRows = totalRows;
			if (sheetWidth) ui.sheetWidth = sheetWidth;
			if (sheetHeight) ui.sheetHeight = sheetHeight;*/

			return;
		}


		else if constexpr (std::is_same_v<T, LogicComponent>)
		{
			LogicComponent::Deserialize(componentVal, object, GetConfiguration().safeMode);

			//bool isActive;
			//std::string s;
			//ScriptLang lang;

			//if (GetConfiguration().safeMode)
			//{
		   //             if (!componentVal.IsObject())
		   //             {
		   //                 Logger::Error("Invalid logic component structure");
		   //                 return;
		   //             }

		   //             if (!componentVal.HasMember("isActive"))
		   //             {
		   //                 isActive = true;
		   //                 Logger::Warning("Invalid structure, using defaults");
		   //             }
		   //             else isActive = componentVal["isActive"].GetBool();

		   //             if (!componentVal.HasMember("name"))
		   //             {
		   //                 s = "";
		   //                 Logger::Warning("Invalid structure, using defaults");
		   //             }
		   //             else s = componentVal["name"].GetString();

			//	if (!componentVal.HasMember("scriptLang"))
			//	{
			//		lang = ScriptLang::UNASSIGNED;
			//		Logger::Warning("Invalid structure, using defaults");
			//	}
			//	else lang = static_cast<ScriptLang>(componentVal["scriptLang"].GetInt());
			//}
			//else
			//{
			//	isActive = componentVal["isActive"].GetBool();
			//	s = componentVal["name"].GetString();
			//	lang = static_cast<ScriptLang>(componentVal["scriptLang"].GetInt());
			//}

			////std::map<std::string, void*> vars{};

			////for (auto it = componentVal.MemberBegin(); it != componentVal.MemberEnd(); ++it) // deserialize variables
			////{
			////    if (it->name.GetString() == "name") continue;
			////    
			////    vars.emplace(static_cast<std::string>(it->name), it->value);
			////}

			////object.AddComponent<LogicComponent>(s, vars);

			//// TODO serialize script vars

			//object.AddComponent<LogicComponent>(s);
   //         object.GetComponent<LogicComponent>().isActive = isActive;
   //         object.GetComponent<LogicComponent>().scriptLang = lang;

			return;
		}

		else if constexpr (std::is_same_v<T, AudioComponent>)
		{
			bool isActive, loop, playOnAwake, mute;
			std::string s;
			float vol, bpm;
			std::pair<int, int> timeSig;
			int grp;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid audio component structure");
					return;
				}

				if (!componentVal.HasMember("isActive"))
				{
					isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else isActive = componentVal["isActive"].GetBool();

				if (!componentVal.HasMember("name"))
				{
					s = "";
					Logger::Warning("Invalid structure, using defaults");
				}
				else s = componentVal["name"].GetString();

				if (!componentVal.HasMember("volume"))
				{
					vol = 1.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else vol = componentVal["volume"].GetFloat();

				if (!componentVal.HasMember("mute"))
				{
					mute = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else mute = componentVal["mute"].GetBool();

				if (!componentVal.HasMember("loop"))
				{
					loop = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else loop = componentVal["loop"].GetBool();

				if (!componentVal.HasMember("bpm"))
				{
					bpm = 120.0f;
					Logger::Warning("Invalid structure, using defaults");
				}
				else bpm = componentVal["bpm"].GetFloat();

				if (!componentVal.HasMember("timeSig"))
				{
					timeSig = { 4, 4 };
					Logger::Warning("Invalid structure, using defaults");
				}
				else timeSig = { componentVal["timeSig"]["top"].GetInt(),
					componentVal["timeSig"]["bot"].GetInt() };

				if (!componentVal.HasMember("playOnAwake"))
				{
					playOnAwake = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else playOnAwake = componentVal["playOnAwake"].GetBool();

				if (!componentVal.HasMember("grp"))
				{
					grp = 0;
					Logger::Warning("Invalid structure, using defaults");
				}
				else grp = componentVal["grp"].GetInt();
			}
			else
			{
				s = componentVal["name"].GetString();

				isActive = componentVal["isActive"].GetBool();

				vol = componentVal["volume"].GetFloat();
				mute = componentVal["mute"].GetBool();
				loop = componentVal["loop"].GetBool();
				bpm = componentVal["bpm"].GetFloat();
				timeSig = { componentVal["timeSig"]["top"].GetInt(),
					componentVal["timeSig"]["bot"].GetInt() };
				playOnAwake = componentVal["playOnAwake"].GetBool();
				grp = componentVal["grp"].GetInt();
			}

			object.AddComponent<AudioComponent>(s);
			object.GetComponent<AudioComponent>().isActive = isActive;

			object.GetComponent<AudioComponent>().volume = vol;
			object.GetComponent<AudioComponent>().mute = mute;
			object.GetComponent<AudioComponent>().loop = loop;
			object.GetComponent<AudioComponent>().bpm = bpm;
			object.GetComponent<AudioComponent>().timeSig = timeSig;
			object.GetComponent<AudioComponent>().playOnAwake = playOnAwake;
			object.GetComponent<AudioComponent>().grp = grp;

			if (s == "")
			{
				Logger::Info("Deserialize: AudioComponent - Empty string ID");
				object.GetComponent<AudioComponent>().data = -1;
				return;
			}

			object.GetComponent<AudioComponent>().Update(registry.GetSystem<AudioSystem>());

			//int index = registry.GetSystem<AudioSystem>().InstAudio(s, grp, bpm, timeSig);

			//object.GetComponent<AudioComponent>().data =
			//	&registry.GetSystem<AudioSystem>().GetAudioInst(index);

			return;
		}

		else if constexpr (std::is_same_v<T, PrefabInstanceComponent>)
		{
			std::string prefabName;
			bool syncWithPrefab;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid layer component structure");
					return;
				}

				if (!componentVal.HasMember("prefab_name"))
				{
					prefabName = "";
					Logger::Warning("Invalid structure, using defaults");
				}
				else prefabName = componentVal["prefab_name"].GetString();

				if (!componentVal.HasMember("sync_prefab"))
				{
					syncWithPrefab = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else syncWithPrefab = componentVal["sync_prefab"].GetBool();
			}
			else
			{
				prefabName = componentVal["prefab_name"].GetString();
				syncWithPrefab = componentVal["sync_prefab"].GetBool();
			}
			object.AddComponent<PrefabInstanceComponent>(prefabName, syncWithPrefab);
			return;
		}

		else if constexpr (std::is_same_v<T, ParentComponent>)
		{
			bool inheritActive, inheritTransform;
			int parentId;

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.IsObject())
				{
					Logger::Error("Invalid parent component structure");
					return;
				}

				if (!componentVal.HasMember("inheritActive"))
				{
					inheritActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else inheritActive = componentVal["inheritActive"].GetBool();

				if (!componentVal.HasMember("inheritTransform"))
				{
					inheritTransform = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else inheritTransform = componentVal["inheritTransform"].GetBool();

				if (!componentVal.HasMember("parentId"))
				{
					parentId = -1;
					Logger::Warning("Invalid structure, using defaults");
				}
				else parentId = componentVal["parentId"].GetInt();
			}
			else
			{
				inheritActive = componentVal["inheritActive"].GetBool();
				inheritTransform = componentVal["inheritTransform"].GetBool();
				parentId = componentVal["parentId"].GetInt();
			}

			// Create parent entity reference
			Entity parent(parentId);
			if (parentId != -1)
			{
				parent.registry = &registry;  // Set the registry reference
			}

			// Add component with just parent reference and flags
			object.AddComponent<ParentComponent>(parent, inheritActive, inheritTransform);

			//auto update = [](Entity obj, Entity par)
			//{
			//	obj.GetComponent<ParentComponent>().UpdateLocalTransform(
			//		obj.GetComponent<TransformComponent>(), par.GetComponent<TransformComponent>());
			//};

   //         // Update local transform
   //         registry.GetSystem<QueueSystem>().Add(std::bind(update, object, parent));

			return;
		}

		else if constexpr (std::is_same_v<T, PersistOnLoadComponent>)
		{
			PersistOnLoadComponent::Deserialize(componentVal, object, GetConfiguration().safeMode);
			return;
		}

		else if constexpr (std::is_same_v<T, ParticleComponent>)
		{
			if (GetConfiguration().safeMode && !componentVal.IsObject())
			{
				Logger::Error("Invalid parent component structure");
				return;
			}

			object.AddComponent<ParticleComponent>();

			auto& component = object.GetComponent<ParticleComponent>();

			if (GetConfiguration().safeMode)
			{
				if (!componentVal.HasMember("isActive"))
				{
					component.isActive = true;
					Logger::Warning("Invalid structure, using defaults");
				}
				else component.isActive = componentVal["isActive"].GetBool();

				if (!componentVal.HasMember("renderOption"))
				{
					component.renderOption = 0;
					Logger::Warning("Invalid structure, using defaults");
				}
				else component.renderOption = componentVal["renderOption"].GetInt();

				if (!componentVal.HasMember("usePhysics"))
				{
					component.usePhysics = false;
					Logger::Warning("Invalid structure, using defaults");
				}
				else component.usePhysics = componentVal["usePhysics"].GetBool();

				if (!componentVal.HasMember("countEmission"))
				{
					component.countEmission = 0;
					Logger::Warning("Invalid structure, using defaults");
				}
				else component.countEmission = componentVal["countEmission"].GetInt();

				if (!componentVal.HasMember("emitters"))
				{
					Logger::Warning("Invalid structure, using defaults");
					return;
				}

				for (int i{}; i < component.emission.size(); ++i)
				{
					if (!componentVal["emitters"].HasMember(std::to_string(i).c_str())) continue;

					component.emission[i].active = true;

					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("loop"))
					{
						component.emission[i].loop = false;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].loop = componentVal["emitters"][std::to_string(i).c_str()]["loop"].GetBool();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("elapsedTime"))
					{
						component.emission[i].elapsedTime = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].elapsedTime = componentVal["emitters"][std::to_string(i).c_str()]["elapsedTime"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("rate"))
					{
						component.emission[i].rate = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].rate = componentVal["emitters"][std::to_string(i).c_str()]["rate"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("tLoop"))
					{
						component.emission[i].tLoop = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].tLoop = componentVal["emitters"][std::to_string(i).c_str()]["tLoop"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minLifeTime"))
					{
						component.emission[i].minLifeTime = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minLifeTime = componentVal["emitters"][std::to_string(i).c_str()]["minLifeTime"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxLifeTime"))
					{
						component.emission[i].maxLifeTime = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxLifeTime = componentVal["emitters"][std::to_string(i).c_str()]["maxLifeTime"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minRot"))
					{
						component.emission[i].minRot = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minRot = componentVal["emitters"][std::to_string(i).c_str()]["minRot"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxRot"))
					{
						component.emission[i].maxRot = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxRot = componentVal["emitters"][std::to_string(i).c_str()]["maxRot"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minSpinVel"))
					{
						component.emission[i].minSpinVel = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minSpinVel = componentVal["emitters"][std::to_string(i).c_str()]["minSpinVel"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxSpinVel"))
					{
						component.emission[i].maxSpinVel = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxSpinVel = componentVal["emitters"][std::to_string(i).c_str()]["maxSpinVel"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minSpinAccel"))
					{
						component.emission[i].minSpinAccel = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minSpinAccel = componentVal["emitters"][std::to_string(i).c_str()]["minSpinAccel"].GetFloat();
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxSpinAccel"))
					{
						component.emission[i].maxSpinAccel = 0.0f;
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxSpinAccel = componentVal["emitters"][std::to_string(i).c_str()]["maxSpinAccel"].GetFloat();

					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minPos") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minPos"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["minPos"].HasMember("y"))
					{
						component.emission[i].minPos = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minPos = { componentVal["emitters"][std::to_string(i).c_str()]["minPos"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minPos"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxPos") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxPos"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["maxPos"].HasMember("y"))
					{
						component.emission[i].maxPos = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxPos = { componentVal["emitters"][std::to_string(i).c_str()]["maxPos"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxPos"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minScale") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minScale"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["minScale"].HasMember("y"))
					{
						component.emission[i].minScale = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minScale = { componentVal["emitters"][std::to_string(i).c_str()]["minScale"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minScale"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxScale") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxScale"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["maxScale"].HasMember("y"))
					{
						component.emission[i].maxScale = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxScale = { componentVal["emitters"][std::to_string(i).c_str()]["maxScale"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxScale"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minVel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minVel"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["minVel"].HasMember("y"))
					{
						component.emission[i].minVel = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minVel = { componentVal["emitters"][std::to_string(i).c_str()]["minVel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minVel"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxVel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxVel"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["maxVel"].HasMember("y"))
					{
						component.emission[i].maxVel = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxVel = { componentVal["emitters"][std::to_string(i).c_str()]["maxVel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxVel"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minScaleVel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minScaleVel"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["minScaleVel"].HasMember("y"))
					{
						component.emission[i].minScaleVel = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minScaleVel = { componentVal["emitters"][std::to_string(i).c_str()]["minScaleVel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minScaleVel"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxScaleVel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxScaleVel"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["maxScaleVel"].HasMember("y"))
					{
						component.emission[i].maxScaleVel = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxScaleVel = { componentVal["emitters"][std::to_string(i).c_str()]["maxScaleVel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxScaleVel"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minAccel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minAccel"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["minAccel"].HasMember("y"))
					{
						component.emission[i].minAccel = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minAccel = { componentVal["emitters"][std::to_string(i).c_str()]["minAccel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minAccel"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxAccel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxAccel"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["maxAccel"].HasMember("y"))
					{
						component.emission[i].maxAccel = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxAccel = { componentVal["emitters"][std::to_string(i).c_str()]["maxAccel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxAccel"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minScaleAccel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minScaleAccel"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["minScaleAccel"].HasMember("y"))
					{
						component.emission[i].minScaleAccel = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minScaleAccel = { componentVal["emitters"][std::to_string(i).c_str()]["minScaleAccel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minScaleAccel"]["y"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxScaleAccel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxScaleAccel"].HasMember("x") || !componentVal["emitters"][std::to_string(i).c_str()]["maxScaleAccel"].HasMember("y"))
					{
						component.emission[i].maxScaleAccel = { 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxScaleAccel = { componentVal["emitters"][std::to_string(i).c_str()]["maxScaleAccel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxScaleAccel"]["y"].GetFloat() };

					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minCol") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minCol"].HasMember("r") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minCol"].HasMember("g") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minCol"].HasMember("b") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minCol"].HasMember("a"))
					{
						component.emission[i].minCol = { 0.0f, 0.0f, 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minCol = {
						componentVal["emitters"][std::to_string(i).c_str()]["minCol"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minCol"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minCol"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minCol"]["a"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxCol") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxCol"].HasMember("r") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxCol"].HasMember("g") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxCol"].HasMember("b") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxCol"].HasMember("a"))
					{
						component.emission[i].maxCol = { 0.0f, 0.0f, 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxCol = {
						componentVal["emitters"][std::to_string(i).c_str()]["maxCol"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxCol"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxCol"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxCol"]["a"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minColVel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minColVel"].HasMember("r") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minColVel"].HasMember("g") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minColVel"].HasMember("b") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minColVel"].HasMember("a"))
					{
						component.emission[i].minColVel = { 0.0f, 0.0f, 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minColVel = {
						componentVal["emitters"][std::to_string(i).c_str()]["minColVel"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColVel"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColVel"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColVel"]["a"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxColVel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"].HasMember("r") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"].HasMember("g") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"].HasMember("b") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"].HasMember("a"))
					{
						component.emission[i].maxColVel = { 0.0f, 0.0f, 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxColVel = {
						componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"]["a"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("minColAccel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"].HasMember("r") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"].HasMember("g") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"].HasMember("b") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"].HasMember("a"))
					{
						component.emission[i].minColAccel = { 0.0f, 0.0f, 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].minColAccel = {
						componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"]["a"].GetFloat() };
					if (!componentVal["emitters"][std::to_string(i).c_str()].HasMember("maxColAccel") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"].HasMember("r") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"].HasMember("g") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"].HasMember("b") ||
						!componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"].HasMember("a"))
					{
						component.emission[i].maxColAccel = { 0.0f, 0.0f, 0.0f, 0.0f };
						Logger::Warning("Invalid structure, using defaults");
					}
					else component.emission[i].maxColAccel = {
						componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"]["a"].GetFloat() };
				}
			}
			else
			{
				component.isActive = componentVal["isActive"].GetBool();
				component.renderOption = componentVal["renderOption"].GetInt();
				component.usePhysics = componentVal["usePhysics"].GetBool();
				component.countEmission = componentVal["countEmission"].GetInt();

				for (int i{}; i < component.countEmission; ++i)
				{
					if (!componentVal["emitters"].HasMember(std::to_string(i).c_str())) continue;

					component.emission[i].active = true;

					component.emission[i].loop = componentVal["emitters"][std::to_string(i).c_str()]["loop"].GetBool();
					component.emission[i].elapsedTime = componentVal["emitters"][std::to_string(i).c_str()]["elapsedTime"].GetFloat();
					component.emission[i].rate = componentVal["emitters"][std::to_string(i).c_str()]["rate"].GetFloat();
					component.emission[i].tLoop = componentVal["emitters"][std::to_string(i).c_str()]["tLoop"].GetFloat();
					component.emission[i].minLifeTime = componentVal["emitters"][std::to_string(i).c_str()]["minLifeTime"].GetFloat();
					component.emission[i].maxLifeTime = componentVal["emitters"][std::to_string(i).c_str()]["maxLifeTime"].GetFloat();
					component.emission[i].minRot = componentVal["emitters"][std::to_string(i).c_str()]["minRot"].GetFloat();
					component.emission[i].maxRot = componentVal["emitters"][std::to_string(i).c_str()]["maxRot"].GetFloat();
					component.emission[i].minSpinVel = componentVal["emitters"][std::to_string(i).c_str()]["minSpinVel"].GetFloat();
					component.emission[i].maxSpinVel = componentVal["emitters"][std::to_string(i).c_str()]["maxSpinVel"].GetFloat();
					component.emission[i].minSpinAccel = componentVal["emitters"][std::to_string(i).c_str()]["minSpinAccel"].GetFloat();
					component.emission[i].maxSpinAccel = componentVal["emitters"][std::to_string(i).c_str()]["maxSpinAccel"].GetFloat();

					component.emission[i].minPos = { componentVal["emitters"][std::to_string(i).c_str()]["minPos"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minPos"]["y"].GetFloat() };
					component.emission[i].maxPos = { componentVal["emitters"][std::to_string(i).c_str()]["maxPos"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxPos"]["y"].GetFloat() };
					component.emission[i].minScale = { componentVal["emitters"][std::to_string(i).c_str()]["minScale"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minScale"]["y"].GetFloat() };
					component.emission[i].maxScale = { componentVal["emitters"][std::to_string(i).c_str()]["maxScale"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxScale"]["y"].GetFloat() };
					component.emission[i].minVel = { componentVal["emitters"][std::to_string(i).c_str()]["minVel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minVel"]["y"].GetFloat() };
					component.emission[i].maxVel = { componentVal["emitters"][std::to_string(i).c_str()]["maxVel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxVel"]["y"].GetFloat() };
					component.emission[i].minScaleVel = { componentVal["emitters"][std::to_string(i).c_str()]["minScaleVel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minScaleVel"]["y"].GetFloat() };
					component.emission[i].maxScaleVel = { componentVal["emitters"][std::to_string(i).c_str()]["maxScaleVel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxScaleVel"]["y"].GetFloat() };
					component.emission[i].minAccel = { componentVal["emitters"][std::to_string(i).c_str()]["minAccel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minAccel"]["y"].GetFloat() };
					component.emission[i].maxAccel = { componentVal["emitters"][std::to_string(i).c_str()]["maxAccel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxAccel"]["y"].GetFloat() };
					component.emission[i].minScaleAccel = { componentVal["emitters"][std::to_string(i).c_str()]["minScaleAccel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minScaleAccel"]["y"].GetFloat() };
					component.emission[i].maxScaleAccel = { componentVal["emitters"][std::to_string(i).c_str()]["maxScaleAccel"]["x"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxScaleAccel"]["y"].GetFloat() };

					component.emission[i].minCol = {
						componentVal["emitters"][std::to_string(i).c_str()]["minCol"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minCol"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minCol"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minCol"]["a"].GetFloat() };
					component.emission[i].maxCol = {
						componentVal["emitters"][std::to_string(i).c_str()]["maxCol"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxCol"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxCol"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxCol"]["a"].GetFloat() };
					component.emission[i].minColVel = {
						componentVal["emitters"][std::to_string(i).c_str()]["minColVel"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColVel"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColVel"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColVel"]["a"].GetFloat() };
					component.emission[i].maxColVel = {
						componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColVel"]["a"].GetFloat() };
					component.emission[i].minColAccel = {
						componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["minColAccel"]["a"].GetFloat() };
					component.emission[i].maxColAccel = {
						componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"]["r"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"]["g"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"]["b"].GetFloat(),
						componentVal["emitters"][std::to_string(i).c_str()]["maxColAccel"]["a"].GetFloat() };
				}
			}

			return;
		}

		else Logger::Error("Unsupported component type for deserialization");
	}
}

================
File: Serialization/SerializeTypes.cpp
================
/******************************************************************************/
/*!
\file   SerializeTypes.cpp
\author Team Popplio
\author Ng Jun Heng Shawn
\contribution Shawn - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/03/13 08:55:22 PM (Last Edit)
\brief
        C++ source file for serializing & deserializing spectific Types

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#include <pch.h>

#include "SerializeTypes.h"

#include "../Utilities/Constants.h"

namespace Popplio
{
    template <>
    void SerializeType<bool>(std::string const& name, rapidjson::Value& value, bool const& field, rapidjson::Document::AllocatorType& allocator)
    {
        rapidjson::Value val;
        val.SetBool(field);
        rapidjson::Value str(name.c_str(), allocator);
        value.AddMember(str, val, allocator);
    }
    template <>
    void SerializeType<std::string>(std::string const& name, rapidjson::Value& value, std::string const& field, rapidjson::Document::AllocatorType& allocator)
    {
        rapidjson::Value val;
        val.SetString(field.c_str(), static_cast<rapidjson::SizeType>(field.length()), allocator);
        rapidjson::Value str(name.c_str(), allocator);
        value.AddMember(str, val, allocator);
    }
    template <>
    void SerializeType<int>(std::string const& name, rapidjson::Value& value, int const& field, rapidjson::Document::AllocatorType& allocator)
    {
        rapidjson::Value val;
        val.SetInt(field);
        rapidjson::Value str(name.c_str(), allocator);
        value.AddMember(str, val, allocator);
    }
    template <>
    void SerializeType<float>(std::string const& name, rapidjson::Value& value, float const& field, rapidjson::Document::AllocatorType& allocator)
    {
        rapidjson::Value val;
        val.SetFloat(field);
        rapidjson::Value str(name.c_str(), allocator);
        value.AddMember(str, val, allocator);
    }
    template <>
    void SerializeType<double>(std::string const& name, rapidjson::Value& value, double const& field, rapidjson::Document::AllocatorType& allocator)
    {
        rapidjson::Value val;
        val.SetDouble(field);
        rapidjson::Value str(name.c_str(), allocator);
        value.AddMember(str, val, allocator);
    }
    template <>
    void SerializeType<char>(std::string const& name, rapidjson::Value& value, char const& field, rapidjson::Document::AllocatorType& allocator)
    {
        rapidjson::Value val;
        val.SetString(&field, static_cast<rapidjson::SizeType>(1), allocator);
        rapidjson::Value str(name.c_str(), allocator);
        value.AddMember(str, val, allocator);
    }
    template <>
    void SerializeType<unsigned int>(std::string const& name, rapidjson::Value& value, unsigned int const& field, rapidjson::Document::AllocatorType& allocator)
    {
        rapidjson::Value val;
        val.SetUint(field);
        rapidjson::Value str(name.c_str(), allocator);
        value.AddMember(str, val, allocator);
    }
}

================
File: Serialization/SerializeTypes.h
================
/******************************************************************************/
/*!
\file   SerializeTypes.h
\author Team Popplio
\author Ng Jun Heng Shawn
\contribution Shawn - 100%
\par    Course : CSD2401 / UXGD2400 / DAA2402
\par    Section : A
\date   2025/03/13 08:55:22 PM (Last Edit)
\brief
        C++ header file for serializing & deserializing spectific Types

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#pragma once

#include <rapidjson/document.h>

namespace Popplio
{
    template <typename T>
    void SerializeType(std::string const& name, rapidjson::Value& value, 
        T const& field, rapidjson::Document::AllocatorType& allocator)
    {
        static_cast<void>(name);
        static_cast<void>(value);
        static_cast<void>(field);
        static_cast<void>(allocator);
        Logger::Warning("Popplio::SerializeType | Type not supported");
    }
    template <>
    void SerializeType<bool>(std::string const& name, rapidjson::Value& value, 
        bool const& field, rapidjson::Document::AllocatorType& allocator);
    template <>
    void SerializeType<std::string>(std::string const& name, rapidjson::Value& value, 
        std::string const& field, rapidjson::Document::AllocatorType& allocator);
    template <>
    void SerializeType<int>(std::string const& name, rapidjson::Value& value, 
        int const& field, rapidjson::Document::AllocatorType& allocator);
    template <>
    void SerializeType<float>(std::string const& name, rapidjson::Value& value, 
        float const& field, rapidjson::Document::AllocatorType& allocator);
    template <>
    void SerializeType<double>(std::string const& name, rapidjson::Value& value, 
        double const& field, rapidjson::Document::AllocatorType& allocator);
    template <>
    void SerializeType<char>(std::string const& name, rapidjson::Value& value, 
        char const& field, rapidjson::Document::AllocatorType& allocator);
    template <>
    void SerializeType<unsigned int>(std::string const& name, rapidjson::Value& value, 
        unsigned int const& field, rapidjson::Document::AllocatorType& allocator);

    namespace
    {
        template <typename T>
        void SerializeObjTypeInternal(std::string const& name, rapidjson::Value& value, rapidjson::Value& objValue,
            rapidjson::Document::AllocatorType& allocator, std::string const& objName, T const& field)
        {
            rapidjson::Value objNameStr(objName.c_str(), allocator);
            objValue.AddMember(objNameStr, field, allocator);
            rapidjson::Value nameStr(name.c_str(), allocator);
            value.AddMember(nameStr, objValue, allocator);
        }
        template <typename T, typename ...Args>
        void SerializeObjTypeInternal(std::string const& name, rapidjson::Value& value, rapidjson::Value& objValue,
            rapidjson::Document::AllocatorType& allocator, std::string const& objName, T const& field, Args... params)
        {
            rapidjson::Value objNameStr(objName.c_str(), allocator);
            objValue.AddMember(objNameStr, field, allocator);
            SerializeObjTypeInternal(name, value, objValue, allocator, params...);
        }
    }
    template <typename ...Args>
    void SerializeObjType(std::string const& name, rapidjson::Value& value, 
        rapidjson::Document::AllocatorType& allocator, Args... params)
    {
        rapidjson::Value obj(rapidjson::kObjectType);
        SerializeObjTypeInternal(name, value, obj, allocator, params...);
    }
    template <typename T>
    void SerializeObjType(std::string const& name, rapidjson::Value& value, 
        rapidjson::Document::AllocatorType& allocator, std::initializer_list<std::string> names, std::initializer_list<T> values)
    {
        //if (names.size() <= 0 || values.size() <= 0) return;
        if (names.size() != values.size())
        {
            Logger::Error("Popplio::SerializeObjType | Names and Values size mismatch");
            return;
        }

        rapidjson::Value obj(rapidjson::kObjectType);
        if (names.size() > 0)
        {
            for (size_t i{}; names.begin() + i != names.end(); ++i)
            {
                SerializeType(*(names.begin() + i), obj, *(values.begin() + i), allocator);
                //rapidjson::Value objNameStr((names.begin() + i)->c_str(), allocator);
                //obj.AddMember(objNameStr, *(values.begin() + i), allocator);
            }
        }
        rapidjson::Value nameStr(name.c_str(), allocator);
        value.AddMember(nameStr, obj, allocator);
    }
    template <typename T>
    void SerializeObjType(std::string const& name, rapidjson::Value& value, 
        rapidjson::Document::AllocatorType& allocator, std::vector<std::string> names, std::vector<T> values)
    {
        //if (names.size() <= 0 || values.size() <= 0) return;
        if (names.size() != values.size())
        {
            Logger::Error("Popplio::SerializeObjType | Names and Values size mismatch");
            return;
        }

        rapidjson::Value obj(rapidjson::kObjectType);
        if (names.size() > 0)
        {
            for (size_t i{}; names.begin() + i != names.end(); ++i)
            {
                SerializeType(*(names.begin() + i), obj, *(values.begin() + i), allocator);
                //rapidjson::Value objNameStr((names.begin() + i)->c_str(), allocator);
                //obj.AddMember(objNameStr, *(values.begin() + i), allocator);
            }
        }
        rapidjson::Value nameStr(name.c_str(), allocator);
        value.AddMember(nameStr, obj, allocator);
    }
    template <typename T>
    void SerializeObjType(std::string const& name, rapidjson::Value& value, 
        rapidjson::Document::AllocatorType& allocator, std::vector<std::pair<std::string, T>> values)
    {
        //if (values.size() <= 0) return;

        rapidjson::Value obj(rapidjson::kObjectType);
        if (values.size() > 0)
        {
            for (std::pair<std::string, T> const& val : values)
            {
                SerializeType(val.first, obj, val.second, allocator);
                //rapidjson::Value objNameStr(val.first.c_str(), allocator);
                //obj.AddMember(objNameStr, val.second, allocator);
            }
        }
        rapidjson::Value nameStr(name.c_str(), allocator);
        value.AddMember(nameStr, obj, allocator);
    }
    template <typename T>
    void SerializeObjType(std::string const& name, rapidjson::Value& value, 
        rapidjson::Document::AllocatorType& allocator, std::vector<std::pair<std::string, std::vector<T>>> values)
    {
        rapidjson::Value obj(rapidjson::kObjectType);
        for (unsigned int i{}; i < values.size(); ++i)
        {
            rapidjson::Value element(rapidjson::kObjectType);
            for (unsigned int j{}; j < values[i].second.size(); ++j)
            {
                SerializeType<T>(std::to_string(j), element, values[i].second[j], allocator);
            }
            rapidjson::Value varStr(values[i].first.c_str(), allocator);
            obj.AddMember(varStr, element, allocator);
        }
        rapidjson::Value nameStr(name.c_str(), allocator);
        value.AddMember(nameStr, obj, allocator);
    }

    template <typename T, typename U>
    void SerializeObjType(std::string const& name, rapidjson::Value& value,
        rapidjson::Document::AllocatorType& allocator, std::vector<std::pair<std::string, std::pair<T, U>>> values)
    {
        //if (values.size() <= 0) return;

        rapidjson::Value obj(rapidjson::kObjectType);
        if (values.size() > 0)
        {
            for (std::pair<std::string, std::pair<T, U>> const& val : values)
            {
                SerializeType(val.first + "_ent", obj, val.second.first, allocator);
                SerializeType(val.first + "_comp", obj, val.second.second, allocator);
                //rapidjson::Value objNameStr(val.first.c_str(), allocator);
                //obj.AddMember(objNameStr, val.second, allocator);
            }
        }
        rapidjson::Value nameStr(name.c_str(), allocator);
        value.AddMember(nameStr, obj, allocator);
    }
    template <typename T, typename U>
    void SerializeObjType(std::string const& name, rapidjson::Value& value,
        rapidjson::Document::AllocatorType& allocator, std::vector<std::pair<std::string, std::vector<std::pair<T, U>>>> values)
    {
        rapidjson::Value obj(rapidjson::kObjectType);
        for (unsigned int i{}; i < values.size(); ++i)
        {
            rapidjson::Value element(rapidjson::kObjectType);
            for (unsigned int j{}; j < values[i].second.size(); ++j)
            {
                SerializeType<T>(std::to_string(j) + "_ent", element, values[i].second[j].first, allocator);
                SerializeType<U>(std::to_string(j) + "_comp", element, values[i].second[j].second, allocator);
            }
            rapidjson::Value varStr(values[i].first.c_str(), allocator);
            obj.AddMember(varStr, element, allocator);
        }
        rapidjson::Value nameStr(name.c_str(), allocator);
        value.AddMember(nameStr, obj, allocator);
    }
}

================
File: UI/FunctionRegistry.h
================
/******************************************************************************/
/*!
\file   FunctionRegistry.h
\author Team Popplio
\author Hafawati Binte Mohd Ali (100%)
\par    Course : CSD2450
\par    Section : A
\date   2025/02/06 09:50:22 AM (Last Edit)
\brief
This header file defines the FunctionRegistry class, which provides a
centralized registry for function callbacks. It allows for dynamic function
registration, retrieval, and execution within the engine's UI and scripting systems.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of Technology is prohibited.
*/
/******************************************************************************/

#pragma once
#include <pch.h>
#include <unordered_map>
#include <functional>
#include <vector>
#include <string>
#include <mutex>

namespace Popplio
{

    /*!*************************************************************************
    \class FunctionRegistry
    \brief A singleton class that manages function callbacks.

    The FunctionRegistry class provides a mechanism to register, retrieve, and
    execute function callbacks by name. This allows dynamic function binding
    for UI interactions, scripting, and other event-driven operations.
    *************************************************************************/
    class FunctionRegistry
    {
    public:

        /*!*************************************************************************
        \brief Retrieves the singleton instance of the FunctionRegistry.

        \return Reference to the FunctionRegistry instance.
        *************************************************************************/
        static FunctionRegistry& GetInstance()
        {
            static FunctionRegistry instance;
            return instance;
        }

        /*!*************************************************************************
        \brief Registers a function callback with a specified name.

        This function allows storing a function pointer in the registry, enabling
        it to be called dynamically when needed.

        \param[in] name The unique identifier for the function.
        \param[in] func The function callback to register.
        *************************************************************************/
        void RegisterFunction(const std::string& name, std::function<void()> func)
        {
            std::lock_guard<std::mutex> lock(mutex_);
            functionMap[name] = func;
        }

        /*!*************************************************************************
        \brief Checks if a function with the given name exists in the registry.

        \param[in] name The function name to check.
        \return True if the function exists, false otherwise.
        *************************************************************************/
        bool HasFunction(const std::string& name) const
        {
            std::lock_guard<std::mutex> lock(mutex_);
            return functionMap.find(name) != functionMap.end();
        }

        /*!*************************************************************************
        \brief Retrieves a registered function by name.

        \param[in] name The function name to retrieve.
        \return The function callback if found, otherwise an empty function.
        *************************************************************************/
        std::function<void()> GetFunction(const std::string& name) const
        {
            std::lock_guard<std::mutex> lock(mutex_);
            auto it = functionMap.find(name);
            if (it != functionMap.end())
            {
                return it->second;
            }
            return std::function<void()>(); // Return an empty function instead of nullptr
        }

        /*!*************************************************************************
        \brief Retrieves all registered function names.

        \return A vector containing the names of all registered functions.
        *************************************************************************/
        std::vector<std::string> GetAllFunctionNames() const
        {
            std::lock_guard<std::mutex> lock(mutex_);
            std::vector<std::string> names;
            for (const auto& pair : functionMap)
            {
                names.push_back(pair.first);
            }
            return names;
        }

    private:
        std::unordered_map<std::string, std::function<void()>> functionMap; /*!< Stores function name-to-callback mappings. */
        mutable std::mutex mutex_; /*!< Ensures thread safety for function registration and retrieval. */

        /*!*************************************************************************
        \brief Private constructor to enforce the singleton pattern.
        *************************************************************************/
        FunctionRegistry() = default;

        /*!*************************************************************************
        \brief Deleted copy constructor to prevent copying of the singleton instance.
        *************************************************************************/
        FunctionRegistry(const FunctionRegistry&) = delete;

        /*!*************************************************************************
        \brief Deleted assignment operator to prevent reassignment of the singleton instance.
        *************************************************************************/
        FunctionRegistry& operator=(const FunctionRegistry&) = delete;
    };

} // namespace Popplio

================
File: UI/UIComponent.h
================
/******************************************************************************

\file   UIComponent.h
\author Team Popplio
\author Hafawati Binte Mohd Ali (100%)
\par    Course : CSD2450
\par    Section : A
\date   2025/03/12 09:50:22 AM (Last Edit)
\brief
This header file defines the UIComponent struct, which represents
interactable UI elements such as buttons, checkboxes, and sliders.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.

******************************************************************************/

#pragma once
#include <functional>
#include "../Math/Vector2D.h"

namespace Popplio {

    /*!*************************************************************************
    \brief Enum representing different UI component types.
    *************************************************************************/
    enum class UIType {
        BUTTON,        
        CHECKBOX,      
        SLIDER_TRACK,  
        SLIDER_HANDLE  
    };

    /*!*************************************************************************
    \brief Struct representing an interactive UI component.

    The UIComponent struct is used to define properties for UI elements such as
    buttons, checkboxes, and sliders. It supports interaction states like hover
    effects and click actions.
    *************************************************************************/
    struct UIComponent {
        bool isActive;  
        UIType type;           

        bool isHovered;       
        bool hasHoverEffect;  

        // Spritesheet properties for UI buttons, if hasHoverEffect is true
        int frameX, frameY;               // Normal frame position in the spritesheet. 
        int hoverFrameX, hoverFrameY;     // Hover state frame position in the spritesheet. 
        int totalColumns;                     // Number of columns in the spritesheet (normal + hover). 
        int totalRows;                        // Number of rows in the spritesheet. 
        float sheetWidth;               
        float sheetHeight;               

        bool checked;        
        float sliderValue;    
        int linkedEntityId;     

        std::vector<std::string> onClickActions;          // List of function names to be called on click. 
        std::vector<std::function<void()>> onClickListeners; // Function pointers for click callbacks. 

        /*!*************************************************************************
        \brief Constructor initializing the UIComponent with a specified type.

        \param[in] type The UIType of the component (default is BUTTON).
        *************************************************************************/
       
        UIComponent(UIType type = UIType::BUTTON)
            : type(type), isActive(true), checked(false), sliderValue(0.5f),
            linkedEntityId(-1), hasHoverEffect(false), isHovered(false),
            frameX(0), frameY(0), hoverFrameX(0), hoverFrameY(0),
            totalColumns(1), totalRows(1), sheetWidth(0.0f), sheetHeight(0.0f) 
        {
            if (type == UIType::BUTTON || type == UIType::CHECKBOX) {
                onClickActions.push_back("None");
            }
        }

        
        UIComponent(UIType type, bool isActive, bool checked, float sliderValue, int linkedEntityId,
            bool hasHoverEffect, int frameX, int frameY, int hoverFrameX, int hoverFrameY,
            int totalColumns, int totalRows, float sheetWidth, float sheetHeight,
            std::vector<std::string> onClickActions)
            : type(type), isActive(isActive), checked(checked), sliderValue(sliderValue),
            linkedEntityId(linkedEntityId), hasHoverEffect(hasHoverEffect),
            frameX(frameX), frameY(frameY), hoverFrameX(hoverFrameX), hoverFrameY(hoverFrameY),
            totalColumns(totalColumns), totalRows(totalRows),
            sheetWidth(sheetWidth), sheetHeight(sheetHeight),
            onClickActions(onClickActions), isHovered(false) {
        }

        /*!*************************************************************************
        \brief Adds a new click event listener.

        \param[in] callback A function to be executed when the UI element is clicked.
        *************************************************************************/
        void AddOnClickListener(std::function<void()> callback) {
            onClickListeners.push_back(callback);
        }

        /*!*************************************************************************
        \brief Clears all registered click event listeners.
        *************************************************************************/
        void ClearOnClickListeners() {
            onClickListeners.clear();
        }

        /*!*************************************************************************
        \brief Computes the UV coordinates for the UI element in the spritesheet.

        This function calculates the UV coordinates based on the current frame
        position in the spritesheet. If the component has a hover effect and is
        hovered, it uses the hover frame coordinates.

        \return glm::vec4 UV coordinates (u1, v1, u2, v2) in normalized texture space.
        *************************************************************************/
        glm::vec4 GetCurrentUV() const {
            if (sheetWidth <= 0 || sheetHeight <= 0 || totalColumns <= 0 || totalRows <= 0) {
                Logger::Error("[UIComponent] Invalid spritesheet dimensions! Using default UVs.");
                return glm::vec4(0.0f, 0.0f, 1.0f, 1.0f);
            }

            float frameWidth = sheetWidth / totalColumns;
            float frameHeight = sheetHeight / totalRows;

            int currentX = isHovered ? hoverFrameX : frameX;
            int currentY = isHovered ? hoverFrameY : frameY;

            if (currentX < 0 || currentX >= totalColumns || currentY < 0 || currentY >= totalRows) {
                Logger::Error("[UIComponent] UV index out of bounds! Using default UVs.");
                return glm::vec4(0.0f, 0.0f, 1.0f, 1.0f);
            }

            float u1 = (currentX * frameWidth) / sheetWidth;
            float v1 = (currentY * frameHeight) / sheetHeight;
            float u2 = ((currentX + 1) * frameWidth) / sheetWidth;
            float v2 = ((currentY + 1) * frameHeight) / sheetHeight;

            Logger::Debug("[UIComponent] UVs: " +
                std::to_string(u1) + ", " +
                std::to_string(v1) + ", " +
                std::to_string(u2) + ", " +
                std::to_string(v2));

            return glm::vec4(u1, v1, u2, v2);
        }
    };
}

================
File: UI/UISystem.cpp
================
/******************************************************************************/
/*!
\file   UISystem.cpp
\author Team Popplio
\author Hafawati Binte Mohd Ali (100%)
\par    Course : CSD2450
\par    Section : A
\date   2025/02/03 09:50:22 AM (Last Edit)
\brief
This header file defines the UISystem class, which manages
interactable UI components in the game engine.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
*/
/******************************************************************************/

#include <pch.h>
#include "UISystem.h"
#include "../Transformation/TransformComponent.h"
#include "../Input/InputSystem.h"


namespace Popplio {

    bool UISystem::wasMousePressed = false;
    PopplioMath::Vec2f UISystem::lastMousePos = PopplioMath::Vec2f(0.0f, 0.0f);
    PopplioMath::Vec2f UISystem::mousePosForTrans = PopplioMath::Vec2f(0.0f, 0.0f);

    UISystem::UISystem(CameraManager& cameraMgr, Registry& registry, GLFWwindow* window): cameraManager(cameraMgr), reg(registry), window(window)
    {
        RequireComponent<UIComponent>();
    }

    void UISystem::Initialize()
    {
        InitializeFunctionRegistry();  // Ensure function registry is initialized
    }


    void UISystem::InitializeButtons()
    {
        auto& registry = FunctionRegistry::GetInstance();

        for (auto& entity : GetSystemEntities())
        {
            if (!entity.HasComponent<UIComponent>()) continue;
            auto& uiComponent = entity.GetComponent<UIComponent>();

            if (uiComponent.type == UIType::BUTTON)
            {
                uiComponent.ClearOnClickListeners(); // Clear old functions

                for (const std::string& action : uiComponent.onClickActions)
                {
                    if (registry.HasFunction(action))  // Ensure function exists
                    {
                        std::function<void()> func = registry.GetFunction(action);
                        if (func)
                        {
                            uiComponent.AddOnClickListener(func);
                        }
                    }
                    else
                    {
                        Logger::Warning("[UI SYSTEM] Function '" + action + "' not found in registry.");
                    }
                }
            }

        }
        Logger::Info("[UI SYSTEM] Buttons initialized with OnClick functions.");
    }

    void UISystem::Update()
    {
        PopplioMath::Vec2f worldPos;

#ifndef IMGUI_DISABLE
        // Get mouse position in screen coordinates
        auto& editor = reg.GetSystem<Editor>();

        if (editor.IsEditorEnabled())
        {
            ImVec2 editorMousePos = ImGui::GetMousePos();
            worldPos = ScreenToWorldPositionGame(editorMousePos);
        }
        else
        {
            PopplioMath::Vec2f mousePos = mousePosForTrans;
            worldPos = cameraManager.GetGameCamera().ScreenToWorld(mousePos);
        }
#else
        PopplioMath::Vec2f mousePos = mousePosForTrans;
        worldPos = cameraManager.GetGameCamera().ScreenToWorld(mousePos);
#endif    

        for (auto& entity : GetSystemEntities())
        {
            if (!entity.GetComponent<ActiveComponent>().isActive) continue;
            if (!entity.HasComponent<UIComponent>() || !entity.HasComponent<TransformComponent>()) continue;

            auto& uiComponent = entity.GetComponent<UIComponent>();
            auto& transform = entity.GetComponent<TransformComponent>();

            float halfWidth = transform.scale.x / 2.0f;
            float halfHeight = transform.scale.y / 2.0f;
            float left = transform.position.x - halfWidth;
            float right = transform.position.x + halfWidth;
            float top = transform.position.y - halfHeight;
            float bottom = transform.position.y + halfHeight;

            bool isMouseOver = (worldPos.x >= left && worldPos.x <= right &&
                worldPos.y >= top && worldPos.y <= bottom);

            // Hover Detection
            if (uiComponent.hasHoverEffect)
            {
                if (isMouseOver && !uiComponent.isHovered)
                {
                    uiComponent.isHovered = true;
                    Logger::Info("Mouse entered UI element!");
                }
                else if (!isMouseOver && uiComponent.isHovered)
                {
                    uiComponent.isHovered = false;
                    Logger::Info("Mouse left UI element!");
                }
            }

            Logger::Debug("[DEBUG] UI Button Actions: ");
            std::string log = "";
            for (const auto& action : uiComponent.onClickActions)
            {
                log += action + ", ";
            }
            Logger::Debug(log);

            auto& registry = FunctionRegistry::GetInstance();

            auto availableFunctions = registry.GetAllFunctionNames();
            Logger::Debug("[DEBUG] Available Functions: ");
            log = "";
            for (const auto& func : availableFunctions)
            {
                log += func + ", ";
            }
            Logger::Debug(log);

            // Click Handling
            if (isMouseClickTriggered || isMouseClickDragged)
            {
                if (isMouseOver)
                {
                    if (uiComponent.type == UIType::CHECKBOX)
                    {
                        uiComponent.checked = !uiComponent.checked;
                    }

                    if (uiComponent.type == UIType::SLIDER_TRACK)
                    {
                        for (auto& handleEntity : GetSystemEntities())
                        {
                            if (!handleEntity.HasComponent<UIComponent>() || !handleEntity.HasComponent<TransformComponent>()) continue;
                            auto& handleUI = handleEntity.GetComponent<UIComponent>();

                            if (handleUI.type == UIType::SLIDER_HANDLE && handleUI.linkedEntityId == entity.GetId())
                            {
                                auto& handleTransform = handleEntity.GetComponent<TransformComponent>();

                                float normalizedX = (worldPos.x - left) / (right - left);
                                normalizedX = glm::clamp(normalizedX, 0.0f, 1.0f);

                                handleUI.sliderValue = normalizedX;
                                handleTransform.position.x = left + (normalizedX * (right - left));

                                if (entity.HasComponent<RenderComponent>())
                                {
                                    auto& trackRender = entity.GetComponent<RenderComponent>();
                                    trackRender.color.r = normalizedX;
                                }

                                break;
                            }
                        }
                    }

                    if (uiComponent.type == UIType::BUTTON)
                    {
                        // Ensure `onClickListeners` is properly assigned from `onClickActions`
                        if (uiComponent.onClickListeners.empty())
                        {
                            uiComponent.onClickListeners.clear();
                            for (const std::string& actionName : uiComponent.onClickActions)
                            {
                                if (registry.HasFunction(actionName))
                                {
                                    uiComponent.onClickListeners.push_back(registry.GetFunction(actionName));
                                }
                            }
                        }

                        // Execute all registered `onClickListeners`
                        if (!uiComponent.onClickListeners.empty())
                        {
                            Logger::Info("[UI SYSTEM] Executing " + 
                                std::to_string(uiComponent.onClickListeners.size()) + " functions");
                            for (auto& callback : uiComponent.onClickListeners)
                            {
                                if (callback)
                                {
                                    callback();
                                }
                                else
                                {
                                    Logger::Error("[UI SYSTEM] Attempted to call a null function.");
                                }
                            }

                        }
                    }
                }
            }
        }
    }


#ifndef IMGUI_DISABLE
    PopplioMath::Vec2f UISystem::ScreenToWorldPositionGame(const ImVec2& screenPos) const
    {
        auto& editor = reg.GetSystem<Editor>(); // Get Editor system from the registry

        // Get the game viewport size and position
        ImVec2 gameViewportSize = { editor.viewportBoundsGame[1].x - editor.viewportBoundsGame[0].x,
                                    editor.viewportBoundsGame[1].y - editor.viewportBoundsGame[0].y };
        ImVec2 gameViewportPos = editor.viewportBoundsGame[0];

        // Normalize screen position within the game viewport
        ImVec2 normalizedPos = { (screenPos.x - gameViewportPos.x) / gameViewportSize.x,
                                  (screenPos.y - gameViewportPos.y) / gameViewportSize.y };

        // Convert normalized position to NDC (Normalized Device Coordinates)
        float ndcX = normalizedPos.x * 2.0f - 1.0f;
        float ndcY = 1.0f - normalizedPos.y * 2.0f; // Invert Y axis

        // Create a 2D vector for the NDC coordinates
        PopplioMath::Vec2f ndcPos(ndcX, ndcY);

        // Get the inverse of the projection and view matrices for the game camera
        PopplioMath::M3x3f inverseProjection = cameraManager.GetGameCamera().GetProjectionMatrix();
        inverseProjection.Inverse();
        PopplioMath::M3x3f inverseView = cameraManager.GetGameCamera().GetViewMatrix();
        inverseView.Inverse();

        // Transform NDC to world coordinates
        float viewX = inverseProjection[0][0] * ndcX + inverseProjection[0][1] * ndcY + inverseProjection[0][2];
        float viewY = inverseProjection[1][0] * ndcX + inverseProjection[1][1] * ndcY + inverseProjection[1][2];
        float viewZ = inverseProjection[2][0] * ndcX + inverseProjection[2][1] * ndcY + inverseProjection[2][2];

        float worldX = inverseView[0][0] * viewX + inverseView[0][1] * viewY + inverseView[0][2] * viewZ;
        float worldY = inverseView[1][0] * viewX + inverseView[1][1] * viewY + inverseView[1][2] * viewZ;

        return PopplioMath::Vec2f(worldX, worldY);
    }
#endif // !IMGUI_DISABLE

    void UISystem::ProcessInput()
    {
        // Ensure inputs are processed correctly each frame
        if (InputSystem::IsMouseButtonTriggered(InputSystem::MouseButton::Left))
        {
            //std::cout << "[UI SYSTEM] Mouse Click Triggered!" << std::endl;
            isMouseClickTriggered = true;  // Store state for Update()
        }
        else
        {
            isMouseClickTriggered = false;
        }

        if (InputSystem::IsMouseButtonDown(InputSystem::MouseButton::Left))
        {
            PopplioMath::Vec2f currentMousePos = InputSystem::GetMouse(); // Ensure this function exists

            if (currentMousePos != lastMousePos) // Mouse moved while held down
            {
                isMouseClickDragged = true;
            }
            else
            {
                isMouseClickDragged = false;
            }

            lastMousePos = currentMousePos;
        }
        else
        {
            isMouseClickDragged = false;
        }

        mousePosForTrans = InputSystem::GetMouse();
    }

    void UISystem::InitializeFunctionRegistry()
    {
        auto& registry = FunctionRegistry::GetInstance();

        // Toggle Pause
        registry.RegisterFunction("PAUSE_GAME", []() {
            Engine::isPaused = !Engine::isPaused;
            Logger::Info("[UI SYSTEM] Game " + Engine::isPaused ? "Paused" : "Resumed");
            });
        

        registry.RegisterFunction("QUIT", [this]()
        {
            if (window)
            {
                // This triggers the main engine loop to exit 
                glfwSetWindowShouldClose(window, true);
                Logger::Info("[UI SYSTEM] QUIT triggered, setting GLFW window close flag.");
            }
        });

        registry.RegisterFunction("None", []() {
            Logger::Info("[UI SYSTEM] Does Nothing");
        });

         ///////////
        // DEMO ///
       ///////////

        static int textClickCount = 0;
        // Update a text component dynamically
        registry.RegisterFunction("UPDATE_TEXT", [this]() {  
            auto& allEntities = reg.GetAllEntities();
            for (auto& entity : allEntities)  // Loop through ALL entities
            {
                if (!entity.GetComponent<ActiveComponent>().isActive) continue;
                if (entity.HasComponent<TextComponent>())
                {
                    if (entity.HasTag("comboText"))  // Match the tag
                    {
                        
                        auto& textComp = entity.GetComponent<TextComponent>();
                        textClickCount++;  // Increment count
                        textComp.text = std::to_string(textClickCount); // Update text
                        Logger::Info("[UI SYSTEM] Updated text to: " + textComp.text);
                        break;  // Only update the first matching entity
                    }
                }
            }
        });

        // Open Settings Popup
        registry.RegisterFunction("OPEN_SETTINGS", []() {
            Logger::Info("[UI SYSTEM] Opening Settings Popup...");
            // TODO: Implement UI Popup System
            });
    }

}

================
File: UI/UISystem.h
================
/******************************************************************************
\file   UISystem.h
\author Team Popplio
\author Hafawati Binte Mohd Ali (100%)
\par    Course : CSD2450
\par    Section : A
\date   2025/02/03 09:50:22 AM (Last Edit)
\brief
This header file defines the UISystem class, which manages
interactable UI components in the game engine.

Copyright (C) 2024 - 2025 DigiPen Institute of Technology.
Reproduction or disclosure of this file or its contents
without the prior written consent of DigiPen Institute of
Technology is prohibited.
******************************************************************************/

#pragma once
#include "UIComponent.h"
#include "FunctionRegistry.h"
#include "../Input/InputSystem.h"
#ifndef IMGUI_DISABLE
#include "../Editor/Editor.h"
#endif
#include "../Camera/CameraManager.h"
#include "../Camera/GameCamera.h"
#include "../Engine/Engine.h"


namespace Popplio {
    // System responsible for handling UI components and interactions
    class UISystem : public System {
    public:
        /*!*************************************************************************
        \brief Constructor for the UISystem class.

        \param[in] cameraMgr
        Reference to the CameraManager.
        \param[in] registry
        Reference to the entity-component system registry.
        \param[in] window
        Pointer to the GLFW window.
        *************************************************************************/
        UISystem(CameraManager& cameraMgr, Registry& registry, GLFWwindow* window);

        /*!*************************************************************************
        \brief Updates the UI system.

        This function is responsible for handling UI interactions, including
        checking hover states, processing click events, and triggering callbacks.
        *************************************************************************/
        void Update();

        /*!*************************************************************************
        \brief Initializes the UI system.

        This function ensures all necessary UI components and systems are set up,
        including initializing function registries for UI elements.
        *************************************************************************/
        void Initialize();

        /*!*************************************************************************
        \brief Initializes button components in the UI system.

        This function assigns appropriate callbacks to UI buttons based on their
        configured actions. It ensures that buttons respond to interactions by
        registering functions to execute on click events.
        *************************************************************************/
        void InitializeButtons();


        /*!*************************************************************************
        \brief Converts screen coordinates to world coordinates in the game viewport.

        \param[in] screenPos
        Screen position in ImGui coordinates.

        \return PopplioMath::Vec2f
        World coordinates corresponding to the screen position.
        *************************************************************************/
#ifndef IMGUI_DISABLE
        PopplioMath::Vec2f ScreenToWorldPositionGame(const ImVec2& screenPos) const;
#endif // !IMGUI_DISABLE

        /*!*************************************************************************
        \brief Processes user input for UI interactions.

        This function handles mouse interactions with UI components, including
        detecting clicks, drags, and updating hover states.
        *************************************************************************/
        void ProcessInput();

        /*!*************************************************************************
        \brief Initializes function registry for UI event callbacks.

        This function registers predefined functions in the FunctionRegistry,
        allowing UI elements to execute specific actions when interacted with.
        *************************************************************************/
        void InitializeFunctionRegistry();

    private:
        static bool wasMousePressed;
        static PopplioMath::Vec2f lastMousePos;
        static PopplioMath::Vec2f mousePosForTrans;
        bool isMouseClickTriggered = false;
        bool isMouseClickDragged = false;

        CameraManager& cameraManager; // Reference to the camera manager for coordinate transformations
        Registry& reg;                // Reference to the entity-component system registry
        GLFWwindow* window;
    };
}



================================================================
End of Codebase
================================================================
